<!DOCTYPE html>
<html lang="ru" xmlns:th="http://www.thymeleaf.org" xmlns:sec="http://www.thymeleaf.org/extras/spring-security">
<head>
    <meta charset="UTF-8">
    <title>Первичные данные объекта</title>
    <link rel="stylesheet" href="/css/main.css">
</head>
<body>
<header class="topbar">
    <h1>Object Manager</h1>
    <nav>
        <a href="/objects" class="active">Объекты</a>
        <a href="/customers">Заказчики</a>
        <a href="/admin" sec:authorize="hasRole('ADMIN')">Администрирование</a>
        <form method="post" action="/logout">
            <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}">
            <button type="submit" class="link-button">Выход</button>
        </form>
    </nav>
</header>
<main class="content">
    <section class="card">
        <div class="card-header">
            <h2 th:text="${object.name}">Объект</h2>
            <a class="button secondary" th:href="@{'/objects/' + ${object.id}}">Назад к объекту</a>
        </div>
        <p class="muted">Заполняйте первичные данные по шагам: сначала оборудование, затем точки подключения, после чего сгруппируйте устройства и задайте монтажные материалы.</p>
    </section>

    <form class="card wizard-form" method="post" th:action="@{'/objects/' + ${object.id} + '/primary-data/wizard'}" th:object="${wizardForm}" th:attr="data-initial-step=${wizardActiveStep}">
        <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}">
        <nav class="wizard-progress">
            <button type="button" class="wizard-progress-step active" data-step-index="0">1. Количество</button>
            <button type="button" class="wizard-progress-step" data-step-index="1">2. Места установки</button>
            <button type="button" class="wizard-progress-step" data-step-index="2">3. Узлы</button>
            <button type="button" class="wizard-progress-step" data-step-index="3">4. Рабочие места</button>
            <button type="button" class="wizard-progress-step" data-step-index="4">5. Соединения</button>
            <button type="button" class="wizard-progress-step" data-step-index="5">6. Группировка линий</button>
            <button type="button" class="wizard-progress-step" data-step-index="6">7. Материалы</button>
            <button type="button" class="wizard-progress-step" data-step-index="7">8. Узлы и ящики</button>
            <button type="button" class="wizard-progress-step" data-step-index="8">9. Наполнение рабочих мест</button>
        </nav>

        <div class="alert" th:if="${#fields.hasGlobalErrors()}">
            <p th:each="error : ${#fields.globalErrors()}" th:text="${error.defaultMessage}"></p>
        </div>

        <div class="wizard-panels">
            <section class="wizard-step" data-step-index="0">
                <h3>Шаг 1. Количество устройств, узлов и рабочих мест</h3>
                <p class="muted">Сначала укажите общее количество устройств, узлов и рабочих мест. Эти значения помогут контролировать полноту данных на последующих этапах.</p>
                <div class="grid">
                    <div>
                        <label>Количество устройств</label>
                        <input type="number" min="0" step="1" th:field="*{totalDeviceCount}" placeholder="Например, 12">
                        <p class="field-error" th:if="${#fields.hasErrors('totalDeviceCount')}" th:errors="*{totalDeviceCount}"></p>
                    </div>
                    <div>
                        <label>Количество узлов</label>
                        <input type="number" min="0" step="1" th:field="*{totalNodeCount}" placeholder="Например, 4">
                        <p class="field-error" th:if="${#fields.hasErrors('totalNodeCount')}" th:errors="*{totalNodeCount}"></p>
                    </div>
                    <div>
                        <label>Количество рабочих мест</label>
                        <input type="number" min="0" step="1" th:field="*{workspaceCount}" placeholder="Например, 3">
                        <p class="field-error" th:if="${#fields.hasErrors('workspaceCount')}" th:errors="*{workspaceCount}"></p>
                    </div>
                </div>
                <p class="muted small">Количество устройств сверяется с суммарным числом устройств по карточкам, количество узлов — с уникальными точками подключения, а количество рабочих мест — с карточками постов наблюдения.</p>
            </section>

            <section class="wizard-step" data-step-index="1" hidden>
                <h3>Шаг 2. Места установки устройств</h3>
                <p class="muted">Опишите каждое место установки и количество оборудования на нём. Пока просто зафиксируйте понятные названия камер или других устройств, чтобы затем привязать их к узлам.</p>
                <div data-role="device-step-placeholder" data-phase="naming">
                    <div id="device-step">
                        <div id="device-groups" class="stack">
                            <div class="device-group card nested-card" th:each="group, iter : *{deviceGroups}" th:data-index="${iter.index}">
                                <header class="device-group-header">
                                    <h4>Устройство №<span data-role="device-number" th:text="${iter.index + 1}">1</span></h4>
                                </header>
                                <div class="grid" data-phase="naming">
                                    <div>
                                        <label>Место установки / название камеры</label>
                                        <input type="text" th:field="*{deviceGroups[__${iter.index}__].installLocation}" data-field="installLocation" placeholder="Например, Камера на входе">
                                    </div>
                                </div>
                                <input type="hidden"
                                       th:field="*{deviceGroups[__${iter.index}__].deviceCount}"
                                       data-field="deviceCount">
                                <div class="grid" data-phase="details">
                                    <div>
                                        <label>Тип устройства</label>
                                        <select th:field="*{deviceGroups[__${iter.index}__].deviceTypeId}" data-field="deviceTypeId">
                                            <option value="">Не выбрано</option>
                                            <option th:each="type : ${deviceTypes}"
                                                    th:value="${type.id}"
                                                    th:text="${type.name}"
                                                    th:attr="data-required-cables=${deviceTypeRequirements[type.id]} != null ? deviceTypeRequirements[type.id] : ''"
                                                    th:data-camera="${cameraDeviceFlags[type.id]} ? 'true' : 'false'"></option>
                                        </select>
                                    </div>
                                </div>
                                <input type="hidden"
                                       th:field="*{deviceGroups[__${iter.index}__].installSurfaceCategory}"
                                       data-field="installSurfaceCategory">
                                <input type="hidden"
                                       th:field="*{deviceGroups[__${iter.index}__].connectionPoint}"
                                       data-field="connectionPoint">
                                <div class="grid camera-settings" data-role="camera-fields" data-phase="details"
                                     th:classappend="${!(group.deviceTypeId != null and cameraDeviceFlags[group.deviceTypeId])
                                                        and #strings.isEmpty(group.cameraAccessory)
                                                        and group.cameraViewingDepth == null} ? ' is-hidden' : ''">
                                    <div>
                                        <label>Комплектация камеры (адаптер или пластиковая коробка)</label>
                                        <select th:field="*{deviceGroups[__${iter.index}__].cameraAccessory}"
                                                data-field="cameraAccessory"
                                                th:disabled="${!(group.deviceTypeId != null and cameraDeviceFlags[group.deviceTypeId])}">
                                            <option value="">Не выбрана</option>
                                            <option th:each="option : ${cameraOptions}" th:value="${option.code}" th:text="${option.displayName}"></option>
                                        </select>
                                        <p class="field-error"
                                           th:if="${#fields.hasErrors('deviceGroups[' + iter.index + '].cameraAccessory')}"
                                           th:errors="*{deviceGroups[__${iter.index}__].cameraAccessory}"></p>
                                    </div>
                                    <div>
                                        <label>Глубина просмотра (м)</label>
                                        <input type="number" min="0" step="0.1"
                                               th:field="*{deviceGroups[__${iter.index}__].cameraViewingDepth}"
                                               data-field="cameraViewingDepth"
                                               th:disabled="${!(group.deviceTypeId != null and cameraDeviceFlags[group.deviceTypeId])}"
                                               placeholder="Например, 40">
                                        <p class="field-error"
                                           th:if="${#fields.hasErrors('deviceGroups[' + iter.index + '].cameraViewingDepth')}"
                                           th:errors="*{deviceGroups[__${iter.index}__].cameraViewingDepth}"></p>
                                    </div>
                                </div>
                                <div class="grid cable-settings" data-role="cable-fields" data-phase="details">
                                    <div class="cable-field" data-cable-function="SIGNAL">
                                        <label th:attr="data-default-label=${cableFunctionLabels[signalCableFunction]}"
                                               th:text="${cableFunctionLabels[signalCableFunction]}">Сигнальный кабель</label>
                                        <select th:field="*{deviceGroups[__${iter.index}__].signalCableTypeId}" data-field="signalCableTypeId">
                                            <option value="">Не выбран</option>
                                            <option th:each="cable : ${cableTypes}"
                                                    th:if="${cable.function == signalCableFunction}"
                                                    th:value="${cable.id}"
                                                    th:text="${cable.name}"></option>
                                        </select>
                                        <p class="field-error"
                                           th:if="${#fields.hasErrors('deviceGroups[' + iter.index + '].signalCableTypeId')}"
                                           th:errors="*{deviceGroups[__${iter.index}__].signalCableTypeId}"></p>
                                    </div>
                                    <div class="cable-field" data-cable-function="LOW_VOLTAGE_POWER">
                                        <label th:text="${cableFunctionLabels[lowVoltageCableFunction]}">Кабель для слаботочного питания</label>
                                        <select th:field="*{deviceGroups[__${iter.index}__].lowVoltageCableTypeId}" data-field="lowVoltageCableTypeId">
                                            <option value="">Не выбран</option>
                                            <option th:each="cable : ${cableTypes}"
                                                    th:if="${cable.function == lowVoltageCableFunction}"
                                                    th:value="${cable.id}"
                                                    th:text="${cable.name}"></option>
                                        </select>
                                        <p class="field-error"
                                           th:if="${#fields.hasErrors('deviceGroups[' + iter.index + '].lowVoltageCableTypeId')}"
                                           th:errors="*{deviceGroups[__${iter.index}__].lowVoltageCableTypeId}"></p>
                                    </div>
                                </div>
                                <input type="hidden"
                                       th:field="*{deviceGroups[__${iter.index}__].distanceToConnectionPoint}"
                                       data-field="distanceToConnectionPoint">
                                <button type="button" class="link-button danger remove-device" data-phase="naming" th:if="${iter.index > 0}">Удалить</button>
                            </div>
                        </div>
                        <template id="device-group-template">
                            <div class="device-group card nested-card">
                                <header class="device-group-header">
                                    <h4>Устройство №<span data-role="device-number">1</span></h4>
                                </header>
                                <div class="grid" data-phase="naming">
                                    <div>
                                        <label>Место установки / название камеры</label>
                                        <input type="text" data-field="installLocation" placeholder="Например, Камера на входе">
                                    </div>
                                </div>
                                <input type="hidden" data-field="deviceCount" value="1">
                                <div class="grid" data-phase="details">
                                    <div>
                                        <label>Тип устройства</label>
                                        <select data-field="deviceTypeId">
                                            <option value="">Не выбрано</option>
                                            <option th:each="type : ${deviceTypes}"
                                                    th:value="${type.id}"
                                                    th:text="${type.name}"
                                                    th:attr="data-required-cables=${deviceTypeRequirements[type.id]} != null ? deviceTypeRequirements[type.id] : ''"
                                                    th:data-camera="${cameraDeviceFlags[type.id]} ? 'true' : 'false'"></option>
                                        </select>
                                    </div>
                                </div>
                                <input type="hidden" data-field="installSurfaceCategory">
                                <input type="hidden" data-field="connectionPoint">
                                <div class="grid camera-settings is-hidden" data-role="camera-fields" data-phase="details">
                                    <div>
                                        <label>Комплектация камеры (адаптер или пластиковая коробка)</label>
                                        <select data-field="cameraAccessory">
                                            <option value="">Не выбрана</option>
                                            <option th:each="option : ${cameraOptions}" th:value="${option.code}" th:text="${option.displayName}"></option>
                                        </select>
                                    </div>
                                    <div>
                                        <label>Глубина просмотра (м)</label>
                                        <input type="number" min="0" step="0.1" data-field="cameraViewingDepth" placeholder="Например, 40">
                                    </div>
                                </div>
                                <div class="grid cable-settings is-hidden" data-role="cable-fields" data-phase="details">
                                    <div class="cable-field" data-cable-function="SIGNAL">
                                        <label th:attr="data-default-label=${cableFunctionLabels[signalCableFunction]}"
                                               th:text="${cableFunctionLabels[signalCableFunction]}">Сигнальный кабель</label>
                                        <select data-field="signalCableTypeId">
                                            <option value="">Не выбран</option>
                                            <option th:each="cable : ${cableTypes}"
                                                    th:if="${cable.function == signalCableFunction}"
                                                    th:value="${cable.id}"
                                                    th:text="${cable.name}"></option>
                                        </select>
                                    </div>
                                    <div class="cable-field" data-cable-function="LOW_VOLTAGE_POWER">
                                        <label th:text="${cableFunctionLabels[lowVoltageCableFunction]}">Кабель для слаботочного питания</label>
                                        <select data-field="lowVoltageCableTypeId">
                                            <option value="">Не выбран</option>
                                            <option th:each="cable : ${cableTypes}"
                                                    th:if="${cable.function == lowVoltageCableFunction}"
                                                    th:value="${cable.id}"
                                                    th:text="${cable.name}"></option>
                                        </select>
                                    </div>
                                </div>
                                <input type="hidden" data-field="distanceToConnectionPoint">
                                <button type="button" class="link-button danger remove-device" data-phase="naming">Удалить</button>
                            </div>
                        </template>
                        <button type="button" class="button secondary" id="add-device-group" data-phase="naming">Добавить устройство</button>
                    </div>
                </div>
            </section>

            <section class="wizard-step" data-step-index="2" hidden>
                <h3>Шаг 3. Названия узлов</h3>
                <p class="muted">Создайте список узлов подключения и задайте им понятные названия. Эти названия будут использоваться для привязки устройств и рабочих мест.</p>
                <div data-role="connection-step-placeholder" data-phase="names"></div>
            </section>

            <section class="wizard-step" data-step-index="3" hidden>
                <h3>Шаг 4. Рабочие места</h3>
                <p class="muted">Назовите каждое рабочее место и при необходимости укажите, где оно находится. Позже вы сможете привязать их к узлам и заполнить оборудование.</p>
                <div data-role="workspace-step-placeholder" data-phase="names"></div>
            </section>

            <section class="wizard-step" data-step-index="4" hidden>
                <h3>Шаг 5. Соединения устройств и узлов</h3>
                <p class="muted">Соедините устройства, узлы и рабочие места. Перетащите элемент на нужный узел, чтобы зафиксировать связь, или перенесите его в область сброса для отвязки. После привязки задайте длины линий и при необходимости уточните параметры устройств.</p>
                <div class="node-diagram-panel">
                    <div class="node-diagram-board" id="node-diagram-board">
                        <svg class="node-diagram-links" id="node-diagram-links" preserveAspectRatio="none"></svg>
                        <div class="node-diagram-layer" id="node-diagram-layer"></div>
                        <p class="node-diagram-empty" id="node-diagram-empty">Добавьте устройства и узлы, чтобы построить схему.</p>
                    </div>
                    <aside class="node-diagram-sidebar">
                        <h4>Подсказки</h4>
                        <ul class="muted small">
                            <li>Узлы создаются автоматически по заполненным названиям на шаге 3.</li>
                            <li>Камеры и другие устройства появляются после заполнения шагов 1–2.</li>
                            <li>Перетаскивайте элементы, чтобы расположить их на холсте, а также перетаскивайте устройства и рабочие места на узлы для связи.</li>
                        </ul>
                        <button type="button" class="button tertiary" id="node-diagram-reset">Сбросить расположение</button>
                    </aside>
                </div>
                <div class="node-diagram-unlink" id="node-unlink-area">Перетащите сюда устройство, узел или рабочее место, чтобы отвязать их связи.</div>
                <input type="hidden" id="node-diagram-data" th:field="*{nodeConnectionDiagram}">
                <p class="field-error" th:if="${#fields.hasErrors('nodeConnectionDiagram')}" th:errors="*{nodeConnectionDiagram}"></p>
                <div class="node-diagram-notes">
                    <label for="node-connection-method">Текстовое описание соединения узлов</label>
                    <textarea id="node-connection-method" th:field="*{nodeConnectionMethod}" rows="4" placeholder="Например, узлы А и Б соединяются через существующий кабельный лоток."></textarea>
                    <p class="field-error" th:if="${#fields.hasErrors('nodeConnectionMethod')}" th:errors="*{nodeConnectionMethod}"></p>
                    <p class="muted small">Текст используется в отчёте наряду с графической схемой.</p>
                </div>
                <div class="card nested-card device-details" data-role="connection-details">
                    <h4>Параметры подключаемых устройств</h4>
                    <p class="muted">После привязки устройств к узлам уточните поверхности монтажа, типы кабелей и расстояния до точки подключения.</p>
                    <div data-role="device-step-placeholder" data-phase="details"></div>
                    <p class="muted small">Если расстояние не указано, в расчётах будут использованы значения по умолчанию из паспортов устройств.</p>
                </div>
            </section>

            <section class="wizard-step" data-step-index="5" hidden>
                <h3>Шаг 6. Группировка линий</h3>
                <p class="muted">Сгруппируйте устройства по линиям прокладки. Эти группы понадобятся для расчёта материалов и распределения нагрузки по узлам.</p>
                <div class="grouping-board">
                    <section class="grouping-source">
                        <h4>Устройства</h4>
                        <p class="muted small">Перетащите устройство в нужную группу.</p>
                        <div id="grouping-pool" class="grouping-pool">
                            <div class="device-chip" th:each="group, iter : *{deviceGroups}" th:data-index="${iter.index}" draggable="true">
                                <input type="hidden" th:field="*{deviceGroups[__${iter.index}__].groupLabel}" data-field="groupLabel">
                                <p class="muted small" data-role="summary">Заполните информацию на первом шаге, чтобы увидеть сводку.</p>
                                <p class="muted small" data-role="assignment">Группа: <span data-role="assignment-label">не задана</span></p>
                            </div>
                        </div>
                    </section>
                    <section class="grouping-destinations">
                        <div class="grouping-controls">
                            <button type="button" class="button secondary" id="add-group">Создать группу</button>
                        </div>
                        <p class="field-error" id="grouping-warning" hidden></p>
                        <p class="muted small" id="grouping-empty">Создайте группу и перетащите в неё устройства.</p>
                        <div id="grouping-columns" class="grouping-columns"></div>
                    </section>
                </div>
                <template id="group-column-template">
                    <div class="group-column card nested-card" data-group-label="">
                        <header class="group-header">
                            <input type="text" class="group-name-input" placeholder="Новая группа">
                            <button type="button" class="link-button danger remove-group">Удалить</button>
                        </header>
                        <p class="muted small" data-role="capacity">Длина линии: 0 м</p>
                        <p class="muted small" data-role="connection-hint">Узел: не выбран</p>
                        <div class="group-dropzone" data-role="dropzone"></div>
                    </div>
                </template>
                <template id="device-chip-template">
                    <div class="device-chip" draggable="true">
                        <input type="hidden" data-field="groupLabel">
                        <p class="muted small" data-role="summary">Заполните информацию на первом шаге, чтобы увидеть сводку.</p>
                        <p class="muted small" data-role="assignment">Группа: <span data-role="assignment-label">не задана</span></p>
                    </div>
                </template>
            </section>

            <section class="wizard-step" data-step-index="6" hidden>
                <h3>Шаг 7. Материалы</h3>
                <p class="muted">Для каждой созданной группы укажите необходимые материалы. Если группа не требует материалов, оставьте поля пустыми.</p>
                <p class="muted" id="materials-empty" th:if="${#lists.isEmpty(wizardForm.materialGroups)}">Создайте хотя бы одну группу устройств на предыдущем шаге, чтобы назначить материалы.</p>
                <div id="material-groups" class="stack">
                    <div class="material-group card nested-card" th:each="group, gIndex : *{materialGroups}" th:data-group-label="${group.groupLabel != null ? group.groupLabel : ''}">
                        <input type="hidden" th:field="*{materialGroups[__${gIndex.index}__].groupLabel}" data-field="groupLabel">
                        <header class="group-header">
                            <h4 class="group-label">Группа: <span data-role="label" th:text="${group.groupLabel}">Без названия</span></h4>
                        </header>
                        <p class="field-error capacity-warning" data-role="capacity-warning" hidden>Длина материалов превышает допустимую для этой группы.</p>
                        <div class="stack materials-container" th:id="${'material-rows-' + gIndex.index}">
                            <div class="material-row" th:each="usage, uIndex : *{materialGroups[__${gIndex.index}__].materials}" th:data-index="${uIndex.index}">
                                <div class="grid">
                                    <div>
                                        <label>Материал</label>
                                        <select th:field="*{materialGroups[__${gIndex.index}__].materials[__${uIndex.index}__].materialId}" data-field="materialId">
                                            <option value="">Не выбран</option>
                                            <option th:each="material : ${installationMaterials}" th:value="${material.id}" th:text="${material.name + (#strings.isEmpty(material.unit) ? '' : ' (' + material.unit + ')')}"></option>
                                        </select>
                                    </div>
                                    <div>
                                        <label>Объем / длина</label>
                                        <input type="text" th:field="*{materialGroups[__${gIndex.index}__].materials[__${uIndex.index}__].amount}" data-field="amount" placeholder="25 м, 4 шт...">
                                    </div>
                                    <div>
                                        <label>Категория прокладки</label>
                                        <select th:field="*{materialGroups[__${gIndex.index}__].materials[__${uIndex.index}__].layingSurfaceCategory}" data-field="layingSurfaceCategory">
                                            <option value="">Не выбрана</option>
                                            <option th:each="surface : ${surfaceTypes}" th:value="${surface.code}" th:text="${surface.displayName}"></option>
                                        </select>
                                    </div>
                                    <div>
                                        <label>Доп. описание прокладки</label>
                                        <input type="text" th:field="*{materialGroups[__${gIndex.index}__].materials[__${uIndex.index}__].layingSurface}" data-field="layingSurface" placeholder="По стене, в коробе...">
                                    </div>
                                </div>
                                <button type="button" class="link-button danger remove-material" th:if="${uIndex.index > 0}">Удалить материал</button>
                            </div>
                        </div>
                        <button type="button" class="button secondary add-material">Добавить материал</button>
                    </div>
                </div>
                <template id="material-group-template">
                    <div class="material-group card nested-card">
                        <input type="hidden" data-field="groupLabel">
                        <header class="group-header">
                            <h4 class="group-label">Группа: <span data-role="label">Без названия</span></h4>
                        </header>
                        <p class="field-error capacity-warning" data-role="capacity-warning" hidden>Длина материалов превышает допустимую для этой группы.</p>
                        <div class="stack materials-container">
                            <div class="material-row">
                                <div class="grid">
                                    <div>
                                        <label>Материал</label>
                                        <select data-field="materialId">
                                            <option value="">Не выбран</option>
                                            <option th:each="material : ${installationMaterials}" th:value="${material.id}" th:text="${material.name + (#strings.isEmpty(material.unit) ? '' : ' (' + material.unit + ')')}"></option>
                                        </select>
                                    </div>
                                    <div>
                                        <label>Объем / длина</label>
                                        <input type="text" data-field="amount" placeholder="25 м, 4 шт...">
                                    </div>
                                    <div>
                                        <label>Категория прокладки</label>
                                        <select data-field="layingSurfaceCategory">
                                            <option value="">Не выбрана</option>
                                            <option th:each="surface : ${surfaceTypes}" th:value="${surface.code}" th:text="${surface.displayName}"></option>
                                        </select>
                                    </div>
                                    <div>
                                        <label>Доп. описание прокладки</label>
                                        <input type="text" data-field="layingSurface" placeholder="По стене, в коробе...">
                                    </div>
                                </div>
                                <button type="button" class="link-button danger remove-material">Удалить материал</button>
                            </div>
                        </div>
                        <button type="button" class="button secondary add-material">Добавить материал</button>
                    </div>
                </template>
                <template id="material-row-template">
                    <div class="material-row">
                        <div class="grid">
                            <div>
                                <label>Материал</label>
                                <select data-field="materialId">
                                    <option value="">Не выбран</option>
                                    <option th:each="material : ${installationMaterials}" th:value="${material.id}" th:text="${material.name + (#strings.isEmpty(material.unit) ? '' : ' (' + material.unit + ')')}"></option>
                                </select>
                            </div>
                            <div>
                                <label>Объем / длина</label>
                                <input type="text" data-field="amount" placeholder="25 м, 4 шт...">
                            </div>
                            <div>
                                <label>Категория прокладки</label>
                                <select data-field="layingSurfaceCategory">
                                    <option value="">Не выбрана</option>
                                    <option th:each="surface : ${surfaceTypes}" th:value="${surface.code}" th:text="${surface.displayName}"></option>
                                </select>
                            </div>
                            <div>
                                <label>Доп. описание прокладки</label>
                                <input type="text" data-field="layingSurface" placeholder="По стене, в коробе...">
                            </div>
                        </div>
                        <button type="button" class="link-button danger remove-material">Удалить материал</button>
                    </div>
                </template>
            </section>

            <section class="wizard-step" data-step-index="7" hidden>
                <h3>Шаг 8. Узлы и ящики</h3>
                <p class="muted">Проверьте узлы подключения: выберите монтажные ящики, укажите расстояния до точек запитки и дополнительные элементы. При необходимости ниже можно добавить отдельные монтажные позиции.</p>
                <div id="connection-step" class="stack">
                    <p class="muted" id="connection-empty" th:if="${#lists.isEmpty(wizardForm.connectionPoints)}" data-phase="names details">Заполните устройства и названия узлов на шаге 2, чтобы продолжить.</p>
                    <div id="connection-points" class="stack">
                        <div class="connection-point card nested-card" th:each="point, iter : *{connectionPoints}" th:data-connection-name="${point.name != null ? point.name : ''}">
                            <header class="connection-point-header" data-phase="names details">
                                <button type="button" class="link-button danger remove-connection" th:if="${iter.index > 0}">Удалить</button>
                            </header>
                            <div class="grid">
                                <div data-phase="names details">
                                    <label>Название точки</label>
                                    <input type="text" th:field="*{connectionPoints[__${iter.index}__].name}" data-field="name" placeholder="Распред. коробка №1">
                                    <p class="field-error" data-role="error" hidden>Название должно быть уникальным</p>
                                </div>
                                <div data-phase="details">
                                    <label>Монтажный короб / ящик</label>
                                    <select th:field="*{connectionPoints[__${iter.index}__].mountingElementId}" data-field="mountingElementId">
                                        <option value="">Не выбран</option>
                                        <option th:each="element : ${mountingElements}" th:value="${element.id}" th:text="${element.name}"></option>
                                    </select>
                                </div>
                            </div>
                            <div class="grid">
                                <div data-phase="details">
                                    <label>Расстояние до точки запитки (м)</label>
                                    <input type="number" min="0" step="0.1" th:field="*{connectionPoints[__${iter.index}__].distanceToPower}" data-field="distanceToPower" placeholder="Например, 5">
                                </div>
                                <div data-phase="details">
                                    <label>Тип силового кабеля</label>
                                    <select th:field="*{connectionPoints[__${iter.index}__].powerCableTypeId}" data-field="powerCableTypeId">
                                        <option value="">Не выбран</option>
                                        <option th:each="cable : ${cableTypes}"
                                                th:if="${cable.function == powerCableFunction}"
                                            th:value="${cable.id}"
                                            th:text="${cable.name}"></option>
                                </select>
                            </div>
                        </div>
                        <div class="grid" data-phase="details">
                            <div>
                                <label>Материал прокладки</label>
                                <select th:field="*{connectionPoints[__${iter.index}__].layingMaterialId}" data-field="layingMaterialId">
                                    <option value="">Не выбран</option>
                                    <option th:each="material : ${installationMaterials}" th:value="${material.id}" th:text="${material.name}"></option>
                                </select>
                            </div>
                            <div>
                                <label>Категория поверхности</label>
                                <select th:field="*{connectionPoints[__${iter.index}__].layingSurfaceCategory}" data-field="layingSurfaceCategory">
                                    <option value="">Не выбрана</option>
                                    <option th:each="surface : ${surfaceTypes}" th:value="${surface.code}" th:text="${surface.displayName}"></option>
                                </select>
                            </div>
                            <div>
                                <label>Доп. описание поверхности</label>
                                <input type="text" th:field="*{connectionPoints[__${iter.index}__].layingSurface}" data-field="layingSurface" placeholder="По стене, в коробе...">
                            </div>
                        </div>
                        <div class="grid connection-accessories" data-phase="details">
                            <div>
                                <label class="field-label">Одноместные розетки</label>
                                <label class="switch">
                                    <input type="checkbox"
                                           th:field="*{connectionPoints[__${iter.index}__].singleSocketEnabled}"
                                           data-field="singleSocketEnabled"
                                           data-role="socket-toggle"
                                           data-socket-type="single">
                                    <span>Добавить</span>
                                </label>
                                <div class="stack small-gap"
                                     data-role="single-socket-settings"
                                     th:classappend="${!point.singleSocketEnabled} ? ' is-hidden' : ''">
                                    <label>Количество</label>
                                    <input type="number" min="1" step="1"
                                           th:field="*{connectionPoints[__${iter.index}__].singleSocketCount}"
                                           data-field="singleSocketCount">
                                </div>
                            </div>
                            <div>
                                <label class="field-label">Двухместные розетки</label>
                                <label class="switch">
                                    <input type="checkbox"
                                           th:field="*{connectionPoints[__${iter.index}__].doubleSocketEnabled}"
                                           data-field="doubleSocketEnabled"
                                           data-role="socket-toggle"
                                           data-socket-type="double">
                                    <span>Добавить</span>
                                </label>
                                <div class="stack small-gap"
                                     data-role="double-socket-settings"
                                     th:classappend="${!point.doubleSocketEnabled} ? ' is-hidden' : ''">
                                    <label>Количество</label>
                                    <input type="number" min="1" step="1"
                                           th:field="*{connectionPoints[__${iter.index}__].doubleSocketCount}"
                                           data-field="doubleSocketCount">
                                </div>
                            </div>
                        </div>
                        <div class="grid connection-breakers" data-phase="details">
                            <div>
                                <label class="field-label">Автоматические выключатели</label>
                                <label class="switch">
                                    <input type="checkbox"
                                           th:field="*{connectionPoints[__${iter.index}__].breakersEnabled}"
                                           data-field="breakersEnabled"
                                           data-role="breaker-toggle">
                                    <span>Добавить</span>
                                </label>
                                <div class="stack small-gap"
                                     data-role="breaker-settings"
                                     th:classappend="${!point.breakersEnabled} ? ' is-hidden' : ''">
                                    <label>Количество</label>
                                    <input type="number" min="2" step="1"
                                           th:field="*{connectionPoints[__${iter.index}__].breakerCount}"
                                           data-field="breakerCount">
                                    <p class="muted small">При включении требуется минимум 2 шт.</p>
                                </div>
                            </div>
                            <div>
                                <label>Боксы под автоматы</label>
                                <p class="muted" data-role="breaker-boxes"
                                   th:text="${point.breakerBoxCount} > 0 ? point.breakerBoxCount + ' шт.' : '0 шт.'"></p>
                            </div>
                            <div>
                                <label>Наконечники НШВИ</label>
                                <p class="muted" data-role="nshvi-total"
                                   th:text="${point.nshviCount} > 0 ? point.nshviCount + ' шт.' : '0 шт.'"></p>
                            </div>
                        </div>
                        <p class="connection-usage" data-role="usage" data-phase="details">Устройства будут отображены после заполнения второго шага.</p>
                    </div>
                    </div>
                    <button type="button" class="button secondary" id="add-connection-point" data-phase="names details">Добавить узел</button>
                </div>
                <template id="connection-point-template">
                    <div class="connection-point card nested-card">
                        <header class="connection-point-header" data-phase="names details">
                            <button type="button" class="link-button danger remove-connection">Удалить</button>
                        </header>
                        <div class="grid">
                            <div data-phase="names details">
                                <label>Название точки</label>
                                <input type="text" data-field="name" placeholder="Распред. коробка №1">
                                <p class="field-error" data-role="error" hidden>Название должно быть уникальным</p>
                            </div>
                            <div data-phase="details">
                                <label>Монтажный короб / ящик</label>
                                <select data-field="mountingElementId">
                                    <option value="">Не выбран</option>
                                    <option th:each="element : ${mountingElements}" th:value="${element.id}" th:text="${element.name}"></option>
                                </select>
                            </div>
                        </div>
                        <div class="grid">
                            <div data-phase="details">
                                <label>Расстояние до точки запитки (м)</label>
                                <input type="number" min="0" step="0.1" data-field="distanceToPower" placeholder="Например, 5">
                            </div>
                            <div data-phase="details">
                                <label>Тип силового кабеля</label>
                                <select data-field="powerCableTypeId">
                                    <option value="">Не выбран</option>
                                    <option th:each="cable : ${cableTypes}"
                                            th:if="${cable.function == powerCableFunction}"
                                            th:value="${cable.id}"
                                            th:text="${cable.name}"></option>
                                </select>
                            </div>
                        </div>
                        <div class="grid" data-phase="details">
                            <div>
                                <label>Материал прокладки</label>
                                <select data-field="layingMaterialId">
                                    <option value="">Не выбран</option>
                                    <option th:each="material : ${installationMaterials}" th:value="${material.id}" th:text="${material.name}"></option>
                                </select>
                            </div>
                            <div>
                                <label>Категория поверхности</label>
                                <select data-field="layingSurfaceCategory">
                                    <option value="">Не выбрана</option>
                                    <option th:each="surface : ${surfaceTypes}" th:value="${surface.code}" th:text="${surface.displayName}"></option>
                                </select>
                            </div>
                            <div>
                                <label>Доп. описание поверхности</label>
                                <input type="text" data-field="layingSurface" placeholder="По стене, в коробе...">
                            </div>
                        </div>
                        <div class="grid connection-accessories" data-phase="details">
                            <div>
                                <label class="field-label">Одноместные розетки</label>
                                <label class="switch">
                                    <input type="checkbox"
                                           data-field="singleSocketEnabled"
                                           data-role="socket-toggle"
                                           data-socket-type="single">
                                    <span>Добавить</span>
                                </label>
                                <div class="stack small-gap is-hidden" data-role="single-socket-settings">
                                    <label>Количество</label>
                                    <input type="number" min="1" step="1" data-field="singleSocketCount">
                                </div>
                            </div>
                            <div>
                                <label class="field-label">Двухместные розетки</label>
                                <label class="switch">
                                    <input type="checkbox" data-field="doubleSocketEnabled" data-role="socket-toggle" data-socket-type="double" checked>
                                    <span>Добавить</span>
                                </label>
                                <div class="stack small-gap" data-role="double-socket-settings">
                                    <label>Количество</label>
                                    <input type="number" min="1" step="1" data-field="doubleSocketCount" value="1">
                                </div>
                            </div>
                        </div>
                        <div class="grid connection-breakers">
                            <div>
                                <label class="field-label">Автоматические выключатели</label>
                                <label class="switch">
                                    <input type="checkbox" data-field="breakersEnabled" data-role="breaker-toggle" checked>
                                    <span>Добавить</span>
                                </label>
                                <div class="stack small-gap" data-role="breaker-settings">
                                    <label>Количество</label>
                                    <input type="number" min="2" step="1" data-field="breakerCount" value="2">
                                    <p class="muted small">При включении требуется минимум 2 шт.</p>
                                </div>
                            </div>
                            <div>
                                <label>Боксы под автоматы</label>
                                <p class="muted" data-role="breaker-boxes">1 шт.</p>
                            </div>
                            <div>
                                <label>Наконечники НШВИ</label>
                                <p class="muted" data-role="nshvi-total">8 шт.</p>
                            </div>
                        </div>
                        <p class="connection-usage" data-role="usage">Устройства будут отображены после заполнения второго шага.</p>
                    </div>
                </template>

                <div id="workspace-step" class="stack">
                    <div class="workspace card nested-card" th:each="workspace, wIter : *{workspaces}" th:data-index="${wIter.index}">
                        <header class="workspace-header" data-phase="names details">
                            <h4>Рабочее место №<span th:text="${wIter.index + 1}">1</span></h4>
                            <button type="button" class="link-button danger remove-workspace" th:if="${wIter.index > 0}">Удалить</button>
                        </header>
                        <div class="grid">
                            <div data-phase="names details">
                                <label>Название рабочего места</label>
                                <input type="text" th:field="*{workspaces[__${wIter.index}__].name}" data-field="name" placeholder="Пост охраны, диспетчер...">
                            </div>
                            <div data-phase="details">
                                <label>Расположение / назначение</label>
                                <input type="text" th:field="*{workspaces[__${wIter.index}__].location}" data-field="location" placeholder="Серверная, вахта...">
                            </div>
                        </div>
                        <div class="grid" data-phase="details">
                            <div>
                                <label>Привязка к узлу</label>
                                <input type="text" th:field="*{workspaces[__${wIter.index}__].assignedNode}" data-field="assignedNode" placeholder="Узел №1">
                            </div>
                            <div>
                                <label>Оборудование / наполнение</label>
                                <textarea th:field="*{workspaces[__${wIter.index}__].equipment}" data-field="equipment" rows="3" placeholder="Мониторы, клавиатура, ПО..."></textarea>
                            </div>
                        </div>
                    </div>
                    <button type="button" class="button secondary" id="add-workspace" data-phase="names details">Добавить рабочее место</button>
                </div>
                <template id="workspace-card-template">
                    <div class="workspace card nested-card">
                        <header class="workspace-header" data-phase="names details">
                            <h4>Рабочее место №<span data-role="workspace-number">1</span></h4>
                            <button type="button" class="link-button danger remove-workspace">Удалить</button>
                        </header>
                        <div class="grid">
                            <div data-phase="names details">
                                <label>Название рабочего места</label>
                                <input type="text" data-field="name" placeholder="Пост охраны, диспетчер...">
                            </div>
                            <div data-phase="details">
                                <label>Расположение / назначение</label>
                                <input type="text" data-field="location" placeholder="Серверная, вахта...">
                            </div>
                        </div>
                        <div class="grid" data-phase="details">
                            <div>
                                <label>Привязка к узлу</label>
                                <input type="text" data-field="assignedNode" placeholder="Узел №1">
                            </div>
                            <div>
                                <label>Оборудование / наполнение</label>
                                <textarea data-field="equipment" rows="3" placeholder="Мониторы, клавиатура, ПО..."></textarea>
                            </div>
                        </div>
                    </div>
                </template>

                <div class="card nested-card">
                    <div class="stack" id="mounting-list">
                        <div class="mounting-row" th:each="element, iter : *{mountingElements}" th:data-index="${iter.index}" th:classappend="${element.autoAssigned} ? ' is-locked' : ''">
                            <input type="hidden" th:field="*{mountingElements[__${iter.index}__].elementName}" data-field="elementName">
                            <div class="grid mounting-row-header">
                                <div>
                                    <label>Монтажный короб / ящик</label>
                                    <div class="mounting-element-display" th:if="${element.autoAssigned}">
                                        <input type="hidden" th:field="*{mountingElements[__${iter.index}__].elementId}" data-field="elementId">
                                        <p class="muted" data-role="element-name" th:text="${#strings.isEmpty(element.elementName) ? 'Не выбран' : element.elementName}">Не выбран</p>
                                        <p class="muted small">Назначен на шаге точек подключения.</p>
                                    </div>
                                    <select th:unless="${element.autoAssigned}" th:field="*{mountingElements[__${iter.index}__].elementId}" data-field="elementId">
                                        <option value="">Не выбран</option>
                                        <option th:each="option : ${availableMountingElements}" th:value="${option.id}" th:text="${option.name}"></option>
                                    </select>
                                </div>
                                <div>
                                    <label>Количество / примечание</label>
                                    <input type="text" th:field="*{mountingElements[__${iter.index}__].quantity}" data-field="quantity" placeholder="2 шт, 1 комплект...">
                                </div>
                            </div>
                            <div class="stack mounting-materials" data-role="materials">
                                <div class="mounting-material-row" th:each="material, mIndex : *{mountingElements[__${iter.index}__].materials}" th:data-index="${mIndex.index}">
                                    <div class="grid">
                                        <div>
                                            <label>Материал</label>
                                            <select th:field="*{mountingElements[__${iter.index}__].materials[__${mIndex.index}__].materialId}" data-field="materialId">
                                                <option value="">Не выбран</option>
                                                <option th:each="materialOption : ${installationMaterials}" th:value="${materialOption.id}" th:text="${materialOption.name + (#strings.isEmpty(materialOption.unit) ? '' : ' (' + materialOption.unit + ')')}"></option>
                                            </select>
                                        </div>
                                        <div>
                                            <label>Количество / примечание</label>
                                            <input type="text" th:field="*{mountingElements[__${iter.index}__].materials[__${mIndex.index}__].amount}" data-field="amount" placeholder="1 комплект, 20 м...">
                                        </div>
                                    </div>
                                    <button type="button" class="link-button danger remove-mounting-material" th:if="${mIndex.index > 0}">Удалить материал</button>
                                </div>
                            </div>
                            <button type="button" class="button tertiary" data-action="add-mounting-material">Добавить материал</button>
                            <button type="button" class="link-button danger remove-mounting" th:if="${!element.autoAssigned && iter.index > 0}">Удалить</button>
                        </div>
                    </div>
                    <button type="button" class="button secondary" id="add-mounting-element">Добавить монтажный элемент</button>
                </div>
                <template id="mounting-row-template">
                    <div class="mounting-row">
                        <input type="hidden" data-field="elementName">
                        <div class="grid mounting-row-header">
                            <div>
                                <label>Монтажный короб / ящик</label>
                                <select data-field="elementId">
                                    <option value="">Не выбран</option>
                                    <option th:each="option : ${availableMountingElements}" th:value="${option.id}" th:text="${option.name}"></option>
                                </select>
                            </div>
                            <div>
                                <label>Количество / примечание</label>
                                <input type="text" data-field="quantity" placeholder="2 шт, 1 комплект...">
                            </div>
                        </div>
                        <div class="stack mounting-materials" data-role="materials">
                            <div class="mounting-material-row">
                                <div class="grid">
                                    <div>
                                        <label>Материал</label>
                                        <select data-field="materialId">
                                            <option value="">Не выбран</option>
                                            <option th:each="materialOption : ${installationMaterials}" th:value="${materialOption.id}" th:text="${materialOption.name + (#strings.isEmpty(materialOption.unit) ? '' : ' (' + materialOption.unit + ')')}"></option>
                                        </select>
                                    </div>
                                    <div>
                                        <label>Количество / примечание</label>
                                        <input type="text" data-field="amount" placeholder="1 комплект, 20 м...">
                                    </div>
                                </div>
                                <button type="button" class="link-button danger remove-mounting-material">Удалить материал</button>
                            </div>
                        </div>
                        <button type="button" class="button tertiary" data-action="add-mounting-material">Добавить материал</button>
                        <button type="button" class="link-button danger remove-mounting">Удалить</button>
                    </div>
                </template>
                <template id="mounting-material-template">
                    <div class="mounting-material-row">
                        <div class="grid">
                            <div>
                                <label>Материал</label>
                                <select data-field="materialId">
                                    <option value="">Не выбран</option>
                                    <option th:each="materialOption : ${installationMaterials}" th:value="${materialOption.id}" th:text="${materialOption.name + (#strings.isEmpty(materialOption.unit) ? '' : ' (' + materialOption.unit + ')')}"></option>
                                </select>
                            </div>
                            <div>
                                <label>Количество / примечание</label>
                                <input type="text" data-field="amount" placeholder="1 комплект, 20 м...">
                            </div>
                        </div>
                        <button type="button" class="link-button danger remove-mounting-material">Удалить материал</button>
                    </div>
                </template>
            </section>

            <section class="wizard-step" data-step-index="8" hidden>
                <h3>Шаг 9. Наполнение рабочих мест</h3>
                <p class="muted">Заполните подробности по каждому рабочему месту: где оно расположено, какие узлы к нему подключены и чем оно комплектуется.</p>
                <div class="card nested-card">
                    <label>Основное рабочее место</label>
                    <input type="text" th:field="*{mainWorkspaceLocation}" placeholder="Центральный пост охраны, серверная...">
                    <p class="muted small">Поле используется для сводки и не заменяет названия отдельных рабочих мест.</p>
                </div>
                <div data-role="workspace-step-placeholder" data-phase="details"></div>
            </section>
        </div>
        <div class="form-row wizard-controls">
            <button type="button" class="button secondary" data-action="prev-step">Назад</button>
            <button type="button" class="button primary" data-action="next-step">Далее</button>
            <button type="submit" class="button" data-role="finish" hidden>Сохранить первичные данные</button>
            <a class="button secondary" th:href="@{'/objects/' + ${object.id}}">Отмена</a>
        </div>
    </form>
</main>
<footer class="footer">
    <p>Object Manager &copy; 2025</p>
</footer>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        const deviceContainer = document.getElementById('device-groups');
        const deviceTemplate = document.getElementById('device-group-template');
        const addDeviceButton = document.getElementById('add-device-group');
        const deviceStepElement = document.getElementById('device-step');
        const devicePhasePlaceholders = new Map();
        const connectionTotal = document.getElementById('connection-total');
        const connectionContainer = document.getElementById('connection-points');
        const connectionTemplate = document.getElementById('connection-point-template');
        const connectionEmptyMessage = document.getElementById('connection-empty');
        const connectionStepElement = document.getElementById('connection-step');
        const connectionPhasePlaceholders = new Map();
        const addConnectionButton = document.getElementById('add-connection-point');
        const groupingPool = document.getElementById('grouping-pool');
        const groupColumnsContainer = document.getElementById('grouping-columns');
        const groupColumnTemplate = document.getElementById('group-column-template');
        const groupingEmptyMessage = document.getElementById('grouping-empty');
        const addGroupButton = document.getElementById('add-group');
        const deviceChipTemplate = document.getElementById('device-chip-template');
        const groupingWarning = document.getElementById('grouping-warning');
        const materialGroupsContainer = document.getElementById('material-groups');
        const materialGroupTemplate = document.getElementById('material-group-template');
        const materialRowTemplate = document.getElementById('material-row-template');
        const materialsEmptyMessage = document.getElementById('materials-empty');
        const mountingList = document.getElementById('mounting-list');
        const mountingRowTemplate = document.getElementById('mounting-row-template');
        const mountingMaterialTemplate = document.getElementById('mounting-material-template');
        const addMountingButton = document.getElementById('add-mounting-element');
        const workspaceStepElement = document.getElementById('workspace-step');
        const workspaceTemplate = document.getElementById('workspace-card-template');
        const addWorkspaceButton = document.getElementById('add-workspace');
        const workspacePhasePlaceholders = new Map();
        const stepSections = Array.from(document.querySelectorAll('.wizard-step'));
        const stepButtons = Array.from(document.querySelectorAll('.wizard-progress-step'));
        const prevButton = document.querySelector('[data-action="prev-step"]');
        const nextButton = document.querySelector('[data-action="next-step"]');
        const finishButton = document.querySelector('[data-role="finish"]');
        const nodeDiagramBoard = document.getElementById('node-diagram-board');
        const nodeDiagramLayer = document.getElementById('node-diagram-layer');
        const nodeDiagramLinks = document.getElementById('node-diagram-links');
        const nodeDiagramEmpty = document.getElementById('node-diagram-empty');
        const nodeDiagramInput = document.getElementById('node-diagram-data');
        const nodeDiagramResetButton = document.getElementById('node-diagram-reset');
        const unlinkZone = document.getElementById('node-unlink-area');
        const wizardForm = document.querySelector('.wizard-form');
        const totalDeviceCountInput = wizardForm?.querySelector('input[name="totalDeviceCount"]');
        const deviceGroupsLockedToTotal = true;
        document.querySelectorAll('[data-role="device-step-placeholder"]').forEach(placeholder => {
            const phaseKey = placeholder.dataset.phase;
            if (phaseKey) {
                devicePhasePlaceholders.set(phaseKey, placeholder);
            }
        });
        document.querySelectorAll('[data-role="connection-step-placeholder"]').forEach(placeholder => {
            const phaseKey = placeholder.dataset.phase;
            if (phaseKey) {
                connectionPhasePlaceholders.set(phaseKey, placeholder);
            }
        });
        document.querySelectorAll('[data-role="workspace-step-placeholder"]').forEach(placeholder => {
            const phaseKey = placeholder.dataset.phase;
            if (phaseKey) {
                workspacePhasePlaceholders.set(phaseKey, placeholder);
            }
        });
        const stepPhaseMap = new Map([
            [1, 'naming'],
            [4, 'details']
        ]);
        const connectionStepPhaseMap = new Map([
            [2, 'names'],
            [7, 'details']
        ]);
        const workspaceStepPhaseMap = new Map([
            [3, 'names'],
            [8, 'details']
        ]);
        const initialStepRaw = Number(wizardForm?.dataset.initialStep ?? '0');
        const initialStep = Number.isFinite(initialStepRaw)
            ? Math.max(0, Math.min(initialStepRaw, stepSections.length - 1))
            : 0;

        let currentStep = 0;
        let nodeDiagramModel = { nodes: [], edges: [] };
        let storedDiagramData = parseDiagramValue(nodeDiagramInput?.value ?? '');
        let nodeDiagramRefreshHandle = null;

        function isDeviceDetailsPhaseActive() {
            return (deviceStepElement?.dataset.activePhase || '') === 'details';
        }

        function applyDevicePhaseVisibility(phase) {
            if (!deviceStepElement) {
                return;
            }
            deviceStepElement.dataset.activePhase = phase || '';
            deviceStepElement.querySelectorAll('[data-phase]').forEach(element => {
                const phases = (element.dataset.phase || '').split(/\s+/).filter(Boolean);
                const shouldShow = !phase || phases.length === 0 || phases.includes(phase);
                if (shouldShow) {
                    element.removeAttribute('hidden');
                    element.classList.remove('is-phase-hidden');
                } else {
                    element.setAttribute('hidden', 'hidden');
                    element.classList.add('is-phase-hidden');
                }
            });
            getDeviceGroups().forEach(group => {
                updateCameraFieldsForGroup(group);
                updateCableFieldsForGroup(group);
            });
        }

        function moveDeviceStepToPhase(phase) {
            if (!deviceStepElement) {
                return;
            }
            const placeholder = phase ? devicePhasePlaceholders.get(phase) : null;
            if (placeholder && placeholder !== deviceStepElement.parentElement) {
                placeholder.appendChild(deviceStepElement);
            }
            if (phase) {
                deviceStepElement.removeAttribute('hidden');
                applyDevicePhaseVisibility(phase);
            } else {
                deviceStepElement.setAttribute('hidden', 'hidden');
            }
        }

        function applyConnectionPhaseVisibility(phase) {
            if (!connectionStepElement) {
                return;
            }
            connectionStepElement.dataset.activePhase = phase || '';
            connectionStepElement.querySelectorAll('[data-phase]').forEach(element => {
                const phases = (element.dataset.phase || '').split(/\s+/).filter(Boolean);
                const shouldShow = !phase || phases.length === 0 || phases.includes(phase);
                element.classList.toggle('is-phase-hidden', !shouldShow);
                if (shouldShow) {
                    element.removeAttribute('hidden');
                } else {
                    element.setAttribute('hidden', 'hidden');
                }
            });
        }

        function moveConnectionStepToPhase(phase) {
            if (!connectionStepElement) {
                return;
            }
            const placeholder = phase ? connectionPhasePlaceholders.get(phase) : null;
            if (placeholder && placeholder !== connectionStepElement.parentElement) {
                placeholder.appendChild(connectionStepElement);
            }
            if (phase) {
                connectionStepElement.removeAttribute('hidden');
                applyConnectionPhaseVisibility(phase);
            } else {
                connectionStepElement.setAttribute('hidden', 'hidden');
            }
        }

        function applyWorkspacePhaseVisibility(phase) {
            if (!workspaceStepElement) {
                return;
            }
            workspaceStepElement.dataset.activePhase = phase || '';
            workspaceStepElement.querySelectorAll('[data-phase]').forEach(element => {
                const phases = (element.dataset.phase || '').split(/\s+/).filter(Boolean);
                const shouldShow = !phase || phases.length === 0 || phases.includes(phase);
                element.classList.toggle('is-phase-hidden', !shouldShow);
                if (shouldShow) {
                    element.removeAttribute('hidden');
                } else {
                    element.setAttribute('hidden', 'hidden');
                }
            });
        }

        function moveWorkspaceStepToPhase(phase) {
            if (!workspaceStepElement) {
                return;
            }
            const placeholder = phase ? workspacePhasePlaceholders.get(phase) : null;
            if (placeholder && placeholder !== workspaceStepElement.parentElement) {
                placeholder.appendChild(workspaceStepElement);
            }
            if (phase) {
                workspaceStepElement.removeAttribute('hidden');
                applyWorkspacePhaseVisibility(phase);
            } else {
                workspaceStepElement.setAttribute('hidden', 'hidden');
            }
        }

        function showStep(index) {
            if (index < 0 || index >= stepSections.length) {
                return;
            }
            currentStep = index;
            stepSections.forEach((section, idx) => {
                if (idx === index) {
                    section.removeAttribute('hidden');
                    section.classList.add('active');
                } else {
                    section.setAttribute('hidden', 'hidden');
                    section.classList.remove('active');
                }
            });
            stepButtons.forEach(button => {
                const stepIndex = Number(button.dataset.stepIndex);
                const isActive = stepIndex === index;
                button.classList.toggle('active', isActive);
                button.disabled = isActive;
            });
            if (prevButton) {
                prevButton.disabled = index === 0;
            }
            if (nextButton) {
                nextButton.hidden = index === stepSections.length - 1;
            }
            if (finishButton) {
                finishButton.hidden = index !== stepSections.length - 1;
            }
            const devicePhase = stepPhaseMap.get(index) || null;
            moveDeviceStepToPhase(devicePhase);
            const connectionPhase = connectionStepPhaseMap.get(index) || null;
            moveConnectionStepToPhase(connectionPhase);
            const workspacePhase = workspaceStepPhaseMap.get(index) || null;
            moveWorkspaceStepToPhase(workspacePhase);
        }

        stepButtons.forEach(button => {
            button.addEventListener('click', () => {
                const stepIndex = Number(button.dataset.stepIndex);
                if (!Number.isNaN(stepIndex)) {
                    showStep(stepIndex);
                }
            });
        });
        prevButton?.addEventListener('click', () => {
            if (currentStep > 0) {
                showStep(currentStep - 1);
            }
        });
        nextButton?.addEventListener('click', () => {
            if (currentStep < stepSections.length - 1) {
                showStep(currentStep + 1);
            }
        });

        function updateTotalConnectionPoints() {
            if (!connectionTotal || !deviceContainer) {
                return;
            }
            const names = new Set();
            const connectionInputs = deviceContainer.querySelectorAll('input[data-field="connectionPoint"]');
            connectionInputs.forEach(input => {
                const value = input.value.trim();
                if (value) {
                    names.add(value);
                }
            });
            connectionTotal.textContent = names.size.toString();
        }

        function getDeviceGroups() {
            return Array.from(deviceContainer?.querySelectorAll('.device-group') ?? []);
        }

        function getWorkspaceCards() {
            return Array.from(workspaceStepElement?.querySelectorAll('.workspace') ?? []);
        }

        function isCameraDevice(select) {
            if (!(select instanceof HTMLSelectElement)) {
                return false;
            }
            const option = select.options[select.selectedIndex];
            if (!option) {
                return false;
            }
            if (option.dataset && typeof option.dataset.camera !== 'undefined') {
                return option.dataset.camera === 'true';
            }
            const label = option.text?.toLowerCase() ?? '';
            return label.includes('камера');
        }

        function normalizeConnectionName(value) {
            return (value || '').trim().toLowerCase();
        }

        function resolveConnectionNameFromNodeId(nodeId) {
            if (typeof nodeId !== 'string' || !nodeId.startsWith('connection-')) {
                return null;
            }
            const suffix = nodeId.substring('connection-'.length);
            if (suffix.startsWith('__index_')) {
                const rawIndex = Number.parseInt(suffix.substring('__index_'.length), 10);
                if (Number.isFinite(rawIndex)) {
                    const rows = Array.from(connectionContainer?.querySelectorAll('.connection-point') ?? []);
                    const row = rows[rawIndex];
                    const input = row?.querySelector('input[data-field="name"]');
                    return input?.value?.trim() ?? '';
                }
            }
            const rows = Array.from(connectionContainer?.querySelectorAll('.connection-point') ?? []);
            for (const row of rows) {
                const input = row.querySelector('input[data-field="name"]');
                const rawName = input?.value?.trim() ?? '';
                if (!rawName) {
                    continue;
                }
                const key = normalizeConnectionName(rawName) || rawName;
                if (key === suffix) {
                    return rawName;
                }
            }
            return null;
        }

        function detectDropTarget(pointerEvent, excludeId) {
            if (!(pointerEvent instanceof PointerEvent)) {
                return null;
            }
            const x = pointerEvent.clientX;
            const y = pointerEvent.clientY;
            if (!Number.isFinite(x) || !Number.isFinite(y)) {
                return null;
            }
            const connectionElements = Array.from(nodeDiagramLayer?.querySelectorAll('.diagram-node[data-node-type="connection"]') ?? []);
            for (const element of connectionElements) {
                const targetId = element.dataset.nodeId;
                if (excludeId && targetId === excludeId) {
                    continue;
                }
                const rect = element.getBoundingClientRect();
                if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                    return { type: 'connection', id: targetId };
                }
            }
            if (unlinkZone) {
                const rect = unlinkZone.getBoundingClientRect();
                if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                    return { type: 'unlink' };
                }
            }
            return null;
        }

        function updateDropzoneHighlight(pointerEvent, excludeId) {
            if (!unlinkZone) {
                return;
            }
            const target = detectDropTarget(pointerEvent, excludeId);
            unlinkZone.classList.toggle('is-active', target?.type === 'unlink');
        }

        function clearDropzoneHighlight() {
            if (!unlinkZone) {
                return;
            }
            unlinkZone.classList.remove('is-active');
        }

        function assignDeviceToConnection(nodeId, connectionNodeId) {
            if (typeof nodeId !== 'string' || !nodeId.startsWith('device-')) {
                return;
            }
            const index = Number.parseInt(nodeId.substring('device-'.length), 10);
            if (!Number.isFinite(index)) {
                return;
            }
            const groups = getDeviceGroups();
            const group = groups[index];
            if (!group) {
                return;
            }
            const input = group.querySelector('input[data-field="connectionPoint"]');
            if (!input) {
                return;
            }
            const connectionName = connectionNodeId ? resolveConnectionNameFromNodeId(connectionNodeId) || '' : '';
            if (input.value.trim() === connectionName.trim()) {
                return;
            }
            input.value = connectionName;
            input.dispatchEvent(new Event('input', { bubbles: true }));
            input.dispatchEvent(new Event('change', { bubbles: true }));
        }

        function assignWorkspaceToConnection(nodeId, connectionNodeId) {
            if (typeof nodeId !== 'string' || !nodeId.startsWith('workspace-')) {
                return;
            }
            const index = Number.parseInt(nodeId.substring('workspace-'.length), 10);
            if (!Number.isFinite(index)) {
                return;
            }
            const cards = getWorkspaceCards();
            const card = cards[index];
            if (!card) {
                return;
            }
            const input = card.querySelector('input[data-field="assignedNode"]');
            if (!input) {
                return;
            }
            const connectionName = connectionNodeId ? resolveConnectionNameFromNodeId(connectionNodeId) || '' : '';
            if (input.value.trim() === connectionName.trim()) {
                return;
            }
            input.value = connectionName;
            input.dispatchEvent(new Event('input', { bubbles: true }));
            input.dispatchEvent(new Event('change', { bubbles: true }));
        }

        function removeConnectionEdges(connectionNodeId, model) {
            if (!model || !Array.isArray(model.edges)) {
                return;
            }
            model.edges = model.edges.filter(edge => edge.from !== connectionNodeId && edge.to !== connectionNodeId);
        }

        function toggleConnectionEdge(sourceId, targetId, model) {
            if (!model) {
                return;
            }
            if (!Array.isArray(model.edges)) {
                model.edges = [];
            }
            const existingIndex = model.edges.findIndex(edge =>
                (edge.from === sourceId && edge.to === targetId)
                || (edge.from === targetId && edge.to === sourceId)
            );
            if (existingIndex >= 0) {
                model.edges.splice(existingIndex, 1);
            } else {
                model.edges.push({ from: sourceId, to: targetId });
            }
        }

        function updateEdgeForNode(model, node, connectionId) {
            if (!model || !node) {
                return;
            }
            if (!Array.isArray(model.edges)) {
                model.edges = [];
            }
            model.edges = model.edges.filter(edge => edge.from !== node.id);
            if (connectionId) {
                model.edges.push({ from: node.id, to: connectionId });
            }
        }

        function parseDiagramValue(raw) {
            if (!raw || typeof raw !== 'string') {
                return { nodes: [], edges: [] };
            }
            try {
                const parsed = JSON.parse(raw);
                if (parsed && Array.isArray(parsed.nodes) && Array.isArray(parsed.edges)) {
                    return {
                        nodes: parsed.nodes.filter(node => node && typeof node.id === 'string'),
                        edges: parsed.edges.filter(edge => edge && typeof edge.from === 'string' && typeof edge.to === 'string')
                    };
                }
            } catch (error) {
                console.warn('Не удалось разобрать сохранённую схему узлов', error);
            }
            return { nodes: [], edges: [] };
        }

        function clamp(value, min, max) {
            if (!Number.isFinite(value)) {
                return min;
            }
            if (value < min) {
                return min;
            }
            if (value > max) {
                return max;
            }
            return value;
        }

        function scheduleNodeDiagramRefresh() {
            if (!nodeDiagramBoard) {
                return;
            }
            if (nodeDiagramRefreshHandle !== null) {
                cancelAnimationFrame(nodeDiagramRefreshHandle);
            }
            nodeDiagramRefreshHandle = requestAnimationFrame(() => {
                nodeDiagramRefreshHandle = null;
                refreshNodeDiagram();
            });
        }

        function refreshNodeDiagram() {
            if (!nodeDiagramBoard || !nodeDiagramLayer) {
                return;
            }
            const storedPositions = new Map();
            if (storedDiagramData && Array.isArray(storedDiagramData.nodes)) {
                storedDiagramData.nodes.forEach(node => {
                    if (node && typeof node.id === 'string') {
                        storedPositions.set(node.id, node);
                    }
                });
            }
            nodeDiagramModel = buildNodeDiagramModel(storedPositions);
            renderNodeDiagram(nodeDiagramModel);
            persistNodeDiagram(nodeDiagramModel);
        }

        function buildNodeDiagramModel(storedPositions) {
            const nodes = [];
            const edges = [];
            const connectionNodes = [];
            const deviceNodes = [];
            const workspaceNodes = [];
            const connectionIdMap = new Map();

            const connectionRows = Array.from(connectionContainer?.querySelectorAll('.connection-point') ?? []);
            connectionRows.forEach((row, index) => {
                const nameInput = row.querySelector('input[data-field="name"]');
                const rawName = nameInput?.value?.trim() ?? '';
                const normalized = normalizeConnectionName(rawName);
                const key = normalized || `__index_${index}`;
                const id = `connection-${key}`;
                const stored = storedPositions.get(id);
                const node = {
                    id,
                    title: rawName || `Узел ${index + 1}`,
                    subtitle: '',
                    meta: '',
                    type: 'connection',
                    x: stored ? clamp(Number(stored.x), 0, 1) : undefined,
                    y: stored ? clamp(Number(stored.y), 0, 1) : undefined
                };
                nodes.push(node);
                connectionNodes.push(node);
                if (normalized) {
                    connectionIdMap.set(normalized, id);
                }
                if (rawName) {
                    connectionIdMap.set(rawName, id);
                }
            });

            const groups = getDeviceGroups();
            groups.forEach((group, index) => {
                const typeSelect = group.querySelector('select[data-field="deviceTypeId"]');
                const typeLabel = typeSelect?.selectedOptions?.[0]?.text?.trim() ?? `Устройство №${index + 1}`;
                const countInput = group.querySelector('input[data-field="deviceCount"]');
                const count = countInput?.value?.trim() || '1';
                const locationInput = group.querySelector('input[data-field="installLocation"]');
                const location = locationInput?.value?.trim() ?? '';
                const nodeId = `device-${index}`;
                const stored = storedPositions.get(nodeId);
                const connectionInput = group.querySelector('input[data-field="connectionPoint"]');
                const connectionName = connectionInput?.value?.trim();
                const connectionKey = connectionName ? (normalizeConnectionName(connectionName) || connectionName) : null;
                const connectionId = connectionKey ? connectionIdMap.get(connectionKey) ?? null : null;

                const node = {
                    id: nodeId,
                    title: typeLabel,
                    subtitle: location,
                    meta: '',
                    type: isCameraDevice(typeSelect) ? 'camera' : 'device',
                    connectionId,
                    x: stored ? clamp(Number(stored.x), 0, 1) : undefined,
                    y: stored ? clamp(Number(stored.y), 0, 1) : undefined
                };
                nodes.push(node);
                deviceNodes.push(node);

                if (connectionId) {
                    edges.push({ from: nodeId, to: connectionId });
                }
            });

            const workspaces = getWorkspaceCards();
            workspaces.forEach((card, index) => {
                const nameInput = card.querySelector('input[data-field="name"]');
                const name = nameInput?.value?.trim() ?? '';
                const nodeId = `workspace-${index}`;
                const stored = storedPositions.get(nodeId);
                const locationInput = card.querySelector('input[data-field="location"]');
                const location = locationInput?.value?.trim() ?? '';
                const assignedInput = card.querySelector('input[data-field="assignedNode"]');
                const assignedName = assignedInput?.value?.trim();
                const assignedKey = assignedName ? (normalizeConnectionName(assignedName) || assignedName) : null;
                const connectionId = assignedKey ? connectionIdMap.get(assignedKey) ?? null : null;
                const node = {
                    id: nodeId,
                    title: name || `Рабочее место ${index + 1}`,
                    subtitle: location,
                    meta: '',
                    type: 'workspace',
                    connectionId,
                    x: stored ? clamp(Number(stored.x), 0, 1) : undefined,
                    y: stored ? clamp(Number(stored.y), 0, 1) : undefined
                };
                nodes.push(node);
                workspaceNodes.push(node);
                if (connectionId) {
                    edges.push({ from: nodeId, to: connectionId });
                }
            });

            autoLayoutNodePositions(connectionNodes, deviceNodes, workspaceNodes);
            return { nodes, edges };
        }

        function autoLayoutNodePositions(connectionNodes, deviceNodes, workspaceNodes) {
            const padding = 0.08;
            const topY = 0.18;
            const connectionCount = connectionNodes.length;
            connectionNodes.forEach((node, index) => {
                if (!Number.isFinite(node.x) || !Number.isFinite(node.y)) {
                    const fraction = connectionCount > 1 ? index / (connectionCount - 1) : 0.5;
                    node.x = clamp(fraction, padding, 1 - padding);
                    node.y = topY;
                } else {
                    node.x = clamp(node.x, padding, 1 - padding);
                    node.y = clamp(node.y, padding, 0.5);
                }
            });

            const deviceCount = deviceNodes.length;
            if (deviceCount > 0) {
                const deviceColumns = Math.max(1, Math.ceil(Math.sqrt(deviceCount)));
                deviceNodes.forEach((node, index) => {
                    if (Number.isFinite(node.x) && Number.isFinite(node.y)) {
                        node.x = clamp(node.x, padding, 1 - padding);
                        node.y = clamp(node.y, 0.35, 0.75);
                        return;
                    }
                    const row = Math.floor(index / deviceColumns);
                    const col = index % deviceColumns;
                    const columnFraction = deviceColumns > 1 ? col / (deviceColumns - 1) : 0.5;
                    const rowSpacing = 0.2;
                    const y = 0.42 + row * rowSpacing;
                    node.x = clamp(columnFraction, padding, 1 - padding);
                    node.y = clamp(y, 0.35, 0.78);
                });
            }

            const workspaceCount = workspaceNodes?.length ?? 0;
            if (workspaceCount > 0) {
                const workspaceColumns = Math.max(1, Math.ceil(Math.sqrt(workspaceCount)));
                workspaceNodes.forEach((node, index) => {
                    if (Number.isFinite(node.x) && Number.isFinite(node.y)) {
                        node.x = clamp(node.x, padding, 1 - padding);
                        node.y = clamp(node.y, 0.65, 0.95);
                        return;
                    }
                    const row = Math.floor(index / workspaceColumns);
                    const col = index % workspaceColumns;
                    const fraction = workspaceColumns > 1 ? col / (workspaceColumns - 1) : 0.5;
                    const rowSpacing = 0.2;
                    const y = 0.7 + row * rowSpacing;
                    node.x = clamp(fraction, padding, 1 - padding);
                    node.y = clamp(y, 0.62, 0.96);
                });
            }
        }

        function renderNodeDiagram(model) {
            if (!nodeDiagramLayer || !nodeDiagramBoard) {
                return;
            }
            nodeDiagramLayer.innerHTML = '';
            if (nodeDiagramLinks) {
                while (nodeDiagramLinks.firstChild) {
                    nodeDiagramLinks.removeChild(nodeDiagramLinks.firstChild);
                }
            }
            const nodes = Array.isArray(model.nodes) ? model.nodes : [];
            const isEmpty = nodes.length === 0;
            if (nodeDiagramEmpty) {
                nodeDiagramEmpty.hidden = !isEmpty;
            }
            nodeDiagramBoard.classList.toggle('is-empty', isEmpty);
            const fragment = document.createDocumentFragment();
            nodes.forEach(node => {
                const element = document.createElement('div');
                element.classList.add('diagram-node');
                element.dataset.nodeId = node.id;
                element.dataset.nodeType = node.type ?? 'device';

                const title = document.createElement('p');
                title.classList.add('diagram-node-title');
                title.textContent = node.title ?? '';
                element.appendChild(title);

                if (node.meta) {
                    const meta = document.createElement('span');
                    meta.classList.add('diagram-node-meta');
                    meta.textContent = node.meta;
                    element.appendChild(meta);
                }

                if (node.subtitle) {
                    const subtitle = document.createElement('p');
                    subtitle.classList.add('diagram-node-subtitle');
                    subtitle.textContent = node.subtitle;
                    element.appendChild(subtitle);
                }

                fragment.appendChild(element);
                updateNodeElementPosition(element, node);
                enableNodeDragging(element, node, model);
            });
            nodeDiagramLayer.appendChild(fragment);
            updateNodeDiagramEdges(model);
        }

        function updateNodeElementPosition(element, node) {
            if (!element || !node) {
                return;
            }
            const left = clamp(Number(node.x), 0, 1) * 100;
            const top = clamp(Number(node.y), 0, 1) * 100;
            element.style.left = `${left}%`;
            element.style.top = `${top}%`;
        }

        function updateNodeDiagramEdges(model) {
            if (!nodeDiagramBoard || !nodeDiagramLinks) {
                return;
            }
            const rect = nodeDiagramBoard.getBoundingClientRect();
            const width = rect.width || 1;
            const height = rect.height || 1;
            nodeDiagramLinks.setAttribute('viewBox', `0 0 ${width} ${height}`);
            nodeDiagramLinks.setAttribute('width', String(width));
            nodeDiagramLinks.setAttribute('height', String(height));
            while (nodeDiagramLinks.firstChild) {
                nodeDiagramLinks.removeChild(nodeDiagramLinks.firstChild);
            }
            const nodeMap = new Map();
            (model.nodes ?? []).forEach(node => {
                nodeMap.set(node.id, node);
            });
            (model.edges ?? []).forEach(edge => {
                const from = nodeMap.get(edge.from);
                const to = nodeMap.get(edge.to);
                if (!from || !to) {
                    return;
                }
                if (!Number.isFinite(from.x) || !Number.isFinite(from.y) || !Number.isFinite(to.x) || !Number.isFinite(to.y)) {
                    return;
                }
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.classList.add('diagram-link');
                line.setAttribute('x1', String(clamp(from.x, 0, 1) * width));
                line.setAttribute('y1', String(clamp(from.y, 0, 1) * height));
                line.setAttribute('x2', String(clamp(to.x, 0, 1) * width));
                line.setAttribute('y2', String(clamp(to.y, 0, 1) * height));
                nodeDiagramLinks.appendChild(line);
            });
        }

        function enableNodeDragging(element, node, model) {
            if (!element || !node) {
                return;
            }
            element.addEventListener('pointerdown', event => {
                if (!nodeDiagramBoard) {
                    return;
                }
                event.preventDefault();
                element.setPointerCapture(event.pointerId);
                element.classList.add('is-dragging');
                let lastPointerEvent = event;
                updateDropzoneHighlight(event, node.id);

                const handleMove = moveEvent => {
                    const rect = nodeDiagramBoard.getBoundingClientRect();
                    const width = rect.width || 1;
                    const height = rect.height || 1;
                    const x = clamp((moveEvent.clientX - rect.left) / width, 0.02, 0.98);
                    const y = clamp((moveEvent.clientY - rect.top) / height, 0.02, 0.98);
                    node.x = x;
                    node.y = y;
                    updateNodeElementPosition(element, node);
                    updateNodeDiagramEdges(model);
                    lastPointerEvent = moveEvent;
                    updateDropzoneHighlight(moveEvent, node.id);
                };

                const finish = endEvent => {
                    element.removeEventListener('pointermove', handleMove);
                    element.removeEventListener('pointerup', finish);
                    element.removeEventListener('lostpointercapture', finish);
                    element.classList.remove('is-dragging');
                    clearDropzoneHighlight();

                    const referenceEvent = endEvent instanceof PointerEvent ? endEvent : lastPointerEvent;
                    const dropTarget = detectDropTarget(referenceEvent, node.id);

                    if (dropTarget?.type === 'connection') {
                        if (node.type === 'device' || node.type === 'camera') {
                            assignDeviceToConnection(node.id, dropTarget.id);
                            node.connectionId = dropTarget.id;
                            updateEdgeForNode(model, node, dropTarget.id);
                            updateNodeDiagramEdges(model);
                            updateDeviceSummaries();
                            updateGroupCapacities();
                            validateMaterialCapacity();
                        } else if (node.type === 'workspace') {
                            assignWorkspaceToConnection(node.id, dropTarget.id);
                            node.connectionId = dropTarget.id;
                            updateEdgeForNode(model, node, dropTarget.id);
                            updateNodeDiagramEdges(model);
                        } else if (node.type === 'connection' && node.id !== dropTarget.id) {
                            toggleConnectionEdge(node.id, dropTarget.id, model);
                            updateNodeDiagramEdges(model);
                        }
                    } else if (dropTarget?.type === 'unlink') {
                        if (node.type === 'device' || node.type === 'camera') {
                            assignDeviceToConnection(node.id, null);
                            node.connectionId = null;
                            updateEdgeForNode(model, node, null);
                            updateNodeDiagramEdges(model);
                            updateDeviceSummaries();
                            updateGroupCapacities();
                            validateMaterialCapacity();
                        } else if (node.type === 'workspace') {
                            assignWorkspaceToConnection(node.id, null);
                            node.connectionId = null;
                            updateEdgeForNode(model, node, null);
                            updateNodeDiagramEdges(model);
                        } else if (node.type === 'connection') {
                            removeConnectionEdges(node.id, model);
                            updateNodeDiagramEdges(model);
                        }
                    }

                    persistNodeDiagram(model);
                };

                element.addEventListener('pointermove', handleMove);
                element.addEventListener('pointerup', finish);
                element.addEventListener('lostpointercapture', finish);
            });
        }

        function persistNodeDiagram(model) {
            if (!nodeDiagramInput) {
                return;
            }
            const nodes = (model.nodes ?? []).map(node => ({
                id: node.id,
                type: node.type,
                title: node.title,
                subtitle: node.subtitle,
                meta: node.meta,
                x: Number.isFinite(node.x) ? Number(node.x.toFixed(4)) : null,
                y: Number.isFinite(node.y) ? Number(node.y.toFixed(4)) : null
            }));
            const edges = (model.edges ?? []).map(edge => ({ from: edge.from, to: edge.to }));
            const payload = { nodes, edges };
            nodeDiagramInput.value = JSON.stringify(payload);
            storedDiagramData = payload;
        }

        nodeDiagramResetButton?.addEventListener('click', event => {
            event.preventDefault();
            storedDiagramData = { nodes: [], edges: [] };
            if (nodeDiagramInput) {
                nodeDiagramInput.value = '';
            }
            refreshNodeDiagram();
        });

        window.addEventListener('resize', () => {
            updateNodeDiagramEdges(nodeDiagramModel);
        });

        wizardForm?.addEventListener('input', event => {
            const target = event.target;
            if (!(target instanceof HTMLElement)) {
                return;
            }
            if (target.matches('input[data-field="connectionPoint"], input[data-field="deviceCount"], input[data-field="installLocation"], select[data-field="deviceTypeId"], input[data-field="name"], input[data-field="assignedNode"]')) {
                scheduleNodeDiagramRefresh();
            }
        });

        function requiresGenericCableLabel(select) {
            if (!(select instanceof HTMLSelectElement)) {
                return false;
            }
            const option = select.options[select.selectedIndex];
            const label = option?.text?.toLowerCase() ?? '';
            return label.includes('камера')
                || label.includes('точка доступа')
                || label.includes('wi-fi')
                || label.includes('wifi')
                || label.includes('точка сети')
                || label.includes('сетевая точка');
        }

        function updateCameraFieldsForGroup(group) {
            if (!group) {
                return;
            }
            const typeSelect = group.querySelector('select[data-field="deviceTypeId"]');
            const accessorySelect = group.querySelector('select[data-field="cameraAccessory"]');
            const depthInput = group.querySelector('input[data-field="cameraViewingDepth"]');
            const cameraFields = group.querySelector('[data-role="camera-fields"]');
            const detailsActive = isDeviceDetailsPhaseActive();
            const cameraTypeSelected = isCameraDevice(typeSelect);
            const cameraVisible = detailsActive && cameraTypeSelected;
            if (cameraFields) {
                cameraFields.classList.toggle('is-hidden', !cameraVisible);
            }
            if (accessorySelect) {
                accessorySelect.disabled = !cameraVisible;
                if (detailsActive && !cameraTypeSelected) {
                    accessorySelect.value = '';
                }
            }
            if (depthInput) {
                depthInput.disabled = !cameraVisible;
                if (detailsActive && !cameraTypeSelected) {
                    depthInput.value = '';
                }
            }
        }

        function getRequiredCableFunctions(select) {
            if (!(select instanceof HTMLSelectElement)) {
                return [];
            }
            const option = select.options[select.selectedIndex];
            const datasetValue = option?.dataset?.requiredCables || '';
            const functions = datasetValue
                .split(',')
                .map(item => item.trim().toUpperCase())
                .filter(Boolean);
            if (select.value && !functions.includes('SIGNAL')) {
                functions.push('SIGNAL');
            }
            return functions;
        }

        function updateCableFieldsForGroup(group) {
            if (!group) {
                return;
            }
            const typeSelect = group.querySelector('select[data-field="deviceTypeId"]');
            const detailsActive = isDeviceDetailsPhaseActive();
            const requiredFunctions = detailsActive ? getRequiredCableFunctions(typeSelect) : [];
            const container = group.querySelector('[data-role="cable-fields"]');
            if (!container) {
                return;
            }
            const fields = Array.from(container.querySelectorAll('.cable-field'));
            fields.forEach(field => {
                const functionName = (field.dataset.cableFunction || '').toUpperCase();
                const required = requiredFunctions.includes(functionName);
                field.classList.toggle('is-hidden', !required);
                const select = field.querySelector('select');
                if (select) {
                    select.disabled = !detailsActive || !required;
                    select.required = required;
                    if (detailsActive && !required) {
                        select.value = '';
                    }
                }
            });
            container.classList.toggle('is-hidden', !detailsActive || requiredFunctions.length === 0);
            const signalField = fields.find(field => (field.dataset.cableFunction || '').toUpperCase() === 'SIGNAL');
            if (signalField) {
                const labelElement = signalField.querySelector('label');
                if (labelElement) {
                    const defaultLabel = labelElement.dataset.defaultLabel || labelElement.textContent || '';
                    if (detailsActive && requiresGenericCableLabel(typeSelect)) {
                        labelElement.textContent = 'Кабель';
                    } else if (defaultLabel) {
                        labelElement.textContent = defaultLabel;
                    }
                }
            }
        }

        function getMountingRows() {
            return Array.from(document.querySelectorAll('.mounting-row'));
        }

        function getMountingRowElementId(row) {
            if (!row) {
                return '';
            }
            const hidden = row.querySelector('input[data-field="elementId"]');
            if (hidden instanceof HTMLInputElement) {
                return hidden.value.trim();
            }
            const select = row.querySelector('select[data-field="elementId"]');
            if (select instanceof HTMLSelectElement) {
                return select.value.trim();
            }
            return '';
        }

        function updateAutoMountingRow(row, elementId, elementName) {
            if (!row) {
                return;
            }
            row.classList.add('is-locked');
            row.dataset.autoElementId = elementId;
            const idInput = row.querySelector('input[data-field="elementId"]');
            if (idInput instanceof HTMLInputElement) {
                idInput.value = elementId;
            }
            const nameInput = row.querySelector('input[data-field="elementName"]');
            if (nameInput instanceof HTMLInputElement) {
                nameInput.value = elementName || '';
            }
            const displayName = row.querySelector('[data-role="element-name"]');
            if (displayName) {
                displayName.textContent = elementName || 'Не выбран';
            }
        }

        function createAutoMountingRow(elementId, elementName) {
            const row = document.createElement('div');
            row.classList.add('mounting-row', 'is-locked');

            const elementNameInput = document.createElement('input');
            elementNameInput.type = 'hidden';
            elementNameInput.setAttribute('data-field', 'elementName');
            row.appendChild(elementNameInput);

            const header = document.createElement('div');
            header.classList.add('grid', 'mounting-row-header');
            row.appendChild(header);

            const elementColumn = document.createElement('div');
            header.appendChild(elementColumn);
            const label = document.createElement('label');
            label.textContent = 'Монтажный короб / ящик';
            elementColumn.appendChild(label);

            const display = document.createElement('div');
            display.classList.add('mounting-element-display');
            elementColumn.appendChild(display);

            const elementIdInput = document.createElement('input');
            elementIdInput.type = 'hidden';
            elementIdInput.setAttribute('data-field', 'elementId');
            display.appendChild(elementIdInput);

            const nameParagraph = document.createElement('p');
            nameParagraph.classList.add('muted');
            nameParagraph.setAttribute('data-role', 'element-name');
            display.appendChild(nameParagraph);

            const noteParagraph = document.createElement('p');
            noteParagraph.classList.add('muted', 'small');
            noteParagraph.textContent = 'Назначен на шаге точек подключения.';
            display.appendChild(noteParagraph);

            const quantityColumn = document.createElement('div');
            header.appendChild(quantityColumn);
            const quantityLabel = document.createElement('label');
            quantityLabel.textContent = 'Количество / примечание';
            quantityColumn.appendChild(quantityLabel);
            const quantityInput = document.createElement('input');
            quantityInput.type = 'text';
            quantityInput.placeholder = '2 шт, 1 комплект...';
            quantityInput.setAttribute('data-field', 'quantity');
            quantityColumn.appendChild(quantityInput);

            const materialsContainer = document.createElement('div');
            materialsContainer.classList.add('stack', 'mounting-materials');
            materialsContainer.setAttribute('data-role', 'materials');
            row.appendChild(materialsContainer);

            if (mountingMaterialTemplate instanceof HTMLTemplateElement) {
                const materialClone = mountingMaterialTemplate.content.firstElementChild.cloneNode(true);
                materialsContainer.appendChild(materialClone);
            } else {
                const materialRow = document.createElement('div');
                materialRow.classList.add('mounting-material-row');
                materialsContainer.appendChild(materialRow);
            }

            const addMaterialButton = document.createElement('button');
            addMaterialButton.type = 'button';
            addMaterialButton.classList.add('button', 'tertiary');
            addMaterialButton.dataset.action = 'add-mounting-material';
            addMaterialButton.textContent = 'Добавить материал';
            row.appendChild(addMaterialButton);

            updateAutoMountingRow(row, elementId, elementName);
            return row;
        }

        function syncAutoMountingRows() {
            if (!mountingList) {
                return;
            }
            const assignments = new Map();
            const connectionRows = Array.from(connectionContainer?.querySelectorAll('.connection-point') ?? []);
            connectionRows.forEach(row => {
                const select = row.querySelector('select[data-field="mountingElementId"]');
                if (!(select instanceof HTMLSelectElement)) {
                    return;
                }
                const value = select.value.trim();
                if (!value) {
                    return;
                }
                if (!assignments.has(value)) {
                    const option = select.options[select.selectedIndex];
                    const name = option?.text?.trim() || '';
                    assignments.set(value, name);
                }
            });

            const rows = Array.from(mountingList.querySelectorAll('.mounting-row'));
            const manualRows = [];
            rows.forEach(row => {
                const elementId = getMountingRowElementId(row);
                if (row.classList.contains('is-locked')) {
                    if (!assignments.has(elementId)) {
                        row.remove();
                    } else {
                        updateAutoMountingRow(row, elementId, assignments.get(elementId) || '');
                        assignments.delete(elementId);
                    }
                } else {
                    manualRows.push(row);
                }
            });

            assignments.forEach((name, id) => {
                const newRow = createAutoMountingRow(id, name);
                if (manualRows.length > 0) {
                    mountingList.insertBefore(newRow, manualRows[0]);
                } else {
                    mountingList.appendChild(newRow);
                }
            });

            reindexMountingRows();
        }

        function reindexMountingRows() {
            const rows = getMountingRows();
            rows.forEach((row, index) => {
                row.dataset.index = index.toString();
                row.querySelectorAll('[data-field]').forEach(field => {
                    if (!(field instanceof HTMLElement)) {
                        return;
                    }
                    if (field.closest('.mounting-material-row')) {
                        return;
                    }
                    const key = field.getAttribute('data-field');
                    if (!key) {
                        return;
                    }
                    field.setAttribute('name', `mountingElements[${index}].${key}`);
                });
                const materialsContainer = row.querySelector('[data-role="materials"]');
                if (materialsContainer) {
                    const materialRows = Array.from(materialsContainer.querySelectorAll('.mounting-material-row'));
                    materialRows.forEach((materialRow, materialIndex) => {
                        materialRow.dataset.index = materialIndex.toString();
                        materialRow.querySelectorAll('[data-field]').forEach(field => {
                            const key = field.getAttribute('data-field');
                            if (!key) {
                                return;
                            }
                            let name = '';
                            if (key === 'materialId') {
                                name = `mountingElements[${index}].materials[${materialIndex}].materialId`;
                            } else if (key === 'amount') {
                                name = `mountingElements[${index}].materials[${materialIndex}].amount`;
                            }
                            if (name) {
                                field.setAttribute('name', name);
                            }
                        });
                        const removeMaterialButton = materialRow.querySelector('.remove-mounting-material');
                        if (removeMaterialButton) {
                            removeMaterialButton.style.display = materialIndex === 0 ? 'none' : '';
                        }
                    });
                }
                const removeButton = row.querySelector('.remove-mounting');
                if (removeButton) {
                    if (row.classList.contains('is-locked')) {
                        removeButton.style.display = 'none';
                    } else {
                        removeButton.style.display = index === 0 ? 'none' : '';
                    }
                }
            });
        }

        function reindexDeviceGroups() {
            const groups = getDeviceGroups();
            groups.forEach((group, index) => {
                group.dataset.index = index.toString();
                group.querySelectorAll('[data-field]').forEach(field => {
                    const key = field.getAttribute('data-field');
                    if (!key) {
                        return;
                    }
                    field.setAttribute('name', `deviceGroups[${index}].${key}`);
                });
                const numberElement = group.querySelector('[data-role="device-number"]');
                if (numberElement) {
                    numberElement.textContent = (index + 1).toString();
                }
                const removeButton = group.querySelector('.remove-device');
                if (removeButton) {
                    if (deviceGroupsLockedToTotal) {
                        removeButton.hidden = true;
                        removeButton.setAttribute('aria-hidden', 'true');
                        removeButton.setAttribute('tabindex', '-1');
                        removeButton.disabled = true;
                    } else {
                        removeButton.hidden = false;
                        removeButton.removeAttribute('aria-hidden');
                        removeButton.removeAttribute('tabindex');
                        removeButton.disabled = false;
                        removeButton.style.display = index === 0 ? 'none' : '';
                    }
                }
                updateCameraFieldsForGroup(group);
                updateCableFieldsForGroup(group);
            });
            updateTotalConnectionPoints();
            ensureDeviceCards();
            refreshGroupColumnsFromCards();
            syncConnectionPointsFromDevices();
            scheduleNodeDiagramRefresh();
        }

        function syncDeviceGroupsWithTotalCount() {
            if (!deviceGroupsLockedToTotal) {
                return false;
            }
            const desiredRaw = Number.parseInt(totalDeviceCountInput?.value ?? '', 10);
            if (!Number.isFinite(desiredRaw) || desiredRaw < 0) {
                reindexDeviceGroups();
                updateDeviceRelatedSummaries();
                return true;
            }
            let groups = getDeviceGroups();
            const desiredCount = desiredRaw;
            while (groups.length < desiredCount) {
                if (!(deviceTemplate instanceof HTMLTemplateElement) || !deviceContainer) {
                    break;
                }
                const clone = deviceTemplate.content.firstElementChild?.cloneNode(true);
                if (!clone) {
                    break;
                }
                deviceContainer.appendChild(clone);
                groups = getDeviceGroups();
            }
            while (groups.length > desiredCount) {
                const group = groups.pop();
                if (!group) {
                    break;
                }
                const index = Number.parseInt(group.dataset.index ?? '', 10);
                if (Number.isFinite(index)) {
                    removeDeviceCard(index);
                }
                group.remove();
                groups = getDeviceGroups();
            }
            reindexDeviceGroups();
            updateDeviceRelatedSummaries();
            return true;
        }

        function getDeviceCards() {
            const collected = [];
            let order = 0;
            const pushCard = card => {
                if (!card) {
                    return;
                }
                const parsedIndex = Number.parseInt(card.dataset.index ?? '', 10);
                collected.push({
                    card,
                    index: Number.isFinite(parsedIndex) ? parsedIndex : Number.NaN,
                    order: order++
                });
            };
            groupingPool?.querySelectorAll('.device-chip').forEach(pushCard);
            getGroupColumns().forEach(column => {
                column.querySelectorAll('.device-chip').forEach(pushCard);
            });
            collected.sort((left, right) => {
                const leftHasIndex = Number.isFinite(left.index);
                const rightHasIndex = Number.isFinite(right.index);
                if (leftHasIndex && rightHasIndex && left.index !== right.index) {
                    return left.index - right.index;
                }
                if (leftHasIndex && !rightHasIndex) {
                    return -1;
                }
                if (!leftHasIndex && rightHasIndex) {
                    return 1;
                }
                return left.order - right.order;
            });
            return collected.map(entry => entry.card);
        }

        function removeDeviceCard(index) {
            if (!Number.isInteger(index) || index < 0) {
                return;
            }
            const target = getDeviceCards().find(card => {
                const parsed = Number.parseInt(card.dataset.index ?? '', 10);
                return Number.isFinite(parsed) && parsed === index;
            });
            target?.remove();
        }

        function enableCardDrag(card) {
            if (!card || card.dataset.dragBound === 'true') {
                return;
            }
            card.addEventListener('dragstart', event => {
                event.dataTransfer?.setData('text/plain', card.dataset.index ?? '');
                event.dataTransfer?.setDragImage(card, 12, 12);
                card.classList.add('dragging');
                showGroupingWarning('');
                highlightDropzonesForCard(card);
            });
            card.addEventListener('dragend', () => {
                card.classList.remove('dragging');
                clearDropzoneHighlights();
            });
            card.dataset.dragBound = 'true';
        }

        function ensureDeviceCards() {
            if (!groupingPool) {
                return;
            }
            const groups = getDeviceGroups();
            let cards = getDeviceCards();
            while (cards.length < groups.length) {
                if (!(deviceChipTemplate instanceof HTMLTemplateElement)) {
                    break;
                }
                const clone = deviceChipTemplate.content.firstElementChild.cloneNode(true);
                groupingPool.appendChild(clone);
                cards = getDeviceCards();
            }
            while (cards.length > groups.length) {
                const card = cards.pop();
                card?.remove();
                cards = getDeviceCards();
            }
            cards = getDeviceCards();
            cards.forEach((card, index) => {
                card.dataset.index = index.toString();
                const hidden = card.querySelector('input[data-field="groupLabel"]');
                if (hidden) {
                    hidden.setAttribute('name', `deviceGroups[${index}].groupLabel`);
                    card.dataset.groupLabel = hidden.value.trim();
                }
                enableCardDrag(card);
                updateCardAssignmentDisplay(card);
            });
        }

        function getGroupColumns() {
            return Array.from(groupColumnsContainer?.querySelectorAll('.group-column') ?? []);
        }

        function ensureGroupColumn(label) {
            if (!groupColumnsContainer) {
                return null;
            }
            const trimmed = (label || '').trim();
            if (!trimmed) {
                return null;
            }
            let column = getGroupColumns().find(col => (col.dataset.groupLabel || '') === trimmed);
            if (!column) {
                if (!(groupColumnTemplate instanceof HTMLTemplateElement)) {
                    return null;
                }
                column = groupColumnTemplate.content.firstElementChild.cloneNode(true);
                groupColumnsContainer.appendChild(column);
                bindGroupColumnEvents(column);
            }
            column.dataset.groupLabel = trimmed;
            const input = column.querySelector('.group-name-input');
            if (input && input !== document.activeElement) {
                input.value = trimmed;
            }
            updateGroupingEmptyState();
            updateColumnConnection(column);
            return column;
        }

        function bindGroupColumnEvents(column) {
            const input = column.querySelector('.group-name-input');
            const dropzone = column.querySelector('[data-role="dropzone"]');
            const removeButton = column.querySelector('.remove-group');
            input?.addEventListener('input', () => {
                const newLabel = input.value.trim();
                column.dataset.groupLabel = newLabel;
                Array.from(dropzone?.querySelectorAll('.device-chip') ?? []).forEach(card => {
                    moveCardToGroup(card, newLabel);
                });
                if (!newLabel) {
                    column.remove();
                    updateGroupingEmptyState();
                    syncMaterialGroupsWithLabels();
                    validateMaterialCapacity();
                    return;
                }
                updateGroupingEmptyState();
                updateGroupCapacities();
                syncMaterialGroupsWithLabels();
                validateMaterialCapacity();
            });
            dropzone?.addEventListener('dragover', event => {
                event.preventDefault();
                dropzone.classList.add('drop-target');
            });
            dropzone?.addEventListener('dragleave', () => {
                dropzone.classList.remove('drop-target');
            });
            dropzone?.addEventListener('drop', event => {
                event.preventDefault();
                dropzone.classList.remove('drop-target');
                clearDropzoneHighlights();
                const index = Number(event.dataTransfer?.getData('text/plain'));
                const label = column.dataset.groupLabel || input?.value.trim() || '';
                moveCardToGroupByIndex(index, label);
            });
            removeButton?.addEventListener('click', () => {
                Array.from(column.querySelectorAll('.device-chip')).forEach(card => moveCardToGroup(card, ''));
                column.remove();
                updateGroupingEmptyState();
                syncMaterialGroupsWithLabels();
                validateMaterialCapacity();
            });
        }

        function updateGroupingEmptyState() {
            if (!groupingEmptyMessage || !groupColumnsContainer) {
                return;
            }
            const hasGroups = groupColumnsContainer.querySelector('.group-column') !== null;
            groupingEmptyMessage.hidden = hasGroups;
        }

        function updateCardAssignmentDisplay(card) {
            const labelElement = card.querySelector('[data-role="assignment-label"]');
            const label = (card.dataset.groupLabel || '').trim();
            if (labelElement) {
                labelElement.textContent = label || 'не задана';
            }
        }

        function syncDeviceGroupLabel(card, label) {
            if (!card || !deviceContainer) {
                return;
            }
            const index = Number(card.dataset.index);
            if (!Number.isInteger(index) || index < 0) {
                return;
            }
            const groupElement = deviceContainer.querySelector(`.device-group[data-index="${index}"]`);
            if (!groupElement) {
                return;
            }
            const hiddenField = groupElement.querySelector('input[data-field="groupLabel"]');
            if (hiddenField instanceof HTMLInputElement) {
                hiddenField.value = label;
            }
        }

        function moveCardToGroup(card, label, options = {}) {
            if (!card) {
                return;
            }
            const trimmed = (label || '').trim();
            const hidden = card.querySelector('input[data-field="groupLabel"]');
            const targetIsPool = trimmed.length === 0;
            let column = null;
            let dropzone = null;
            if (!targetIsPool) {
                column = ensureGroupColumn(trimmed);
                dropzone = column?.querySelector('[data-role="dropzone"]') ?? null;
                if (!dropzone) {
                    return;
                }
                if (!options.skipValidation && !isCardCompatibleWithColumn(card, column)) {
                    if (!options.silent) {
                        const allowed = column.dataset.allowedConnectionLabel || '';
                        const deviceConnection = (card.dataset.connectionPoint || '').trim() || 'без точки подключения';
                        const message = allowed
                            ? `Группы формируются по узлам. Устройство подключено к "${deviceConnection}", а группа предназначена для узла "${allowed}".`
                            : `Группы формируются по узлам. Устройство подключено к "${deviceConnection}", поэтому его нельзя объединять с этой группой.`;
                        showGroupingWarning(message);
                    }
                    return;
                }
            }
            if (hidden) {
                hidden.value = trimmed;
            }
            card.dataset.groupLabel = trimmed;
            syncDeviceGroupLabel(card, trimmed);
            updateCardAssignmentDisplay(card);
            if (targetIsPool || !dropzone) {
                groupingPool?.appendChild(card);
            } else {
                dropzone.appendChild(card);
            }
            if (!options.silent) {
                showGroupingWarning('');
            }
            updateGroupingEmptyState();
            updateGroupCapacities();
            syncMaterialGroupsWithLabels();
            validateMaterialCapacity();
        }

        function moveCardToGroupByIndex(index, label, options = {}) {
            const card = getDeviceCards().find(item => Number(item.dataset.index) === index);
            if (card) {
                moveCardToGroup(card, label, options);
            }
        }

        function getDeviceGroupData(index) {
            const group = deviceContainer?.querySelector(`.device-group[data-index="${index}"]`);
            if (!group) {
                return null;
            }
            const typeSelect = group.querySelector('select[data-field="deviceTypeId"]');
            const countInput = group.querySelector('input[data-field="deviceCount"]');
            const installInput = group.querySelector('input[data-field="installLocation"]');
            const connectionInput = group.querySelector('input[data-field="connectionPoint"]');
            const distanceInput = group.querySelector('input[data-field="distanceToConnectionPoint"]');
            const accessorySelect = group.querySelector('select[data-field="cameraAccessory"]');
            const viewingDepthInput = group.querySelector('input[data-field="cameraViewingDepth"]');
            const signalCableSelect = group.querySelector('select[data-field="signalCableTypeId"]');
            const lowVoltageCableSelect = group.querySelector('select[data-field="lowVoltageCableTypeId"]');
            const typeName = typeSelect instanceof HTMLSelectElement
                ? typeSelect.options[typeSelect.selectedIndex]?.text?.trim()
                : '';
            const connectionName = connectionInput?.value.trim() || '';
            return {
                typeName: typeName || '',
                count: countInput?.value.trim() || '1',
                installLocation: installInput?.value.trim() || '',
                connectionPoint: connectionName,
                connectionKey: normalizeConnectionName(connectionName),
                distance: distanceInput?.value.trim() || '',
                accessory: accessorySelect instanceof HTMLSelectElement
                    ? accessorySelect.options[accessorySelect.selectedIndex]?.text?.trim() || ''
                    : '',
                viewingDepth: viewingDepthInput?.value.trim() || '',
                signalCable: signalCableSelect instanceof HTMLSelectElement
                    ? signalCableSelect.options[signalCableSelect.selectedIndex]?.text?.trim() || ''
                    : '',
                lowVoltageCable: lowVoltageCableSelect instanceof HTMLSelectElement
                    ? lowVoltageCableSelect.options[lowVoltageCableSelect.selectedIndex]?.text?.trim() || ''
                    : '',
                signalLabel: requiresGenericCableLabel(typeSelect) ? 'Кабель' : 'Сигнал',
                isCamera: isCameraDevice(typeSelect)
            };
        }

        function updateDeviceSummaries() {
            getDeviceCards().forEach(card => {
                const index = Number(card.dataset.index);
                const summary = card.querySelector('[data-role="summary"]');
                if (Number.isNaN(index) || !summary) {
                    return;
                }
                const data = getDeviceGroupData(index);
                if (!data) {
                    summary.textContent = 'Заполните информацию на первом шаге, чтобы увидеть сводку.';
                    card.dataset.totalLength = '0';
                    card.dataset.connectionPoint = '';
                    card.dataset.connectionKey = '';
                    return;
                }
                card.dataset.connectionPoint = data.connectionPoint || '';
                card.dataset.connectionKey = data.connectionKey || '';
                const parts = [];
                if (data.typeName) {
                    parts.push(data.typeName);
                }
                if (data.installLocation) {
                    parts.push(`Установка: ${data.installLocation}`);
                }
                if (data.isCamera && data.accessory) {
                    parts.push(`Комплектация: ${data.accessory}`);
                }
                if (data.isCamera && data.viewingDepth) {
                    const hasUnit = /[a-zа-я]/i.test(data.viewingDepth);
                    const depthLabel = hasUnit ? data.viewingDepth : `${data.viewingDepth} м`;
                    parts.push(`Глубина: ${depthLabel}`);
                }
                const cableDescriptions = [];
                if (data.signalCable) {
                    cableDescriptions.push(`${data.signalLabel}: ${data.signalCable}`);
                }
                if (data.lowVoltageCable) {
                    cableDescriptions.push(`Питание: ${data.lowVoltageCable}`);
                }
                if (cableDescriptions.length > 0) {
                    parts.push(`Кабели: ${cableDescriptions.join(', ')}`);
                }
                summary.textContent = parts.length > 0
                    ? parts.join(' • ')
                    : 'Заполните информацию на первом шаге, чтобы увидеть сводку.';
                card.dataset.totalLength = '0';
            });
        }

        function updateDeviceRelatedSummaries() {
            updateDeviceSummaries();
            updateGroupCapacities();
            validateMaterialCapacity();
        }

        function refreshGroupColumnsFromCards() {
            if (!groupingPool) {
                return;
            }
            const cards = getDeviceCards();
            const labels = new Set();
            cards.forEach(card => {
                const label = (card.dataset.groupLabel || card.querySelector('input[data-field="groupLabel"]')?.value || '').trim();
                if (label) {
                    labels.add(label);
                }
            });
            labels.forEach(label => ensureGroupColumn(label));
            getGroupColumns().forEach(column => {
                const label = (column.dataset.groupLabel || '').trim();
                if (label && !labels.has(label)) {
                    column.remove();
                }
            });
            cards.forEach(card => {
                const label = (card.dataset.groupLabel || '').trim();
                if (label) {
                    const dropzone = ensureGroupColumn(label)?.querySelector('[data-role="dropzone"]');
                    dropzone?.appendChild(card);
                } else {
                    groupingPool.appendChild(card);
                }
                syncDeviceGroupLabel(card, label);
                updateCardAssignmentDisplay(card);
            });
            updateGroupingEmptyState();
            updateDeviceSummaries();
            updateGroupCapacities();
            syncMaterialGroupsWithLabels();
            validateMaterialCapacity();
        }

        function updateGroupCapacities() {
            getGroupColumns().forEach(column => {
                const dropzone = column.querySelector('[data-role="dropzone"]');
                let total = 0;
                Array.from(dropzone?.querySelectorAll('.device-chip') ?? []).forEach(card => {
                    const length = Number.parseFloat(card.dataset.totalLength ?? '0');
                    if (!Number.isNaN(length)) {
                        total += length;
                    }
                });
                column.dataset.totalLength = total.toString();
                const capacity = column.querySelector('[data-role="capacity"]');
                if (capacity) {
                    capacity.textContent = `Длина линии: ${total.toFixed(2)} м`;
                }
                updateColumnConnection(column);
            });
        }

        function collectGroupLabels() {
            const seen = new Set();
            const labels = [];
            getGroupColumns().forEach(column => {
                const label = (column.dataset.groupLabel || '').trim();
                if (label && !seen.has(label)) {
                    seen.add(label);
                    labels.push(label);
                }
            });
            return labels;
        }

        function showGroupingWarning(message) {
            if (!groupingWarning) {
                if (message) {
                    console.warn(message);
                }
                return;
            }
            if (message) {
                groupingWarning.textContent = message;
                groupingWarning.hidden = false;
            } else {
                groupingWarning.textContent = '';
                groupingWarning.hidden = true;
            }
        }

        function updateColumnConnection(column) {
            if (!column) {
                return;
            }
            const dropzone = column.querySelector('[data-role="dropzone"]');
            const cards = Array.from(dropzone?.querySelectorAll('.device-chip') ?? []);
            const cardWithConnection = cards.find(item => (item.dataset.connectionPoint || '').trim());
            const connectionLabel = cardWithConnection ? (cardWithConnection.dataset.connectionPoint || '').trim() : '';
            column.dataset.allowedConnection = cardWithConnection ? normalizeConnectionName(connectionLabel) : '';
            column.dataset.allowedConnectionLabel = connectionLabel;
            const hint = column.querySelector('[data-role="connection-hint"]');
            if (hint) {
                if (cards.length === 0) {
                    hint.textContent = 'Узел: не выбран';
                } else if (connectionLabel) {
                    hint.textContent = `Узел: ${connectionLabel}`;
                } else {
                    hint.textContent = 'Узел: не указан';
                }
            }
        }

        function isCardCompatibleWithColumn(card, column) {
            if (!card || !column) {
                return false;
            }
            const dropzone = column.querySelector('[data-role="dropzone"]');
            const existingCards = Array.from(dropzone?.querySelectorAll('.device-chip') ?? []).filter(existing => existing !== card);
            if (existingCards.length === 0) {
                return true;
            }
            const cardConnection = (card.dataset.connectionPoint || '').trim();
            const cardKey = normalizeConnectionName(cardConnection);
            const nonEmpty = existingCards
                .map(existing => ({
                    raw: (existing.dataset.connectionPoint || '').trim(),
                    key: normalizeConnectionName(existing.dataset.connectionPoint || '')
                }))
                .filter(item => item.raw);
            if (nonEmpty.length > 0) {
                return cardKey.length > 0 && cardKey === nonEmpty[0].key;
            }
            return cardConnection.length === 0;
        }

        function highlightDropzonesForCard(card) {
            getGroupColumns().forEach(column => {
                const dropzone = column.querySelector('[data-role="dropzone"]');
                if (!dropzone) {
                    return;
                }
                const compatible = isCardCompatibleWithColumn(card, column);
                dropzone.classList.toggle('is-incompatible', !compatible);
            });
        }

        function clearDropzoneHighlights() {
            getGroupColumns().forEach(column => {
                column.querySelector('[data-role="dropzone"]')?.classList.remove('is-incompatible');
            });
            groupingPool?.classList.remove('is-incompatible');
        }

        function setConnectionPointError(input, message) {
            const row = input.closest('.connection-point');
            const errorElement = row?.querySelector('[data-role="error"]');
            if (!row || !errorElement) {
                return;
            }
            if (message) {
                errorElement.textContent = message;
                errorElement.hidden = false;
                input.classList.add('input-error');
            } else {
                errorElement.textContent = '';
                errorElement.hidden = true;
                input.classList.remove('input-error');
            }
        }

        function parsePositiveInt(value) {
            if (typeof value !== 'string') {
                return 0;
            }
            const normalized = value.trim();
            if (normalized.length === 0) {
                return 0;
            }
            const parsed = Number.parseInt(normalized, 10);
            return Number.isFinite(parsed) && parsed > 0 ? parsed : 0;
        }

        function updateConnectionAccessories(row) {
            if (!row) {
                return;
            }
            const singleToggle = row.querySelector('input[data-field="singleSocketEnabled"]');
            const singleSettings = row.querySelector('[data-role="single-socket-settings"]');
            const singleInput = row.querySelector('input[data-field="singleSocketCount"]');
            const singleEnabled = singleToggle instanceof HTMLInputElement && singleToggle.checked;
            if (singleSettings) {
                singleSettings.classList.toggle('is-hidden', !singleEnabled);
            }
            if (singleInput) {
                singleInput.disabled = !singleEnabled;
                if (singleEnabled && parsePositiveInt(singleInput.value) < 1) {
                    singleInput.value = '1';
                }
            }

            const doubleToggle = row.querySelector('input[data-field="doubleSocketEnabled"]');
            const doubleSettings = row.querySelector('[data-role="double-socket-settings"]');
            const doubleInput = row.querySelector('input[data-field="doubleSocketCount"]');
            const doubleEnabled = doubleToggle instanceof HTMLInputElement && doubleToggle.checked;
            if (doubleSettings) {
                doubleSettings.classList.toggle('is-hidden', !doubleEnabled);
            }
            if (doubleInput) {
                doubleInput.disabled = !doubleEnabled;
                if (doubleEnabled && parsePositiveInt(doubleInput.value) < 1) {
                    doubleInput.value = '1';
                }
            }

            const breakerToggle = row.querySelector('input[data-field="breakersEnabled"]');
            const breakerSettings = row.querySelector('[data-role="breaker-settings"]');
            const breakerInput = row.querySelector('input[data-field="breakerCount"]');
            const breakerEnabled = breakerToggle instanceof HTMLInputElement && breakerToggle.checked;
            if (breakerSettings) {
                breakerSettings.classList.toggle('is-hidden', !breakerEnabled);
            }
            if (breakerInput) {
                breakerInput.disabled = !breakerEnabled;
                if (breakerEnabled && parsePositiveInt(breakerInput.value) < 2) {
                    breakerInput.value = '2';
                }
            }

            const effectiveSingle = singleEnabled ? Math.max(parsePositiveInt(singleInput?.value ?? ''), 1) : 0;
            const effectiveDouble = doubleEnabled ? Math.max(parsePositiveInt(doubleInput?.value ?? ''), 1) : 0;
            const effectiveBreakers = breakerEnabled ? Math.max(parsePositiveInt(breakerInput?.value ?? ''), 2) : 0;
            const breakerBoxes = effectiveBreakers > 0 ? Math.max(1, Math.ceil(effectiveBreakers / 2)) : 0;
            const nshvi = (effectiveSingle + effectiveDouble) * 4 + effectiveBreakers * 2;

            const breakerBoxesElement = row.querySelector('[data-role="breaker-boxes"]');
            if (breakerBoxesElement) {
                breakerBoxesElement.textContent = `${breakerBoxes} шт.`;
            }
            const nshviElement = row.querySelector('[data-role="nshvi-total"]');
            if (nshviElement) {
                nshviElement.textContent = `${nshvi} шт.`;
            }
        }

        function createConnectionRow() {
            if (!(connectionTemplate instanceof HTMLTemplateElement)) {
                return null;
            }
            return connectionTemplate.content.firstElementChild.cloneNode(true);
        }

        function bindConnectionRow(row) {
            if (!row || row.dataset.connectionBound === 'true') {
                return;
            }
            const removeButton = row.querySelector('.remove-connection');
            removeButton?.addEventListener('click', () => {
                row.remove();
                if (connectionContainer && connectionContainer.children.length === 0) {
                    const replacement = createConnectionRow();
                    if (replacement) {
                        connectionContainer.appendChild(replacement);
                        bindConnectionRow(replacement);
                    }
                }
                reindexConnectionPoints();
            });
            row.querySelectorAll('input[data-field], select[data-field]').forEach(field => {
                field.addEventListener('change', () => scheduleNodeDiagramRefresh());
                field.addEventListener('input', () => scheduleNodeDiagramRefresh());
            });
            row.dataset.connectionBound = 'true';
        }

        function createWorkspaceCard() {
            if (!(workspaceTemplate instanceof HTMLTemplateElement)) {
                return null;
            }
            return workspaceTemplate.content.firstElementChild.cloneNode(true);
        }

        function bindWorkspaceCard(card) {
            if (!card || card.dataset.workspaceBound === 'true') {
                return;
            }
            const removeButton = card.querySelector('.remove-workspace');
            removeButton?.addEventListener('click', () => {
                card.remove();
                if (getWorkspaceCards().length === 0) {
                    const replacement = createWorkspaceCard();
                    if (replacement && workspaceStepElement) {
                        workspaceStepElement.appendChild(replacement);
                        bindWorkspaceCard(replacement);
                    }
                }
                reindexWorkspaces();
            });
            card.querySelectorAll('input[data-field], textarea[data-field]').forEach(field => {
                field.addEventListener('input', () => scheduleNodeDiagramRefresh());
                field.addEventListener('change', () => scheduleNodeDiagramRefresh());
            });
            card.dataset.workspaceBound = 'true';
        }

        function reindexWorkspaces() {
            const cards = getWorkspaceCards();
            cards.forEach((card, index) => {
                card.dataset.index = index.toString();
                const numberElement = card.querySelector('[data-role="workspace-number"]');
                if (numberElement) {
                    numberElement.textContent = (index + 1).toString();
                }
                card.querySelectorAll('[data-field]').forEach(field => {
                    const key = field.getAttribute('data-field');
                    if (!key) {
                        return;
                    }
                    field.setAttribute('name', `workspaces[${index}].${key}`);
                });
                const removeButton = card.querySelector('.remove-workspace');
                if (removeButton) {
                    removeButton.style.display = index === 0 ? 'none' : '';
                }
            });
            const countField = wizardForm?.querySelector('input[name="workspaceCount"]');
            if (countField) {
                countField.value = cards.length.toString();
            }
            scheduleNodeDiagramRefresh();
        }

        function reindexConnectionPoints() {
            if (!connectionContainer) {
                return;
            }
            const rows = Array.from(connectionContainer.querySelectorAll('.connection-point'));
            rows.forEach((row, index) => {
                const nameInput = row.querySelector('input[data-field="name"]');
                const elementSelect = row.querySelector('select[data-field="mountingElementId"]');
                const distanceInput = row.querySelector('input[data-field="distanceToPower"]');
                const cableSelect = row.querySelector('select[data-field="powerCableTypeId"]');
                const materialSelect = row.querySelector('select[data-field="layingMaterialId"]');
                const surfaceCategorySelect = row.querySelector('select[data-field="layingSurfaceCategory"]');
                const surfaceInput = row.querySelector('input[data-field="layingSurface"]');
                const singleToggle = row.querySelector('input[data-field="singleSocketEnabled"]');
                const singleCount = row.querySelector('input[data-field="singleSocketCount"]');
                const doubleToggle = row.querySelector('input[data-field="doubleSocketEnabled"]');
                const doubleCount = row.querySelector('input[data-field="doubleSocketCount"]');
                const breakerToggle = row.querySelector('input[data-field="breakersEnabled"]');
                const breakerCount = row.querySelector('input[data-field="breakerCount"]');
                row.dataset.index = index.toString();
                if (nameInput) {
                    nameInput.setAttribute('name', `connectionPoints[${index}].name`);
                    row.dataset.connectionName = nameInput.value.trim();
                }
                if (elementSelect) {
                    elementSelect.setAttribute('name', `connectionPoints[${index}].mountingElementId`);
                }
                if (distanceInput) {
                    distanceInput.setAttribute('name', `connectionPoints[${index}].distanceToPower`);
                }
                if (cableSelect) {
                    cableSelect.setAttribute('name', `connectionPoints[${index}].powerCableTypeId`);
                }
                if (materialSelect) {
                    materialSelect.setAttribute('name', `connectionPoints[${index}].layingMaterialId`);
                }
                if (surfaceCategorySelect) {
                    surfaceCategorySelect.setAttribute('name', `connectionPoints[${index}].layingSurfaceCategory`);
                }
                if (surfaceInput) {
                    surfaceInput.setAttribute('name', `connectionPoints[${index}].layingSurface`);
                }
                if (singleToggle) {
                    singleToggle.setAttribute('name', `connectionPoints[${index}].singleSocketEnabled`);
                }
                if (singleCount) {
                    singleCount.setAttribute('name', `connectionPoints[${index}].singleSocketCount`);
                }
                if (doubleToggle) {
                    doubleToggle.setAttribute('name', `connectionPoints[${index}].doubleSocketEnabled`);
                }
                if (doubleCount) {
                    doubleCount.setAttribute('name', `connectionPoints[${index}].doubleSocketCount`);
                }
                if (breakerToggle) {
                    breakerToggle.setAttribute('name', `connectionPoints[${index}].breakersEnabled`);
                }
                if (breakerCount) {
                    breakerCount.setAttribute('name', `connectionPoints[${index}].breakerCount`);
                }
                const removeButton = row.querySelector('.remove-connection');
                if (removeButton) {
                    removeButton.style.display = index === 0 ? 'none' : '';
                }
                bindConnectionRow(row);
                updateConnectionAccessories(row);
            });
            if (connectionEmptyMessage) {
                connectionEmptyMessage.hidden = rows.length > 0;
            }
            scheduleNodeDiagramRefresh();
        }

        function syncConnectionPointsFromDevices() {
            if (!connectionContainer) {
                return;
            }
            const usageMap = new Map();
            const groups = getDeviceGroups();
            const rowMap = new Map();
            Array.from(connectionContainer.querySelectorAll('.connection-point')).forEach(row => {
                const key = (row.dataset.connectionName || '').trim();
                if (key) {
                    rowMap.set(key, row);
                }
                row.dataset.matched = 'false';
            });
            groups.forEach((group, index) => {
                const connectionInput = group.querySelector('input[data-field="connectionPoint"]');
                const name = connectionInput?.value.trim();
                if (!name) {
                    return;
                }
                if (!usageMap.has(name)) {
                    usageMap.set(name, []);
                }
                usageMap.get(name).push(index);
                let row = rowMap.get(name);
                if (!row) {
                    if (!(connectionTemplate instanceof HTMLTemplateElement)) {
                        return;
                    }
                    row = connectionTemplate.content.firstElementChild.cloneNode(true);
                    connectionContainer.appendChild(row);
                    rowMap.set(name, row);
                }
                row.dataset.matched = 'true';
                row.dataset.connectionName = name;
                const nameInput = row.querySelector('input[data-field="name"]');
                if (nameInput && nameInput.value.trim() !== name) {
                    nameInput.value = name;
                }
            });
            Array.from(connectionContainer.querySelectorAll('.connection-point')).forEach(row => {
                if (row.dataset.matched !== 'true') {
                    row.remove();
                } else {
                    row.removeAttribute('data-matched');
                }
            });
            reindexConnectionPoints();
            updateConnectionPointUsage(usageMap);
            syncAutoMountingRows();
            scheduleNodeDiagramRefresh();
        }

        function updateConnectionPointUsage(usageMap) {
            if (!connectionContainer) {
                return;
            }
            Array.from(connectionContainer.querySelectorAll('.connection-point')).forEach(row => {
                const usageElement = row.querySelector('[data-role="usage"]');
                if (!usageElement) {
                    return;
                }
                const name = row.dataset.connectionName || '';
                const indices = usageMap.get(name) || [];
                if (indices.length === 0) {
                    usageElement.textContent = 'Нет привязанных устройств.';
                    return;
                }
                const descriptions = indices.map(index => {
                    const data = getDeviceGroupData(index);
                    if (!data) {
                        return `Устройство №${index + 1}`;
                    }
                    const parts = [];
                    if (data.typeName) {
                        parts.push(data.typeName);
                    } else {
                        parts.push(`Устройство №${index + 1}`);
                    }
                    if (data.count) {
                        parts.push(`${data.count} шт.`);
                    }
                    if (data.installLocation) {
                        parts.push(data.installLocation);
                    }
                    return parts.join(' — ');
                });
                usageElement.textContent = `Устройства: ${descriptions.join('; ')}`;
            });
        }

        function updateDeviceConnectionNames(oldName, newName) {
            if (!deviceContainer || !oldName || oldName === newName) {
                return;
            }
            Array.from(deviceContainer.querySelectorAll('input[data-field="connectionPoint"]')).forEach(input => {
                if (input.value.trim() === oldName) {
                    input.value = newName;
                }
            });
        }

        function syncMaterialGroupsWithLabels() {
            if (!materialGroupsContainer) {
                return;
            }
            const labels = collectGroupLabels();
            const existing = Array.from(materialGroupsContainer.querySelectorAll('.material-group'));
            const groupMap = new Map(existing.map(group => [group.dataset.groupLabel || '', group]));
            const usedGroups = new Set();
            labels.forEach(label => {
                let group = groupMap.get(label);
                if (!group) {
                    if (!(materialGroupTemplate instanceof HTMLTemplateElement)) {
                        return;
                    }
                    group = materialGroupTemplate.content.firstElementChild.cloneNode(true);
                    materialGroupsContainer.appendChild(group);
                }
                group.dataset.groupLabel = label;
                const labelElement = group.querySelector('[data-role="label"]');
                if (labelElement) {
                    labelElement.textContent = label;
                }
                const hiddenInput = group.querySelector('input[data-field="groupLabel"]');
                if (hiddenInput) {
                    hiddenInput.value = label;
                }
                usedGroups.add(group);
            });
            existing.forEach(group => {
                if (!usedGroups.has(group)) {
                    group.remove();
                }
            });
            if (materialsEmptyMessage) {
                materialsEmptyMessage.hidden = labels.length > 0;
            }
            reindexMaterialGroups();
            validateMaterialCapacity();
        }

        function reindexMaterialGroups() {
            if (!materialGroupsContainer) {
                return;
            }
            const groups = Array.from(materialGroupsContainer.querySelectorAll('.material-group'));
            groups.forEach((group, groupIndex) => {
                group.dataset.index = groupIndex.toString();
                const labelInput = group.querySelector('input[data-field="groupLabel"]');
                if (labelInput) {
                    labelInput.setAttribute('name', `materialGroups[${groupIndex}].groupLabel`);
                    group.dataset.groupLabel = labelInput.value.trim();
                }
                const rows = Array.from(group.querySelectorAll('.material-row'));
                rows.forEach((row, rowIndex) => {
                    row.dataset.index = rowIndex.toString();
                    row.querySelectorAll('[data-field]').forEach(field => {
                        const key = field.getAttribute('data-field');
                        if (!key) {
                            return;
                        }
                        let name = '';
                        if (key === 'materialId') {
                            name = `materialGroups[${groupIndex}].materials[${rowIndex}].materialId`;
                        } else if (key === 'amount') {
                            name = `materialGroups[${groupIndex}].materials[${rowIndex}].amount`;
                        } else if (key === 'layingSurface') {
                            name = `materialGroups[${groupIndex}].materials[${rowIndex}].layingSurface`;
                        } else if (key === 'layingSurfaceCategory') {
                            name = `materialGroups[${groupIndex}].materials[${rowIndex}].layingSurfaceCategory`;
                        }
                        if (name) {
                            field.setAttribute('name', name);
                        }
                    });
                    const removeButton = row.querySelector('.remove-material');
                    if (removeButton) {
                        removeButton.style.display = rowIndex === 0 ? 'none' : '';
                    }
                });
            });
        }

        function parseLength(value) {
            if (!value) {
                return Number.NaN;
            }
            const match = value.replace(',', '.').match(/\d+(?:\.\d+)?/);
            return match ? Number.parseFloat(match[0]) : Number.NaN;
        }

        function validateMaterialCapacity() {
            if (!materialGroupsContainer) {
                return;
            }
            const capacities = new Map();
            getGroupColumns().forEach(column => {
                const label = (column.dataset.groupLabel || '').trim();
                if (!label) {
                    return;
                }
                const total = Number.parseFloat(column.dataset.totalLength ?? '0');
                capacities.set(label, Number.isNaN(total) ? 0 : total);
            });
            Array.from(materialGroupsContainer.querySelectorAll('.material-group')).forEach(group => {
                const label = (group.dataset.groupLabel || '').trim();
                const capacity = capacities.get(label) ?? 0;
                let used = 0;
                group.querySelectorAll('input[data-field="amount"]').forEach(input => {
                    const value = parseLength(input.value);
                    if (!Number.isNaN(value)) {
                        used += value;
                    }
                });
                group.dataset.capacity = capacity.toString();
                group.dataset.usedLength = used.toString();
                const warning = group.querySelector('[data-role="capacity-warning"]');
                const over = capacity > 0 && used > capacity + 0.0001;
                group.classList.toggle('over-capacity', over);
                if (warning) {
                    warning.hidden = !over;
                    if (over) {
                        warning.textContent = `Запланировано ${used.toFixed(2)} м при доступных ${capacity.toFixed(2)} м.`;
                    }
                }
            });
        }

        if (deviceGroupsLockedToTotal) {
            if (addDeviceButton) {
                addDeviceButton.hidden = true;
                addDeviceButton.setAttribute('aria-hidden', 'true');
                addDeviceButton.setAttribute('tabindex', '-1');
                addDeviceButton.disabled = true;
            }
        } else {
            addDeviceButton?.addEventListener('click', () => {
                if (!(deviceTemplate instanceof HTMLTemplateElement) || !deviceContainer) {
                    return;
                }
                const clone = deviceTemplate.content.firstElementChild.cloneNode(true);
                deviceContainer.appendChild(clone);
                reindexDeviceGroups();
            });
        }

        deviceContainer?.addEventListener('input', event => {
            const target = event.target;
            if (!(target instanceof HTMLInputElement)) {
                return;
            }
            const field = target.getAttribute('data-field');
            if (field === 'deviceCount') {
                updateTotalConnectionPoints();
                updateDeviceSummaries();
                updateGroupCapacities();
                validateMaterialCapacity();
            }
            if (field === 'connectionPoint') {
                updateTotalConnectionPoints();
                syncConnectionPointsFromDevices();
                updateDeviceSummaries();
                updateGroupCapacities();
                validateMaterialCapacity();
            } else if (field === 'installLocation' || field === 'distanceToConnectionPoint') {
                updateDeviceSummaries();
                updateGroupCapacities();
                validateMaterialCapacity();
            } else if (field === 'cameraViewingDepth') {
                updateDeviceSummaries();
            }
        });

        deviceContainer?.addEventListener('change', event => {
            const target = event.target;
            if (!(target instanceof HTMLSelectElement)) {
                return;
            }
            const field = target.getAttribute('data-field');
            if (field === 'deviceTypeId') {
                const group = target.closest('.device-group');
                updateCameraFieldsForGroup(group);
                updateCableFieldsForGroup(group);
                updateDeviceSummaries();
                updateGroupCapacities();
                validateMaterialCapacity();
            } else if (field === 'cameraAccessory') {
                updateDeviceSummaries();
            } else if (field === 'signalCableTypeId' || field === 'lowVoltageCableTypeId'
                    || field === 'powerCableTypeId') {
                updateDeviceSummaries();
            }
        });

        if (!deviceGroupsLockedToTotal) {
            deviceContainer?.addEventListener('click', event => {
                const target = event.target;
                if (!(target instanceof HTMLElement)) {
                    return;
                }
                if (target.classList.contains('remove-device')) {
                    const group = target.closest('.device-group');
                    if (group && deviceContainer.children.length > 1) {
                        const index = Number.parseInt(group.dataset.index ?? '', 10);
                        group.remove();
                        removeDeviceCard(Number.isFinite(index) ? index : -1);
                        reindexDeviceGroups();
                    }
                }
            });
        }

        connectionContainer?.addEventListener('focusin', event => {
            const target = event.target;
            if (target instanceof HTMLInputElement && target.getAttribute('data-field') === 'name') {
                target.dataset.originalValue = target.value.trim();
            }
        });

        if (deviceGroupsLockedToTotal) {
            const handleTotalDeviceCountChange = () => {
                syncDeviceGroupsWithTotalCount();
            };
            totalDeviceCountInput?.addEventListener('input', handleTotalDeviceCountChange);
            totalDeviceCountInput?.addEventListener('change', handleTotalDeviceCountChange);
        }

        connectionContainer?.addEventListener('focusout', event => {
            const target = event.target;
            if (!(target instanceof HTMLInputElement) || target.getAttribute('data-field') !== 'name') {
                return;
            }
            const row = target.closest('.connection-point');
            if (!row) {
                return;
            }
            const oldValue = target.dataset.originalValue || row.dataset.connectionName || '';
            const newValue = target.value.trim();
            if (!newValue) {
                setConnectionPointError(target, 'Введите название точки подключения');
                target.value = oldValue;
                return;
            }
            const duplicate = Array.from(connectionContainer.querySelectorAll('.connection-point')).some(other => {
                if (other === row) {
                    return false;
                }
                const otherInput = other.querySelector('input[data-field="name"]');
                const otherName = other.dataset.connectionName || otherInput?.value.trim() || '';
                return otherName === newValue;
            });
            if (duplicate) {
                setConnectionPointError(target, 'Название должно быть уникальным');
                target.value = oldValue;
                return;
            }
            setConnectionPointError(target, null);
            row.dataset.connectionName = newValue;
            updateDeviceConnectionNames(oldValue, newValue);
            syncConnectionPointsFromDevices();
            updateDeviceSummaries();
            updateGroupCapacities();
            validateMaterialCapacity();
        });

        connectionContainer?.addEventListener('change', event => {
            const target = event.target;
            if (!(target instanceof HTMLInputElement || target instanceof HTMLSelectElement)) {
                return;
            }
            const field = target.getAttribute('data-field');
            if (target instanceof HTMLSelectElement && field === 'mountingElementId') {
                syncAutoMountingRows();
            }
            if (field === 'singleSocketEnabled' || field === 'doubleSocketEnabled' || field === 'breakersEnabled') {
                const row = target.closest('.connection-point');
                updateConnectionAccessories(row);
            }
        });

        connectionContainer?.addEventListener('input', event => {
            const target = event.target;
            if (!(target instanceof HTMLInputElement)) {
                return;
            }
            const field = target.getAttribute('data-field');
            if (field === 'singleSocketCount' || field === 'doubleSocketCount' || field === 'breakerCount') {
                const row = target.closest('.connection-point');
                updateConnectionAccessories(row);
            }
        });

        addConnectionButton?.addEventListener('click', () => {
            if (!connectionContainer) {
                return;
            }
            const row = createConnectionRow();
            if (!row) {
                return;
            }
            connectionContainer.appendChild(row);
            bindConnectionRow(row);
            reindexConnectionPoints();
        });

        addWorkspaceButton?.addEventListener('click', () => {
            if (!workspaceStepElement) {
                return;
            }
            const card = createWorkspaceCard();
            if (!card) {
                return;
            }
            workspaceStepElement.appendChild(card);
            bindWorkspaceCard(card);
            reindexWorkspaces();
        });

        addGroupButton?.addEventListener('click', () => {
            const labels = collectGroupLabels();
            let counter = labels.length + 1;
            let proposed = `Группа ${counter}`;
            while (labels.includes(proposed)) {
                counter += 1;
                proposed = `Группа ${counter}`;
            }
            const column = ensureGroupColumn(proposed);
            if (column) {
                const input = column.querySelector('.group-name-input');
                if (input) {
                    input.value = proposed;
                    input.focus();
                    input.select();
                }
                column.dataset.groupLabel = proposed;
            }
            updateGroupingEmptyState();
            syncMaterialGroupsWithLabels();
        });

        groupingPool?.addEventListener('dragover', event => {
            event.preventDefault();
            groupingPool.classList.add('drop-target');
        });

        groupingPool?.addEventListener('dragleave', () => {
            groupingPool.classList.remove('drop-target');
        });

        groupingPool?.addEventListener('drop', event => {
            event.preventDefault();
            groupingPool.classList.remove('drop-target');
            clearDropzoneHighlights();
            const index = Number(event.dataTransfer?.getData('text/plain'));
            moveCardToGroupByIndex(index, '');
        });

        addMountingButton?.addEventListener('click', event => {
            event.preventDefault();
            if (!(mountingRowTemplate instanceof HTMLTemplateElement) || !mountingList) {
                return;
            }
            const clone = mountingRowTemplate.content.firstElementChild.cloneNode(true);
            mountingList.appendChild(clone);
            reindexMountingRows();
        });

        mountingList?.addEventListener('change', event => {
            const target = event.target;
            if (!(target instanceof HTMLSelectElement)) {
                return;
            }
            if (target.getAttribute('data-field') !== 'elementId') {
                return;
            }
            const row = target.closest('.mounting-row');
            if (!row) {
                return;
            }
            const hiddenName = row.querySelector('input[data-field="elementName"]');
            if (hiddenName instanceof HTMLInputElement) {
                const option = target.options[target.selectedIndex];
                hiddenName.value = option?.text ?? '';
            }
        });

        mountingList?.addEventListener('click', event => {
            const target = event.target;
            if (!(target instanceof HTMLElement)) {
                return;
            }
            if (target.dataset.action === 'add-mounting-material') {
                event.preventDefault();
                const row = target.closest('.mounting-row');
                if (!row || !(mountingMaterialTemplate instanceof HTMLTemplateElement)) {
                    return;
                }
                const container = row.querySelector('[data-role="materials"]');
                if (!container) {
                    return;
                }
                const clone = mountingMaterialTemplate.content.firstElementChild.cloneNode(true);
                container.appendChild(clone);
                reindexMountingRows();
                return;
            }
            if (target.classList.contains('remove-mounting-material')) {
                event.preventDefault();
                const materialRow = target.closest('.mounting-material-row');
                const row = target.closest('.mounting-row');
                if (!materialRow || !row) {
                    return;
                }
                const container = row.querySelector('[data-role="materials"]');
                if (!container) {
                    return;
                }
                const materialRows = Array.from(container.querySelectorAll('.mounting-material-row'));
                if (materialRows.length <= 1) {
                    materialRow.querySelectorAll('select[data-field], input[data-field]').forEach(field => {
                        if (field instanceof HTMLSelectElement || field instanceof HTMLInputElement) {
                            field.value = '';
                        }
                    });
                    return;
                }
                materialRow.remove();
                reindexMountingRows();
                return;
            }
            if (!target.classList.contains('remove-mounting')) {
                return;
            }
            event.preventDefault();
            const row = target.closest('.mounting-row');
            if (!row || row.classList.contains('is-locked')) {
                return;
            }
            const rows = getMountingRows();
            if (rows.length <= 1) {
                row.querySelectorAll('select[data-field], input[data-field]').forEach(field => {
                    if (field instanceof HTMLSelectElement || field instanceof HTMLInputElement) {
                        field.value = '';
                    }
                });
                const materials = row.querySelectorAll('.mounting-material-row');
                materials.forEach((materialRow, index) => {
                    materialRow.querySelectorAll('select[data-field], input[data-field]').forEach(field => {
                        if (field instanceof HTMLSelectElement || field instanceof HTMLInputElement) {
                            field.value = '';
                        }
                    });
                    if (index > 0) {
                        materialRow.remove();
                    }
                });
                reindexMountingRows();
                return;
            }
            row.remove();
            reindexMountingRows();
        });

        materialGroupsContainer?.addEventListener('click', event => {
            const target = event.target;
            if (!(target instanceof HTMLElement)) {
                return;
            }
            if (target.classList.contains('add-material')) {
                event.preventDefault();
                const group = target.closest('.material-group');
                const rowsContainer = group?.querySelector('.materials-container');
                if (!group || !rowsContainer || !(materialRowTemplate instanceof HTMLTemplateElement)) {
                    return;
                }
                const clone = materialRowTemplate.content.firstElementChild.cloneNode(true);
                rowsContainer.appendChild(clone);
                reindexMaterialGroups();
                validateMaterialCapacity();
                return;
            }
            if (target.classList.contains('remove-material')) {
                const row = target.closest('.material-row');
                const group = target.closest('.material-group');
                if (!row || !group) {
                    return;
                }
                const rows = group.querySelectorAll('.material-row');
                if (rows.length > 1) {
                    row.remove();
                    reindexMaterialGroups();
                    validateMaterialCapacity();
                }
            }
        });

        materialGroupsContainer?.addEventListener('input', event => {
            const target = event.target;
            if (target instanceof HTMLInputElement && target.getAttribute('data-field') === 'amount') {
                validateMaterialCapacity();
            }
        });

        function sanitizeFieldNames() {
            reindexDeviceGroups();
            reindexMountingRows();
            reindexConnectionPoints();
            reindexMaterialGroups();
            if (!wizardForm) {
                return;
            }
            wizardForm.querySelectorAll('[name*="__index__"]').forEach(field => {
                const key = field.getAttribute('data-field');
                if (!key) {
                    field.removeAttribute('name');
                    return;
                }
                const deviceGroup = field.closest('.device-group');
                if (deviceGroup && deviceGroup.dataset.index) {
                    field.setAttribute('name', `deviceGroups[${deviceGroup.dataset.index}].${key}`);
                    return;
                }
                const connectionPoint = field.closest('.connection-point');
                if (connectionPoint && connectionPoint.dataset.index) {
                    field.setAttribute('name', `connectionPoints[${connectionPoint.dataset.index}].${key}`);
                    return;
                }
                const materialGroup = field.closest('.material-group');
                if (materialGroup && materialGroup.dataset.index) {
                    const materialRow = field.closest('.material-row');
                    if (materialRow && materialRow.dataset.index) {
                        field.setAttribute('name', `materialGroups[${materialGroup.dataset.index}].materials[${materialRow.dataset.index}].${key}`);
                    } else {
                        field.setAttribute('name', `materialGroups[${materialGroup.dataset.index}].${key}`);
                    }
                    return;
                }
                const mountingRow = field.closest('.mounting-row');
                if (mountingRow && mountingRow.dataset.index) {
                    field.setAttribute('name', `mountingElements[${mountingRow.dataset.index}].${key}`);
                    return;
                }
                const workspaceCard = field.closest('.workspace');
                if (workspaceCard && workspaceCard.dataset.index) {
                    field.setAttribute('name', `workspaces[${workspaceCard.dataset.index}].${key}`);
                    return;
                }
                field.removeAttribute('name');
            });
        }

        wizardForm?.addEventListener('submit', () => {
            sanitizeFieldNames();
        });

        Array.from(connectionContainer?.querySelectorAll('.connection-point') ?? []).forEach(bindConnectionRow);
        getWorkspaceCards().forEach(bindWorkspaceCard);
        reindexWorkspaces();
        reindexConnectionPoints();
        reindexMountingRows();
        const deviceGroupsSynced = syncDeviceGroupsWithTotalCount();
        if (!deviceGroupsSynced) {
            reindexDeviceGroups();
            updateDeviceRelatedSummaries();
        }
        syncAutoMountingRows();
        refreshNodeDiagram();
        moveDeviceStepToPhase(stepPhaseMap.get(initialStep) || null);
        showStep(initialStep);
    });
</script>
</body>
</html>
