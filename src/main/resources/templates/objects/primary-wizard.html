<!DOCTYPE html>
<html lang="ru" xmlns:th="http://www.thymeleaf.org" xmlns:sec="http://www.thymeleaf.org/extras/spring-security">
<head>
    <meta charset="UTF-8">
    <title>Первичные данные объекта</title>
    <link rel="stylesheet" href="/css/main.css">
</head>
<body>
<header class="topbar">
    <h1>Object Manager</h1>
    <nav>
        <a href="/objects" class="active">Объекты</a>
        <a href="/customers">Заказчики</a>
        <a href="/admin" sec:authorize="hasRole('ADMIN')">Администрирование</a>
        <form method="post" action="/logout">
            <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}">
            <button type="submit" class="link-button">Выход</button>
        </form>
    </nav>
</header>
<main class="content">
    <section class="card">
        <div class="card-header">
            <h2 th:text="${object.name}">Объект</h2>
            <a class="button secondary" th:href="@{'/objects/' + ${object.id}}">Назад к объекту</a>
        </div>
        <p class="muted">Заполняйте первичные данные по шагам: сначала оборудование, затем точки подключения, после чего сгруппируйте устройства и задайте монтажные материалы.</p>
    </section>

    <form class="card wizard-form" method="post" th:action="@{'/objects/' + ${object.id} + '/primary-data/wizard'}" th:object="${wizardForm}">
        <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}">
        <nav class="wizard-progress">
            <button type="button" class="wizard-progress-step active" data-step-index="0">1. Оборудование</button>
            <button type="button" class="wizard-progress-step" data-step-index="1">2. Точки подключения</button>
            <button type="button" class="wizard-progress-step" data-step-index="2">3. Группы устройств</button>
            <button type="button" class="wizard-progress-step" data-step-index="3">4. Материалы</button>
        </nav>

        <div class="wizard-panels">
            <section class="wizard-step" data-step-index="0">
                <h3>Шаг 1. Оборудование</h3>
                <p class="muted">Укажите тип устройства, количество, место установки, точку подключения и расстояние до неё. Эти данные определяют дальнейшие шаги.</p>
                <div id="device-groups" class="stack">
                    <div class="device-group card nested-card" th:each="group, iter : *{deviceGroups}" th:data-index="${iter.index}">
                        <div class="grid">
                            <div>
                                <label>Тип устройства</label>
                                <select th:field="*{deviceGroups[__${iter.index}__].deviceTypeId}" data-field="deviceTypeId">
                                    <option value="">Не выбрано</option>
                                    <option th:each="type : ${deviceTypes}" th:value="${type.id}" th:text="${type.name}"></option>
                                </select>
                            </div>
                            <div>
                                <label>Количество</label>
                                <input type="number" min="0" step="1" class="device-count" th:field="*{deviceGroups[__${iter.index}__].deviceCount}" data-field="deviceCount">
                            </div>
                            <div>
                                <label>Расстояние до точки подключения (м)</label>
                                <input type="number" min="0" step="0.1" th:field="*{deviceGroups[__${iter.index}__].distanceToConnectionPoint}" data-field="distanceToConnectionPoint" placeholder="Например, 12">
                            </div>
                        </div>
                        <div class="grid">
                            <div>
                                <label>Точка установки</label>
                                <input type="text" th:field="*{deviceGroups[__${iter.index}__].installLocation}" data-field="installLocation" placeholder="Крыша, подъезд...">
                            </div>
                            <div>
                                <label>Точка подключения</label>
                                <input type="text" th:field="*{deviceGroups[__${iter.index}__].connectionPoint}" data-field="connectionPoint" placeholder="Распред. коробка...">
                            </div>
                        </div>
                        <button type="button" class="link-button danger remove-device" th:if="${iter.index > 0}">Удалить</button>
                    </div>
                </div>
                <template id="device-group-template">
                    <div class="device-group card nested-card">
                        <div class="grid">
                            <div>
                                <label>Тип устройства</label>
                                <select data-field="deviceTypeId">
                                    <option value="">Не выбрано</option>
                                    <option th:each="type : ${deviceTypes}" th:value="${type.id}" th:text="${type.name}"></option>
                                </select>
                            </div>
                            <div>
                                <label>Количество</label>
                                <input type="number" min="0" step="1" class="device-count" data-field="deviceCount">
                            </div>
                            <div>
                                <label>Расстояние до точки подключения (м)</label>
                                <input type="number" min="0" step="0.1" data-field="distanceToConnectionPoint" placeholder="Например, 12">
                            </div>
                        </div>
                        <div class="grid">
                            <div>
                                <label>Точка установки</label>
                                <input type="text" data-field="installLocation" placeholder="Крыша, подъезд...">
                            </div>
                            <div>
                                <label>Точка подключения</label>
                                <input type="text" data-field="connectionPoint" placeholder="Распред. коробка...">
                            </div>
                        </div>
                        <button type="button" class="link-button danger remove-device">Удалить</button>
                    </div>
                </template>
                <button type="button" class="button secondary" id="add-device-group">Добавить устройство</button>
                <p><strong>Всего точек подключения:</strong> <span id="connection-total" th:text="${totalConnectionPoints}">0</span></p>
            </section>

            <section class="wizard-step" data-step-index="1" hidden>
                <h3>Шаг 2. Точки подключения</h3>
                <p class="muted">Точки формируются автоматически на основании предыдущего шага. Названия должны быть уникальными, чтобы к одной точке можно было подключить несколько устройств.</p>
                <p class="muted" id="connection-empty" th:if="${#lists.isEmpty(wizardForm.connectionPoints)}">Добавьте устройства и укажите для них точки подключения на первом шаге.</p>
                <div id="connection-points" class="stack">
                    <div class="connection-point card nested-card" th:each="point, iter : *{connectionPoints}" th:data-connection-name="${point.name != null ? point.name : ''}">
                        <div class="grid">
                            <div>
                                <label>Название точки</label>
                                <input type="text" th:field="*{connectionPoints[__${iter.index}__].name}" data-field="name" placeholder="Распред. коробка №1">
                                <p class="field-error" data-role="error" hidden>Название должно быть уникальным</p>
                            </div>
                            <div>
                                <label>Монтажный короб / ящик</label>
                                <select th:field="*{connectionPoints[__${iter.index}__].mountingElementId}" data-field="mountingElementId">
                                    <option value="">Не выбран</option>
                                    <option th:each="element : ${mountingElements}" th:value="${element.id}" th:text="${element.name}"></option>
                                </select>
                            </div>
                        </div>
                        <div class="grid">
                            <div>
                                <label>Расстояние до точки запитки (м)</label>
                                <input type="number" min="0" step="0.1" th:field="*{connectionPoints[__${iter.index}__].distanceToPower}" data-field="distanceToPower" placeholder="Например, 5">
                            </div>
                            <div>
                                <label>Тип кабеля питания</label>
                                <select th:field="*{connectionPoints[__${iter.index}__].powerCableTypeId}" data-field="powerCableTypeId">
                                    <option value="">Не выбран</option>
                                    <option th:each="cable : ${cableTypes}" th:value="${cable.id}" th:text="${cable.name}"></option>
                                </select>
                            </div>
                        </div>
                        <div>
                            <label>Способ прокладки</label>
                            <input type="text" th:field="*{connectionPoints[__${iter.index}__].layingMethod}" data-field="layingMethod" placeholder="В гофре по потолку...">
                        </div>
                        <p class="connection-usage" data-role="usage">Устройства будут отображены после заполнения первого шага.</p>
                    </div>
                </div>
                <template id="connection-point-template">
                    <div class="connection-point card nested-card">
                        <div class="grid">
                            <div>
                                <label>Название точки</label>
                                <input type="text" data-field="name" placeholder="Распред. коробка №1">
                                <p class="field-error" data-role="error" hidden>Название должно быть уникальным</p>
                            </div>
                            <div>
                                <label>Монтажный короб / ящик</label>
                                <select data-field="mountingElementId">
                                    <option value="">Не выбран</option>
                                    <option th:each="element : ${mountingElements}" th:value="${element.id}" th:text="${element.name}"></option>
                                </select>
                            </div>
                        </div>
                        <div class="grid">
                            <div>
                                <label>Расстояние до точки запитки (м)</label>
                                <input type="number" min="0" step="0.1" data-field="distanceToPower" placeholder="Например, 5">
                            </div>
                            <div>
                                <label>Тип кабеля питания</label>
                                <select data-field="powerCableTypeId">
                                    <option value="">Не выбран</option>
                                    <option th:each="cable : ${cableTypes}" th:value="${cable.id}" th:text="${cable.name}"></option>
                                </select>
                            </div>
                        </div>
                        <div>
                            <label>Способ прокладки</label>
                            <input type="text" data-field="layingMethod" placeholder="В гофре по потолку...">
                        </div>
                        <p class="connection-usage" data-role="usage">Устройства будут отображены после заполнения первого шага.</p>
                    </div>
                </template>
            </section>

            <section class="wizard-step" data-step-index="2" hidden>
                <h3>Шаг 3. Группы устройств</h3>
                <p class="muted">Объедините камеры и другие устройства в логические группы. Эти группы будут использоваться для выбора монтажных материалов.</p>
                <div class="grouping-board">
                    <section class="grouping-source">
                        <h4>Устройства</h4>
                        <p class="muted small">Перетащите устройство в нужную группу.</p>
                        <div id="grouping-pool" class="grouping-pool">
                            <div class="device-chip" th:each="group, iter : *{deviceGroups}" th:data-index="${iter.index}" draggable="true">
                                <input type="hidden" th:field="*{deviceGroups[__${iter.index}__].groupLabel}" data-field="groupLabel">
                                <p class="muted small" data-role="summary">Заполните информацию на первом шаге, чтобы увидеть сводку.</p>
                                <p class="muted small" data-role="assignment">Группа: <span data-role="assignment-label">не задана</span></p>
                            </div>
                        </div>
                    </section>
                    <section class="grouping-destinations">
                        <div class="grouping-controls">
                            <button type="button" class="button secondary" id="add-group">Создать группу</button>
                        </div>
                        <p class="muted small" id="grouping-empty">Создайте группу и перетащите в неё устройства.</p>
                        <div id="grouping-columns" class="grouping-columns"></div>
                    </section>
                </div>
                <template id="group-column-template">
                    <div class="group-column card nested-card" data-group-label="">
                        <header class="group-header">
                            <input type="text" class="group-name-input" placeholder="Новая группа">
                            <button type="button" class="link-button danger remove-group">Удалить</button>
                        </header>
                        <p class="muted small" data-role="capacity">Длина линии: 0 м</p>
                        <div class="group-dropzone" data-role="dropzone"></div>
                    </div>
                </template>
                <template id="device-chip-template">
                    <div class="device-chip" draggable="true">
                        <input type="hidden" data-field="groupLabel">
                        <p class="muted small" data-role="summary">Заполните информацию на первом шаге, чтобы увидеть сводку.</p>
                        <p class="muted small" data-role="assignment">Группа: <span data-role="assignment-label">не задана</span></p>
                    </div>
                </template>
            </section>

            <section class="wizard-step" data-step-index="3" hidden>
                <h3>Шаг 4. Монтажные материалы</h3>
                <p class="muted">Для каждой созданной группы укажите материалы и способ прокладки. Если группа не требует материалов, оставьте поля пустыми.</p>
                <div class="card nested-card">
                    <h4>Монтажные элементы</h4>
                    <p class="muted small">Укажите дополнительные монтажные элементы, необходимые для всех групп.</p>
                    <div class="stack">
                        <div class="mounting-row" th:each="element, iter : *{mountingElements}" th:data-index="${iter.index}">
                            <input type="hidden" th:field="*{mountingElements[__${iter.index}__].elementId}" data-field="elementId">
                            <div class="grid">
                                <div>
                                    <label th:for="${'mounting-' + iter.index}" th:text="${element.elementName != null ? element.elementName : 'Элемент'}">Элемент</label>
                                    <input type="text" th:id="${'mounting-' + iter.index}" th:value="${element.elementName}" readonly>
                                </div>
                                <div>
                                    <label>Количество / примечание</label>
                                    <input type="text" th:field="*{mountingElements[__${iter.index}__].quantity}" data-field="quantity" placeholder="2 шт, 1 комплект...">
                                </div>
                            </div>
                        </div>
                        <p th:if="${#lists.isEmpty(mountingElements)}" class="muted small">Монтажные элементы пока не добавлены в администрировании.</p>
                    </div>
                </div>
                <p class="muted" id="materials-empty" th:if="${#lists.isEmpty(wizardForm.materialGroups)}">Создайте хотя бы одну группу устройств на предыдущем шаге, чтобы назначить материалы.</p>
                <div id="material-groups" class="stack">
                    <div class="material-group card nested-card" th:each="group, gIndex : *{materialGroups}" th:data-group-label="${group.groupLabel != null ? group.groupLabel : ''}">
                        <input type="hidden" th:field="*{materialGroups[__${gIndex.index}__].groupLabel}" data-field="groupLabel">
                        <header class="group-header">
                            <h4 class="group-label">Группа: <span data-role="label" th:text="${group.groupLabel}">Без названия</span></h4>
                        </header>
                        <p class="field-error capacity-warning" data-role="capacity-warning" hidden>Длина материалов превышает допустимую для этой группы.</p>
                        <div class="grid">
                            <div>
                                <label>Отображаемое название</label>
                                <input type="text" th:field="*{materialGroups[__${gIndex.index}__].groupName}" data-field="groupName" placeholder="Например, Линия 1">
                            </div>
                            <div>
                                <label>Поверхность прокладки</label>
                                <input type="text" th:field="*{materialGroups[__${gIndex.index}__].surface}" data-field="surface" placeholder="По потолку, в земле...">
                            </div>
                        </div>
                        <div class="stack materials-container" th:id="${'material-rows-' + gIndex.index}">
                            <div class="material-row" th:each="usage, uIndex : *{materialGroups[__${gIndex.index}__].materials}" th:data-index="${uIndex.index}">
                                <div class="grid">
                                    <div>
                                        <label>Материал</label>
                                        <select th:field="*{materialGroups[__${gIndex.index}__].materials[__${uIndex.index}__].materialId}" data-field="materialId">
                                            <option value="">Не выбран</option>
                                            <option th:each="material : ${installationMaterials}" th:value="${material.id}" th:text="${material.name}"></option>
                                        </select>
                                    </div>
                                    <div>
                                        <label>Объем / длина</label>
                                        <input type="text" th:field="*{materialGroups[__${gIndex.index}__].materials[__${uIndex.index}__].amount}" data-field="amount" placeholder="25 м, 4 шт...">
                                    </div>
                                    <div>
                                        <label>По чему проложены</label>
                                        <input type="text" th:field="*{materialGroups[__${gIndex.index}__].materials[__${uIndex.index}__].layingSurface}" data-field="layingSurface" placeholder="По стене, в коробе...">
                                    </div>
                                </div>
                                <button type="button" class="link-button danger remove-material" th:if="${uIndex.index > 0}">Удалить материал</button>
                            </div>
                        </div>
                        <button type="button" class="button secondary add-material">Добавить материал</button>
                    </div>
                </div>
                <template id="material-group-template">
                    <div class="material-group card nested-card">
                        <input type="hidden" data-field="groupLabel">
                        <header class="group-header">
                            <h4 class="group-label">Группа: <span data-role="label">Без названия</span></h4>
                        </header>
                        <p class="field-error capacity-warning" data-role="capacity-warning" hidden>Длина материалов превышает допустимую для этой группы.</p>
                        <div class="grid">
                            <div>
                                <label>Отображаемое название</label>
                                <input type="text" data-field="groupName" placeholder="Например, Линия 1">
                            </div>
                            <div>
                                <label>Поверхность прокладки</label>
                                <input type="text" data-field="surface" placeholder="По потолку, в земле...">
                            </div>
                        </div>
                        <div class="stack materials-container">
                            <div class="material-row">
                                <div class="grid">
                                    <div>
                                        <label>Материал</label>
                                        <select data-field="materialId">
                                            <option value="">Не выбран</option>
                                            <option th:each="material : ${installationMaterials}" th:value="${material.id}" th:text="${material.name}"></option>
                                        </select>
                                    </div>
                                    <div>
                                        <label>Объем / длина</label>
                                        <input type="text" data-field="amount" placeholder="25 м, 4 шт...">
                                    </div>
                                    <div>
                                        <label>По чему проложены</label>
                                        <input type="text" data-field="layingSurface" placeholder="По стене, в коробе...">
                                    </div>
                                </div>
                                <button type="button" class="link-button danger remove-material">Удалить материал</button>
                            </div>
                        </div>
                        <button type="button" class="button secondary add-material">Добавить материал</button>
                    </div>
                </template>
                <template id="material-row-template">
                    <div class="material-row">
                        <div class="grid">
                            <div>
                                <label>Материал</label>
                                <select data-field="materialId">
                                    <option value="">Не выбран</option>
                                    <option th:each="material : ${installationMaterials}" th:value="${material.id}" th:text="${material.name}"></option>
                                </select>
                            </div>
                            <div>
                                <label>Объем / длина</label>
                                <input type="text" data-field="amount" placeholder="25 м, 4 шт...">
                            </div>
                            <div>
                                <label>По чему проложены</label>
                                <input type="text" data-field="layingSurface" placeholder="По стене, в коробе...">
                            </div>
                        </div>
                        <button type="button" class="link-button danger remove-material">Удалить материал</button>
                    </div>
                </template>
            </section>
        </div>

        <div class="form-row wizard-controls">
            <button type="button" class="button secondary" data-action="prev-step">Назад</button>
            <button type="button" class="button primary" data-action="next-step">Далее</button>
            <button type="submit" class="button" data-role="finish" hidden>Сохранить первичные данные</button>
            <a class="button secondary" th:href="@{'/objects/' + ${object.id}}">Отмена</a>
        </div>
    </form>
</main>
<footer class="footer">
    <p>Object Manager &copy; 2025</p>
</footer>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        const deviceContainer = document.getElementById('device-groups');
        const deviceTemplate = document.getElementById('device-group-template');
        const addDeviceButton = document.getElementById('add-device-group');
        const connectionTotal = document.getElementById('connection-total');
        const connectionContainer = document.getElementById('connection-points');
        const connectionTemplate = document.getElementById('connection-point-template');
        const connectionEmptyMessage = document.getElementById('connection-empty');
        const groupingPool = document.getElementById('grouping-pool');
        const groupColumnsContainer = document.getElementById('grouping-columns');
        const groupColumnTemplate = document.getElementById('group-column-template');
        const groupingEmptyMessage = document.getElementById('grouping-empty');
        const addGroupButton = document.getElementById('add-group');
        const deviceChipTemplate = document.getElementById('device-chip-template');
        const materialGroupsContainer = document.getElementById('material-groups');
        const materialGroupTemplate = document.getElementById('material-group-template');
        const materialRowTemplate = document.getElementById('material-row-template');
        const materialsEmptyMessage = document.getElementById('materials-empty');
        const stepSections = Array.from(document.querySelectorAll('.wizard-step'));
        const stepButtons = Array.from(document.querySelectorAll('.wizard-progress-step'));
        const prevButton = document.querySelector('[data-action="prev-step"]');
        const nextButton = document.querySelector('[data-action="next-step"]');
        const finishButton = document.querySelector('[data-role="finish"]');
        const wizardForm = document.querySelector('.wizard-form');

        let currentStep = 0;

        function showStep(index) {
            if (index < 0 || index >= stepSections.length) {
                return;
            }
            currentStep = index;
            stepSections.forEach((section, idx) => {
                if (idx === index) {
                    section.removeAttribute('hidden');
                    section.classList.add('active');
                } else {
                    section.setAttribute('hidden', 'hidden');
                    section.classList.remove('active');
                }
            });
            stepButtons.forEach(button => {
                const stepIndex = Number(button.dataset.stepIndex);
                const isActive = stepIndex === index;
                button.classList.toggle('active', isActive);
                button.disabled = isActive;
            });
            if (prevButton) {
                prevButton.disabled = index === 0;
            }
            if (nextButton) {
                nextButton.hidden = index === stepSections.length - 1;
            }
            if (finishButton) {
                finishButton.hidden = index !== stepSections.length - 1;
            }
        }

        stepButtons.forEach(button => {
            button.addEventListener('click', () => {
                const stepIndex = Number(button.dataset.stepIndex);
                if (!Number.isNaN(stepIndex)) {
                    showStep(stepIndex);
                }
            });
        });
        prevButton?.addEventListener('click', () => {
            if (currentStep > 0) {
                showStep(currentStep - 1);
            }
        });
        nextButton?.addEventListener('click', () => {
            if (currentStep < stepSections.length - 1) {
                showStep(currentStep + 1);
            }
        });

        function updateTotalConnectionPoints() {
            if (!connectionTotal || !deviceContainer) {
                return;
            }
            const names = new Set();
            const connectionInputs = deviceContainer.querySelectorAll('input[data-field="connectionPoint"]');
            connectionInputs.forEach(input => {
                const value = input.value.trim();
                if (value) {
                    names.add(value);
                }
            });
            connectionTotal.textContent = names.size.toString();
        }

        function getDeviceGroups() {
            return Array.from(deviceContainer?.querySelectorAll('.device-group') ?? []);
        }

        function getMountingRows() {
            return Array.from(document.querySelectorAll('.mounting-row'));
        }

        function reindexMountingRows() {
            getMountingRows().forEach((row, index) => {
                row.dataset.index = index.toString();
                row.querySelectorAll('[data-field]').forEach(field => {
                    const key = field.getAttribute('data-field');
                    if (!key) {
                        return;
                    }
                    field.setAttribute('name', `mountingElements[${index}].${key}`);
                });
            });
        }

        function reindexDeviceGroups() {
            const groups = getDeviceGroups();
            groups.forEach((group, index) => {
                group.dataset.index = index.toString();
                group.querySelectorAll('[data-field]').forEach(field => {
                    const key = field.getAttribute('data-field');
                    if (!key) {
                        return;
                    }
                    field.setAttribute('name', `deviceGroups[${index}].${key}`);
                });
                const removeButton = group.querySelector('.remove-device');
                if (removeButton) {
                    removeButton.style.display = index === 0 ? 'none' : '';
                }
            });
            updateTotalConnectionPoints();
            ensureDeviceCards();
            refreshGroupColumnsFromCards();
            syncConnectionPointsFromDevices();
        }

        function getDeviceCards() {
            return Array.from(groupingPool?.querySelectorAll('.device-chip') ?? []);
        }

        function enableCardDrag(card) {
            if (!card || card.dataset.dragBound === 'true') {
                return;
            }
            card.addEventListener('dragstart', event => {
                event.dataTransfer?.setData('text/plain', card.dataset.index ?? '');
                event.dataTransfer?.setDragImage(card, 12, 12);
                card.classList.add('dragging');
            });
            card.addEventListener('dragend', () => {
                card.classList.remove('dragging');
            });
            card.dataset.dragBound = 'true';
        }

        function ensureDeviceCards() {
            if (!groupingPool) {
                return;
            }
            const groups = getDeviceGroups();
            let cards = getDeviceCards();
            while (cards.length < groups.length) {
                if (!(deviceChipTemplate instanceof HTMLTemplateElement)) {
                    break;
                }
                const clone = deviceChipTemplate.content.firstElementChild.cloneNode(true);
                groupingPool.appendChild(clone);
                cards = getDeviceCards();
            }
            while (cards.length > groups.length) {
                const card = cards.pop();
                card?.remove();
            }
            cards = getDeviceCards();
            cards.forEach((card, index) => {
                card.dataset.index = index.toString();
                const hidden = card.querySelector('input[data-field="groupLabel"]');
                if (hidden) {
                    hidden.setAttribute('name', `deviceGroups[${index}].groupLabel`);
                    card.dataset.groupLabel = hidden.value.trim();
                }
                enableCardDrag(card);
                updateCardAssignmentDisplay(card);
            });
        }

        function getGroupColumns() {
            return Array.from(groupColumnsContainer?.querySelectorAll('.group-column') ?? []);
        }

        function ensureGroupColumn(label) {
            if (!groupColumnsContainer) {
                return null;
            }
            const trimmed = (label || '').trim();
            if (!trimmed) {
                return null;
            }
            let column = getGroupColumns().find(col => (col.dataset.groupLabel || '') === trimmed);
            if (!column) {
                if (!(groupColumnTemplate instanceof HTMLTemplateElement)) {
                    return null;
                }
                column = groupColumnTemplate.content.firstElementChild.cloneNode(true);
                groupColumnsContainer.appendChild(column);
                bindGroupColumnEvents(column);
            }
            column.dataset.groupLabel = trimmed;
            const input = column.querySelector('.group-name-input');
            if (input && input !== document.activeElement) {
                input.value = trimmed;
            }
            updateGroupingEmptyState();
            return column;
        }

        function bindGroupColumnEvents(column) {
            const input = column.querySelector('.group-name-input');
            const dropzone = column.querySelector('[data-role="dropzone"]');
            const removeButton = column.querySelector('.remove-group');
            input?.addEventListener('input', () => {
                const newLabel = input.value.trim();
                column.dataset.groupLabel = newLabel;
                Array.from(dropzone?.querySelectorAll('.device-chip') ?? []).forEach(card => {
                    moveCardToGroup(card, newLabel);
                });
                if (!newLabel) {
                    column.remove();
                    updateGroupingEmptyState();
                    syncMaterialGroupsWithLabels();
                    validateMaterialCapacity();
                    return;
                }
                updateGroupingEmptyState();
                updateGroupCapacities();
                syncMaterialGroupsWithLabels();
                validateMaterialCapacity();
            });
            dropzone?.addEventListener('dragover', event => {
                event.preventDefault();
                dropzone.classList.add('drop-target');
            });
            dropzone?.addEventListener('dragleave', () => {
                dropzone.classList.remove('drop-target');
            });
            dropzone?.addEventListener('drop', event => {
                event.preventDefault();
                dropzone.classList.remove('drop-target');
                const index = Number(event.dataTransfer?.getData('text/plain'));
                const label = column.dataset.groupLabel || input?.value.trim() || '';
                moveCardToGroupByIndex(index, label);
            });
            removeButton?.addEventListener('click', () => {
                Array.from(column.querySelectorAll('.device-chip')).forEach(card => moveCardToGroup(card, ''));
                column.remove();
                updateGroupingEmptyState();
                syncMaterialGroupsWithLabels();
                validateMaterialCapacity();
            });
        }

        function updateGroupingEmptyState() {
            if (!groupingEmptyMessage || !groupColumnsContainer) {
                return;
            }
            const hasGroups = groupColumnsContainer.querySelector('.group-column') !== null;
            groupingEmptyMessage.hidden = hasGroups;
        }

        function updateCardAssignmentDisplay(card) {
            const labelElement = card.querySelector('[data-role="assignment-label"]');
            const label = (card.dataset.groupLabel || '').trim();
            if (labelElement) {
                labelElement.textContent = label || 'не задана';
            }
        }

        function moveCardToGroup(card, label) {
            if (!card) {
                return;
            }
            const trimmed = (label || '').trim();
            const hidden = card.querySelector('input[data-field="groupLabel"]');
            if (hidden) {
                hidden.value = trimmed;
            }
            card.dataset.groupLabel = trimmed;
            updateCardAssignmentDisplay(card);
            let target = groupingPool;
            if (trimmed) {
                const column = ensureGroupColumn(trimmed);
                target = column?.querySelector('[data-role="dropzone"]') ?? groupingPool;
            }
            target?.appendChild(card);
            updateGroupingEmptyState();
            updateGroupCapacities();
            syncMaterialGroupsWithLabels();
            validateMaterialCapacity();
        }

        function moveCardToGroupByIndex(index, label) {
            const card = getDeviceCards().find(item => Number(item.dataset.index) === index);
            if (card) {
                moveCardToGroup(card, label);
            }
        }

        function getDeviceGroupData(index) {
            const group = deviceContainer?.querySelector(`.device-group[data-index="${index}"]`);
            if (!group) {
                return null;
            }
            const typeSelect = group.querySelector('select[data-field="deviceTypeId"]');
            const countInput = group.querySelector('input[data-field="deviceCount"]');
            const installInput = group.querySelector('input[data-field="installLocation"]');
            const connectionInput = group.querySelector('input[data-field="connectionPoint"]');
            const distanceInput = group.querySelector('input[data-field="distanceToConnectionPoint"]');
            const typeName = typeSelect instanceof HTMLSelectElement
                ? typeSelect.options[typeSelect.selectedIndex]?.text?.trim()
                : '';
            return {
                typeName: typeName || '',
                count: countInput?.value.trim() || '',
                installLocation: installInput?.value.trim() || '',
                connectionPoint: connectionInput?.value.trim() || '',
                distance: distanceInput?.value.trim() || ''
            };
        }

        function updateDeviceSummaries() {
            getDeviceCards().forEach(card => {
                const index = Number(card.dataset.index);
                const summary = card.querySelector('[data-role="summary"]');
                if (Number.isNaN(index) || !summary) {
                    return;
                }
                const data = getDeviceGroupData(index);
                if (!data) {
                    summary.textContent = 'Заполните информацию на первом шаге, чтобы увидеть сводку.';
                    card.dataset.totalLength = '0';
                    return;
                }
                const parts = [];
                if (data.typeName) {
                    parts.push(data.typeName);
                }
                if (data.count) {
                    parts.push(`${data.count} шт.`);
                }
                if (data.installLocation) {
                    parts.push(`Установка: ${data.installLocation}`);
                }
                if (data.connectionPoint) {
                    parts.push(`Подключение: ${data.connectionPoint}`);
                }
                if (data.distance) {
                    parts.push(`Расстояние: ${data.distance} м`);
                }
                summary.textContent = parts.length > 0
                    ? parts.join(' • ')
                    : 'Заполните информацию на первом шаге, чтобы увидеть сводку.';
                const countValue = Number.parseInt(data.count.replace(',', '.'), 10);
                const distanceValue = Number.parseFloat(data.distance.replace(',', '.'));
                const length = Number.isFinite(countValue) && Number.isFinite(distanceValue)
                    ? Math.max(countValue, 0) * Math.max(distanceValue, 0)
                    : 0;
                card.dataset.totalLength = Number.isFinite(length) ? length.toString() : '0';
            });
        }

        function refreshGroupColumnsFromCards() {
            if (!groupingPool) {
                return;
            }
            const cards = getDeviceCards();
            const labels = new Set();
            cards.forEach(card => {
                const label = (card.dataset.groupLabel || card.querySelector('input[data-field="groupLabel"]')?.value || '').trim();
                if (label) {
                    labels.add(label);
                }
            });
            labels.forEach(label => ensureGroupColumn(label));
            getGroupColumns().forEach(column => {
                const label = (column.dataset.groupLabel || '').trim();
                if (label && !labels.has(label)) {
                    column.remove();
                }
            });
            cards.forEach(card => {
                const label = (card.dataset.groupLabel || '').trim();
                if (label) {
                    const dropzone = ensureGroupColumn(label)?.querySelector('[data-role="dropzone"]');
                    dropzone?.appendChild(card);
                } else {
                    groupingPool.appendChild(card);
                }
                updateCardAssignmentDisplay(card);
            });
            updateGroupingEmptyState();
            updateDeviceSummaries();
            updateGroupCapacities();
            syncMaterialGroupsWithLabels();
            validateMaterialCapacity();
        }

        function updateGroupCapacities() {
            getGroupColumns().forEach(column => {
                const dropzone = column.querySelector('[data-role="dropzone"]');
                let total = 0;
                Array.from(dropzone?.querySelectorAll('.device-chip') ?? []).forEach(card => {
                    const length = Number.parseFloat(card.dataset.totalLength ?? '0');
                    if (!Number.isNaN(length)) {
                        total += length;
                    }
                });
                column.dataset.totalLength = total.toString();
                const capacity = column.querySelector('[data-role="capacity"]');
                if (capacity) {
                    capacity.textContent = `Длина линии: ${total.toFixed(2)} м`;
                }
            });
        }

        function collectGroupLabels() {
            const seen = new Set();
            const labels = [];
            getGroupColumns().forEach(column => {
                const label = (column.dataset.groupLabel || '').trim();
                if (label && !seen.has(label)) {
                    seen.add(label);
                    labels.push(label);
                }
            });
            return labels;
        }

        function setConnectionPointError(input, message) {
            const row = input.closest('.connection-point');
            const errorElement = row?.querySelector('[data-role="error"]');
            if (!row || !errorElement) {
                return;
            }
            if (message) {
                errorElement.textContent = message;
                errorElement.hidden = false;
                input.classList.add('input-error');
            } else {
                errorElement.textContent = '';
                errorElement.hidden = true;
                input.classList.remove('input-error');
            }
        }

        function reindexConnectionPoints() {
            if (!connectionContainer) {
                return;
            }
            const rows = Array.from(connectionContainer.querySelectorAll('.connection-point'));
            rows.forEach((row, index) => {
                const nameInput = row.querySelector('input[data-field="name"]');
                const elementSelect = row.querySelector('select[data-field="mountingElementId"]');
                const distanceInput = row.querySelector('input[data-field="distanceToPower"]');
                const cableSelect = row.querySelector('select[data-field="powerCableTypeId"]');
                const layingInput = row.querySelector('[data-field="layingMethod"]');
                row.dataset.index = index.toString();
                if (nameInput) {
                    nameInput.setAttribute('name', `connectionPoints[${index}].name`);
                    row.dataset.connectionName = nameInput.value.trim();
                }
                if (elementSelect) {
                    elementSelect.setAttribute('name', `connectionPoints[${index}].mountingElementId`);
                }
                if (distanceInput) {
                    distanceInput.setAttribute('name', `connectionPoints[${index}].distanceToPower`);
                }
                if (cableSelect) {
                    cableSelect.setAttribute('name', `connectionPoints[${index}].powerCableTypeId`);
                }
                if (layingInput) {
                    layingInput.setAttribute('name', `connectionPoints[${index}].layingMethod`);
                }
            });
            if (connectionEmptyMessage) {
                connectionEmptyMessage.hidden = rows.length > 0;
            }
        }

        function syncConnectionPointsFromDevices() {
            if (!connectionContainer) {
                return;
            }
            const usageMap = new Map();
            const groups = getDeviceGroups();
            const rowMap = new Map();
            Array.from(connectionContainer.querySelectorAll('.connection-point')).forEach(row => {
                const key = (row.dataset.connectionName || '').trim();
                if (key) {
                    rowMap.set(key, row);
                }
                row.dataset.matched = 'false';
            });
            groups.forEach((group, index) => {
                const connectionInput = group.querySelector('input[data-field="connectionPoint"]');
                const name = connectionInput?.value.trim();
                if (!name) {
                    return;
                }
                if (!usageMap.has(name)) {
                    usageMap.set(name, []);
                }
                usageMap.get(name).push(index);
                let row = rowMap.get(name);
                if (!row) {
                    if (!(connectionTemplate instanceof HTMLTemplateElement)) {
                        return;
                    }
                    row = connectionTemplate.content.firstElementChild.cloneNode(true);
                    connectionContainer.appendChild(row);
                    rowMap.set(name, row);
                }
                row.dataset.matched = 'true';
                row.dataset.connectionName = name;
                const nameInput = row.querySelector('input[data-field="name"]');
                if (nameInput && nameInput.value.trim() !== name) {
                    nameInput.value = name;
                }
            });
            Array.from(connectionContainer.querySelectorAll('.connection-point')).forEach(row => {
                if (row.dataset.matched !== 'true') {
                    row.remove();
                } else {
                    row.removeAttribute('data-matched');
                }
            });
            reindexConnectionPoints();
            updateConnectionPointUsage(usageMap);
        }

        function updateConnectionPointUsage(usageMap) {
            if (!connectionContainer) {
                return;
            }
            Array.from(connectionContainer.querySelectorAll('.connection-point')).forEach(row => {
                const usageElement = row.querySelector('[data-role="usage"]');
                if (!usageElement) {
                    return;
                }
                const name = row.dataset.connectionName || '';
                const indices = usageMap.get(name) || [];
                if (indices.length === 0) {
                    usageElement.textContent = 'Нет привязанных устройств.';
                    return;
                }
                const descriptions = indices.map(index => {
                    const data = getDeviceGroupData(index);
                    if (!data) {
                        return `Устройство №${index + 1}`;
                    }
                    const parts = [];
                    if (data.typeName) {
                        parts.push(data.typeName);
                    } else {
                        parts.push(`Устройство №${index + 1}`);
                    }
                    if (data.count) {
                        parts.push(`${data.count} шт.`);
                    }
                    if (data.installLocation) {
                        parts.push(data.installLocation);
                    }
                    return parts.join(' — ');
                });
                usageElement.textContent = `Устройства: ${descriptions.join('; ')}`;
            });
        }

        function updateDeviceConnectionNames(oldName, newName) {
            if (!deviceContainer || !oldName || oldName === newName) {
                return;
            }
            Array.from(deviceContainer.querySelectorAll('input[data-field="connectionPoint"]')).forEach(input => {
                if (input.value.trim() === oldName) {
                    input.value = newName;
                }
            });
        }

        function syncMaterialGroupsWithLabels() {
            if (!materialGroupsContainer) {
                return;
            }
            const labels = collectGroupLabels();
            const existing = Array.from(materialGroupsContainer.querySelectorAll('.material-group'));
            const groupMap = new Map(existing.map(group => [group.dataset.groupLabel || '', group]));
            const usedGroups = new Set();
            labels.forEach(label => {
                let group = groupMap.get(label);
                if (!group) {
                    if (!(materialGroupTemplate instanceof HTMLTemplateElement)) {
                        return;
                    }
                    group = materialGroupTemplate.content.firstElementChild.cloneNode(true);
                    materialGroupsContainer.appendChild(group);
                }
                group.dataset.groupLabel = label;
                const labelElement = group.querySelector('[data-role="label"]');
                if (labelElement) {
                    labelElement.textContent = label;
                }
                const hiddenInput = group.querySelector('input[data-field="groupLabel"]');
                if (hiddenInput) {
                    hiddenInput.value = label;
                }
                usedGroups.add(group);
            });
            existing.forEach(group => {
                if (!usedGroups.has(group)) {
                    group.remove();
                }
            });
            if (materialsEmptyMessage) {
                materialsEmptyMessage.hidden = labels.length > 0;
            }
            reindexMaterialGroups();
            validateMaterialCapacity();
        }

        function reindexMaterialGroups() {
            if (!materialGroupsContainer) {
                return;
            }
            const groups = Array.from(materialGroupsContainer.querySelectorAll('.material-group'));
            groups.forEach((group, groupIndex) => {
                group.dataset.index = groupIndex.toString();
                const labelInput = group.querySelector('input[data-field="groupLabel"]');
                const nameInput = group.querySelector('input[data-field="groupName"]');
                const surfaceInput = group.querySelector('input[data-field="surface"]');
                if (labelInput) {
                    labelInput.setAttribute('name', `materialGroups[${groupIndex}].groupLabel`);
                    group.dataset.groupLabel = labelInput.value.trim();
                }
                if (nameInput) {
                    nameInput.setAttribute('name', `materialGroups[${groupIndex}].groupName`);
                }
                if (surfaceInput) {
                    surfaceInput.setAttribute('name', `materialGroups[${groupIndex}].surface`);
                }
                const rows = Array.from(group.querySelectorAll('.material-row'));
                rows.forEach((row, rowIndex) => {
                    row.dataset.index = rowIndex.toString();
                    row.querySelectorAll('[data-field]').forEach(field => {
                        const key = field.getAttribute('data-field');
                        if (!key) {
                            return;
                        }
                        let name = '';
                        if (key === 'materialId') {
                            name = `materialGroups[${groupIndex}].materials[${rowIndex}].materialId`;
                        } else if (key === 'amount') {
                            name = `materialGroups[${groupIndex}].materials[${rowIndex}].amount`;
                        } else if (key === 'layingSurface') {
                            name = `materialGroups[${groupIndex}].materials[${rowIndex}].layingSurface`;
                        }
                        if (name) {
                            field.setAttribute('name', name);
                        }
                    });
                    const removeButton = row.querySelector('.remove-material');
                    if (removeButton) {
                        removeButton.style.display = rowIndex === 0 ? 'none' : '';
                    }
                });
            });
        }

        function parseLength(value) {
            if (!value) {
                return Number.NaN;
            }
            const match = value.replace(',', '.').match(/\d+(?:\.\d+)?/);
            return match ? Number.parseFloat(match[0]) : Number.NaN;
        }

        function validateMaterialCapacity() {
            if (!materialGroupsContainer) {
                return;
            }
            const capacities = new Map();
            getGroupColumns().forEach(column => {
                const label = (column.dataset.groupLabel || '').trim();
                if (!label) {
                    return;
                }
                const total = Number.parseFloat(column.dataset.totalLength ?? '0');
                capacities.set(label, Number.isNaN(total) ? 0 : total);
            });
            Array.from(materialGroupsContainer.querySelectorAll('.material-group')).forEach(group => {
                const label = (group.dataset.groupLabel || '').trim();
                const capacity = capacities.get(label) ?? 0;
                let used = 0;
                group.querySelectorAll('input[data-field="amount"]').forEach(input => {
                    const value = parseLength(input.value);
                    if (!Number.isNaN(value)) {
                        used += value;
                    }
                });
                group.dataset.capacity = capacity.toString();
                group.dataset.usedLength = used.toString();
                const warning = group.querySelector('[data-role="capacity-warning"]');
                const over = capacity > 0 && used > capacity + 0.0001;
                group.classList.toggle('over-capacity', over);
                if (warning) {
                    warning.hidden = !over;
                    if (over) {
                        warning.textContent = `Запланировано ${used.toFixed(2)} м при доступных ${capacity.toFixed(2)} м.`;
                    }
                }
            });
        }

        addDeviceButton?.addEventListener('click', () => {
            if (!(deviceTemplate instanceof HTMLTemplateElement) || !deviceContainer) {
                return;
            }
            const clone = deviceTemplate.content.firstElementChild.cloneNode(true);
            deviceContainer.appendChild(clone);
            reindexDeviceGroups();
        });

        deviceContainer?.addEventListener('input', event => {
            const target = event.target;
            if (!(target instanceof HTMLInputElement)) {
                return;
            }
            const field = target.getAttribute('data-field');
            if (field === 'deviceCount') {
                updateTotalConnectionPoints();
                updateDeviceSummaries();
                updateGroupCapacities();
                validateMaterialCapacity();
            }
            if (field === 'connectionPoint') {
                updateTotalConnectionPoints();
                syncConnectionPointsFromDevices();
                updateDeviceSummaries();
                updateGroupCapacities();
                validateMaterialCapacity();
            } else if (field === 'installLocation' || field === 'distanceToConnectionPoint') {
                updateDeviceSummaries();
                updateGroupCapacities();
                validateMaterialCapacity();
            }
        });

        deviceContainer?.addEventListener('change', event => {
            const target = event.target;
            if (target instanceof HTMLSelectElement && target.getAttribute('data-field') === 'deviceTypeId') {
                updateDeviceSummaries();
                updateGroupCapacities();
                validateMaterialCapacity();
            }
        });

        deviceContainer?.addEventListener('click', event => {
            const target = event.target;
            if (!(target instanceof HTMLElement)) {
                return;
            }
            if (target.classList.contains('remove-device')) {
                const group = target.closest('.device-group');
                if (group && deviceContainer.children.length > 1) {
                    group.remove();
                    reindexDeviceGroups();
                }
            }
        });

        connectionContainer?.addEventListener('focusin', event => {
            const target = event.target;
            if (target instanceof HTMLInputElement && target.getAttribute('data-field') === 'name') {
                target.dataset.originalValue = target.value.trim();
            }
        });

        connectionContainer?.addEventListener('focusout', event => {
            const target = event.target;
            if (!(target instanceof HTMLInputElement) || target.getAttribute('data-field') !== 'name') {
                return;
            }
            const row = target.closest('.connection-point');
            if (!row) {
                return;
            }
            const oldValue = target.dataset.originalValue || row.dataset.connectionName || '';
            const newValue = target.value.trim();
            if (!newValue) {
                setConnectionPointError(target, 'Введите название точки подключения');
                target.value = oldValue;
                return;
            }
            const duplicate = Array.from(connectionContainer.querySelectorAll('.connection-point')).some(other => {
                if (other === row) {
                    return false;
                }
                const otherInput = other.querySelector('input[data-field="name"]');
                const otherName = other.dataset.connectionName || otherInput?.value.trim() || '';
                return otherName === newValue;
            });
            if (duplicate) {
                setConnectionPointError(target, 'Название должно быть уникальным');
                target.value = oldValue;
                return;
            }
            setConnectionPointError(target, null);
            row.dataset.connectionName = newValue;
            updateDeviceConnectionNames(oldValue, newValue);
            syncConnectionPointsFromDevices();
            updateDeviceSummaries();
            updateGroupCapacities();
            validateMaterialCapacity();
        });

        addGroupButton?.addEventListener('click', () => {
            const labels = collectGroupLabels();
            let counter = labels.length + 1;
            let proposed = `Группа ${counter}`;
            while (labels.includes(proposed)) {
                counter += 1;
                proposed = `Группа ${counter}`;
            }
            const column = ensureGroupColumn(proposed);
            if (column) {
                const input = column.querySelector('.group-name-input');
                if (input) {
                    input.value = proposed;
                    input.focus();
                    input.select();
                }
                column.dataset.groupLabel = proposed;
            }
            updateGroupingEmptyState();
            syncMaterialGroupsWithLabels();
        });

        groupingPool?.addEventListener('dragover', event => {
            event.preventDefault();
            groupingPool.classList.add('drop-target');
        });

        groupingPool?.addEventListener('dragleave', () => {
            groupingPool.classList.remove('drop-target');
        });

        groupingPool?.addEventListener('drop', event => {
            event.preventDefault();
            groupingPool.classList.remove('drop-target');
            const index = Number(event.dataTransfer?.getData('text/plain'));
            moveCardToGroupByIndex(index, '');
        });

        materialGroupsContainer?.addEventListener('click', event => {
            const target = event.target;
            if (!(target instanceof HTMLElement)) {
                return;
            }
            if (target.classList.contains('add-material')) {
                event.preventDefault();
                const group = target.closest('.material-group');
                const rowsContainer = group?.querySelector('.materials-container');
                if (!group || !rowsContainer || !(materialRowTemplate instanceof HTMLTemplateElement)) {
                    return;
                }
                const clone = materialRowTemplate.content.firstElementChild.cloneNode(true);
                rowsContainer.appendChild(clone);
                reindexMaterialGroups();
                validateMaterialCapacity();
                return;
            }
            if (target.classList.contains('remove-material')) {
                const row = target.closest('.material-row');
                const group = target.closest('.material-group');
                if (!row || !group) {
                    return;
                }
                const rows = group.querySelectorAll('.material-row');
                if (rows.length > 1) {
                    row.remove();
                    reindexMaterialGroups();
                    validateMaterialCapacity();
                }
            }
        });

        materialGroupsContainer?.addEventListener('input', event => {
            const target = event.target;
            if (target instanceof HTMLInputElement && target.getAttribute('data-field') === 'amount') {
                validateMaterialCapacity();
            }
        });

        function sanitizeFieldNames() {
            reindexDeviceGroups();
            reindexMountingRows();
            reindexConnectionPoints();
            reindexMaterialGroups();
            if (!wizardForm) {
                return;
            }
            wizardForm.querySelectorAll('[name*="__index__"]').forEach(field => {
                const key = field.getAttribute('data-field');
                if (!key) {
                    field.removeAttribute('name');
                    return;
                }
                const deviceGroup = field.closest('.device-group');
                if (deviceGroup && deviceGroup.dataset.index) {
                    field.setAttribute('name', `deviceGroups[${deviceGroup.dataset.index}].${key}`);
                    return;
                }
                const connectionPoint = field.closest('.connection-point');
                if (connectionPoint && connectionPoint.dataset.index) {
                    field.setAttribute('name', `connectionPoints[${connectionPoint.dataset.index}].${key}`);
                    return;
                }
                const materialGroup = field.closest('.material-group');
                if (materialGroup && materialGroup.dataset.index) {
                    const materialRow = field.closest('.material-row');
                    if (materialRow && materialRow.dataset.index) {
                        field.setAttribute('name', `materialGroups[${materialGroup.dataset.index}].materials[${materialRow.dataset.index}].${key}`);
                    } else {
                        field.setAttribute('name', `materialGroups[${materialGroup.dataset.index}].${key}`);
                    }
                    return;
                }
                const mountingRow = field.closest('.mounting-row');
                if (mountingRow && mountingRow.dataset.index) {
                    field.setAttribute('name', `mountingElements[${mountingRow.dataset.index}].${key}`);
                    return;
                }
                field.removeAttribute('name');
            });
        }

        wizardForm?.addEventListener('submit', () => {
            sanitizeFieldNames();
        });

        reindexMountingRows();
        reindexDeviceGroups();
        showStep(0);
    });
</script>
</body>
</html>
