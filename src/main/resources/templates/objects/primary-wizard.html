<!DOCTYPE html>
<html lang="ru" xmlns:th="http://www.thymeleaf.org" xmlns:sec="http://www.thymeleaf.org/extras/spring-security">
<head>
    <meta charset="UTF-8">
    <title>Первичные данные объекта</title>
    <link rel="stylesheet" href="/css/main.css">
</head>
<body>
<header class="topbar">
    <h1>Object Manager</h1>
    <nav>
        <a href="/objects" class="active">Объекты</a>
        <a href="/customers">Заказчики</a>
        <a href="/admin" sec:authorize="hasRole('ADMIN')">Администрирование</a>
        <form method="post" action="/logout">
            <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}">
            <button type="submit" class="link-button">Выход</button>
        </form>
    </nav>
</header>
<main class="content">
    <section class="card">
        <div class="card-header">
            <h2 th:text="${object.name}">Объект</h2>
            <a class="button secondary" th:href="@{'/objects/' + ${object.id}}">Назад к объекту</a>
        </div>
        <p class="muted">Заполняйте первичные данные по шагам: сначала оборудование, затем точки подключения, после чего сгруппируйте устройства и задайте монтажные материалы.</p>
    </section>

    <form class="card wizard-form" method="post" th:action="@{'/objects/' + ${object.id} + '/primary-data/wizard'}" th:object="${wizardForm}" th:attr="data-initial-step=${wizardActiveStep}">
        <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}">
        <nav class="wizard-progress">
            <button type="button" class="wizard-progress-step active" data-step-index="0">1. Оборудование</button>
            <button type="button" class="wizard-progress-step" data-step-index="1">2. Точки подключения</button>
            <button type="button" class="wizard-progress-step" data-step-index="2">3. Группы устройств</button>
            <button type="button" class="wizard-progress-step" data-step-index="3">4. Материалы</button>
        </nav>

        <div class="alert" th:if="${#fields.hasGlobalErrors()}">
            <p th:each="error : ${#fields.globalErrors()}" th:text="${error.defaultMessage}"></p>
        </div>

        <div class="wizard-panels">
            <section class="wizard-step" data-step-index="0">
                <h3>Шаг 1. Оборудование</h3>
                <p class="muted">Укажите тип устройства, количество, место установки, точку подключения и расстояние до неё. Эти данные определяют дальнейшие шаги.</p>
                <div id="device-groups" class="stack">
                    <div class="device-group card nested-card" th:each="group, iter : *{deviceGroups}" th:data-index="${iter.index}">
                        <div class="grid">
                            <div>
                                <label>Тип устройства</label>
                                <select th:field="*{deviceGroups[__${iter.index}__].deviceTypeId}" data-field="deviceTypeId">
                                    <option value="">Не выбрано</option>
                                    <option th:each="type : ${deviceTypes}"
                                            th:value="${type.id}"
                                            th:text="${type.name}"
                                            th:attr="data-required-cables=${deviceTypeRequirements[type.id]} != null ? deviceTypeRequirements[type.id] : ''"
                                            th:data-camera="${cameraDeviceFlags[type.id]} ? 'true' : 'false'"></option>
                                </select>
                            </div>
                            <div>
                                <label>Количество</label>
                                <input type="number" min="0" step="1" class="device-count" th:field="*{deviceGroups[__${iter.index}__].deviceCount}" data-field="deviceCount">
                            </div>
                            <div>
                                <label>Расстояние до точки подключения (м)</label>
                                <input type="number" min="0" step="0.1" th:field="*{deviceGroups[__${iter.index}__].distanceToConnectionPoint}" data-field="distanceToConnectionPoint" placeholder="Например, 12">
                            </div>
                        </div>
                        <div class="grid">
                            <div>
                                <label>Точка установки</label>
                                <input type="text" th:field="*{deviceGroups[__${iter.index}__].installLocation}" data-field="installLocation" placeholder="Крыша, подъезд...">
                            </div>
                            <div>
                                <label>Точка подключения</label>
                                <input type="text" th:field="*{deviceGroups[__${iter.index}__].connectionPoint}" data-field="connectionPoint" placeholder="Распред. коробка...">
                            </div>
                            <div>
                                <label>Поверхность установки</label>
                                <select th:field="*{deviceGroups[__${iter.index}__].installSurfaceCategory}" data-field="installSurfaceCategory">
                                    <option value="">Не выбрана</option>
                                    <option th:each="surface : ${surfaceTypes}" th:value="${surface.code}" th:text="${surface.displayName}"></option>
                                </select>
                            </div>
                        </div>
                        <div class="grid camera-settings" data-role="camera-fields"
                             th:classappend="${!(group.deviceTypeId != null and cameraDeviceFlags[group.deviceTypeId])
                                                and !#strings.hasText(group.cameraAccessory)
                                                and group.cameraViewingDepth == null} ? ' is-hidden' : ''">
                            <div>
                                <label>Комплектация камеры (адаптер или пластиковая коробка)</label>
                                <select th:field="*{deviceGroups[__${iter.index}__].cameraAccessory}"
                                        data-field="cameraAccessory"
                                        th:disabled="${!(group.deviceTypeId != null and cameraDeviceFlags[group.deviceTypeId])}">
                                    <option value="">Не выбрана</option>
                                    <option th:each="option : ${cameraOptions}" th:value="${option.code}" th:text="${option.displayName}"></option>
                                </select>
                                <p class="field-error"
                                   th:if="${#fields.hasErrors('deviceGroups[' + iter.index + '].cameraAccessory')}"
                                   th:errors="*{deviceGroups[__${iter.index}__].cameraAccessory}"></p>
                            </div>
                            <div>
                                <label>Глубина просмотра (м)</label>
                                <input type="number" min="0" step="0.1"
                                       th:field="*{deviceGroups[__${iter.index}__].cameraViewingDepth}"
                                       data-field="cameraViewingDepth"
                                       th:disabled="${!(group.deviceTypeId != null and cameraDeviceFlags[group.deviceTypeId])}"
                                       placeholder="Например, 40">
                                <p class="field-error"
                                   th:if="${#fields.hasErrors('deviceGroups[' + iter.index + '].cameraViewingDepth')}"
                                   th:errors="*{deviceGroups[__${iter.index}__].cameraViewingDepth}"></p>
                            </div>
                        </div>
                        <div class="grid cable-settings" data-role="cable-fields">
                            <div class="cable-field" data-cable-function="SIGNAL">
                                <label th:attr="data-default-label=${cableFunctionLabels[signalCableFunction]}"
                                       th:text="${cableFunctionLabels[signalCableFunction]}">Сигнальный кабель</label>
                                <select th:field="*{deviceGroups[__${iter.index}__].signalCableTypeId}" data-field="signalCableTypeId">
                                    <option value="">Не выбран</option>
                                    <option th:each="cable : ${cableTypes}"
                                            th:if="${cable.function == signalCableFunction}"
                                            th:value="${cable.id}"
                                            th:text="${cable.name}"></option>
                                </select>
                                <p class="field-error"
                                   th:if="${#fields.hasErrors('deviceGroups[' + iter.index + '].signalCableTypeId')}"
                                    th:errors="*{deviceGroups[__${iter.index}__].signalCableTypeId}"></p>
                            </div>
                            <div class="cable-field" data-cable-function="LOW_VOLTAGE_POWER">
                                <label th:text="${cableFunctionLabels[lowVoltageCableFunction]}">Кабель для слаботочного питания</label>
                                <select th:field="*{deviceGroups[__${iter.index}__].lowVoltageCableTypeId}" data-field="lowVoltageCableTypeId">
                                    <option value="">Не выбран</option>
                                    <option th:each="cable : ${cableTypes}"
                                            th:if="${cable.function == lowVoltageCableFunction}"
                                            th:value="${cable.id}"
                                            th:text="${cable.name}"></option>
                                </select>
                                <p class="field-error"
                                   th:if="${#fields.hasErrors('deviceGroups[' + iter.index + '].lowVoltageCableTypeId')}"
                                   th:errors="*{deviceGroups[__${iter.index}__].lowVoltageCableTypeId}"></p>
                            </div>
                        </div>
                        <button type="button" class="link-button danger remove-device" th:if="${iter.index > 0}">Удалить</button>
                    </div>
                </div>
                <template id="device-group-template">
                    <div class="device-group card nested-card">
                        <div class="grid">
                            <div>
                                <label>Тип устройства</label>
                                <select data-field="deviceTypeId">
                                    <option value="">Не выбрано</option>
                                    <option th:each="type : ${deviceTypes}"
                                            th:value="${type.id}"
                                            th:text="${type.name}"
                                            th:attr="data-required-cables=${deviceTypeRequirements[type.id]} != null ? deviceTypeRequirements[type.id] : ''"
                                            th:data-camera="${cameraDeviceFlags[type.id]} ? 'true' : 'false'"></option>
                                </select>
                            </div>
                            <div>
                                <label>Количество</label>
                                <input type="number" min="0" step="1" class="device-count" data-field="deviceCount">
                            </div>
                            <div>
                                <label>Расстояние до точки подключения (м)</label>
                                <input type="number" min="0" step="0.1" data-field="distanceToConnectionPoint" placeholder="Например, 12">
                            </div>
                        </div>
                        <div class="grid">
                            <div>
                                <label>Точка установки</label>
                                <input type="text" data-field="installLocation" placeholder="Крыша, подъезд...">
                            </div>
                            <div>
                                <label>Точка подключения</label>
                                <input type="text" data-field="connectionPoint" placeholder="Распред. коробка...">
                            </div>
                            <div>
                                <label>Поверхность установки</label>
                                <select data-field="installSurfaceCategory">
                                    <option value="">Не выбрана</option>
                                    <option th:each="surface : ${surfaceTypes}" th:value="${surface.code}" th:text="${surface.displayName}"></option>
                                </select>
                            </div>
                        </div>
                        <div class="grid camera-settings is-hidden" data-role="camera-fields">
                            <div>
                                <label>Комплектация камеры (адаптер или пластиковая коробка)</label>
                                <select data-field="cameraAccessory">
                                    <option value="">Не выбрана</option>
                                    <option th:each="option : ${cameraOptions}" th:value="${option.code}" th:text="${option.displayName}"></option>
                                </select>
                            </div>
                            <div>
                                <label>Глубина просмотра (м)</label>
                                <input type="number" min="0" step="0.1" data-field="cameraViewingDepth" placeholder="Например, 40">
                            </div>
                        </div>
                        <div class="grid cable-settings is-hidden" data-role="cable-fields">
                            <div class="cable-field" data-cable-function="SIGNAL">
                                <label th:attr="data-default-label=${cableFunctionLabels[signalCableFunction]}"
                                       th:text="${cableFunctionLabels[signalCableFunction]}">Сигнальный кабель</label>
                                <select data-field="signalCableTypeId">
                                    <option value="">Не выбран</option>
                                    <option th:each="cable : ${cableTypes}"
                                            th:if="${cable.function == signalCableFunction}"
                                            th:value="${cable.id}"
                                            th:text="${cable.name}"></option>
                                </select>
                            </div>
                            <div class="cable-field" data-cable-function="LOW_VOLTAGE_POWER">
                                <label th:text="${cableFunctionLabels[lowVoltageCableFunction]}">Кабель для слаботочного питания</label>
                                <select data-field="lowVoltageCableTypeId">
                                    <option value="">Не выбран</option>
                                    <option th:each="cable : ${cableTypes}"
                                            th:if="${cable.function == lowVoltageCableFunction}"
                                            th:value="${cable.id}"
                                            th:text="${cable.name}"></option>
                                </select>
                            </div>
                        </div>
                        <button type="button" class="link-button danger remove-device">Удалить</button>
                    </div>
                </template>
                <button type="button" class="button secondary" id="add-device-group">Добавить устройство</button>
                <p><strong>Всего точек подключения:</strong> <span id="connection-total" th:text="${totalConnectionPoints}">0</span></p>
            </section>

            <section class="wizard-step" data-step-index="1" hidden>
                <h3>Шаг 2. Точки подключения</h3>
                <p class="muted">Точки формируются автоматически на основании предыдущего шага. Названия должны быть уникальными, чтобы к одной точке можно было подключить несколько устройств.</p>
                <p class="muted" id="connection-empty" th:if="${#lists.isEmpty(wizardForm.connectionPoints)}">Добавьте устройства и укажите для них точки подключения на первом шаге.</p>
                <div id="connection-points" class="stack">
                    <div class="connection-point card nested-card" th:each="point, iter : *{connectionPoints}" th:data-connection-name="${point.name != null ? point.name : ''}">
                        <div class="grid">
                            <div>
                                <label>Название точки</label>
                                <input type="text" th:field="*{connectionPoints[__${iter.index}__].name}" data-field="name" placeholder="Распред. коробка №1">
                                <p class="field-error" data-role="error" hidden>Название должно быть уникальным</p>
                            </div>
                            <div>
                                <label>Монтажный короб / ящик</label>
                                <select th:field="*{connectionPoints[__${iter.index}__].mountingElementId}" data-field="mountingElementId">
                                    <option value="">Не выбран</option>
                                    <option th:each="element : ${mountingElements}" th:value="${element.id}" th:text="${element.name}"></option>
                                </select>
                            </div>
                        </div>
                        <div class="grid">
                            <div>
                                <label>Расстояние до точки запитки (м)</label>
                                <input type="number" min="0" step="0.1" th:field="*{connectionPoints[__${iter.index}__].distanceToPower}" data-field="distanceToPower" placeholder="Например, 5">
                            </div>
                            <div>
                                <label>Тип силового кабеля</label>
                                <select th:field="*{connectionPoints[__${iter.index}__].powerCableTypeId}" data-field="powerCableTypeId">
                                    <option value="">Не выбран</option>
                                    <option th:each="cable : ${cableTypes}"
                                            th:if="${cable.function == powerCableFunction}"
                                            th:value="${cable.id}"
                                            th:text="${cable.name}"></option>
                                </select>
                            </div>
                        </div>
                        <div class="grid">
                            <div>
                                <label>Материал прокладки</label>
                                <select th:field="*{connectionPoints[__${iter.index}__].layingMaterialId}" data-field="layingMaterialId">
                                    <option value="">Не выбран</option>
                                    <option th:each="material : ${installationMaterials}" th:value="${material.id}" th:text="${material.name}"></option>
                                </select>
                            </div>
                            <div>
                                <label>Категория поверхности</label>
                                <select th:field="*{connectionPoints[__${iter.index}__].layingSurfaceCategory}" data-field="layingSurfaceCategory">
                                    <option value="">Не выбрана</option>
                                    <option th:each="surface : ${surfaceTypes}" th:value="${surface.code}" th:text="${surface.displayName}"></option>
                                </select>
                            </div>
                            <div>
                                <label>Доп. описание поверхности</label>
                                <input type="text" th:field="*{connectionPoints[__${iter.index}__].layingSurface}" data-field="layingSurface" placeholder="По стене, в коробе...">
                            </div>
                        </div>
                        <p class="connection-usage" data-role="usage">Устройства будут отображены после заполнения первого шага.</p>
                    </div>
                </div>
                <template id="connection-point-template">
                    <div class="connection-point card nested-card">
                        <div class="grid">
                            <div>
                                <label>Название точки</label>
                                <input type="text" data-field="name" placeholder="Распред. коробка №1">
                                <p class="field-error" data-role="error" hidden>Название должно быть уникальным</p>
                            </div>
                            <div>
                                <label>Монтажный короб / ящик</label>
                                <select data-field="mountingElementId">
                                    <option value="">Не выбран</option>
                                    <option th:each="element : ${mountingElements}" th:value="${element.id}" th:text="${element.name}"></option>
                                </select>
                            </div>
                        </div>
                        <div class="grid">
                            <div>
                                <label>Расстояние до точки запитки (м)</label>
                                <input type="number" min="0" step="0.1" data-field="distanceToPower" placeholder="Например, 5">
                            </div>
                            <div>
                                <label>Тип силового кабеля</label>
                                <select data-field="powerCableTypeId">
                                    <option value="">Не выбран</option>
                                    <option th:each="cable : ${cableTypes}"
                                            th:if="${cable.function == powerCableFunction}"
                                            th:value="${cable.id}"
                                            th:text="${cable.name}"></option>
                                </select>
                            </div>
                        </div>
                        <div class="grid">
                            <div>
                                <label>Материал прокладки</label>
                                <select data-field="layingMaterialId">
                                    <option value="">Не выбран</option>
                                    <option th:each="material : ${installationMaterials}" th:value="${material.id}" th:text="${material.name}"></option>
                                </select>
                            </div>
                            <div>
                                <label>Категория поверхности</label>
                                <select data-field="layingSurfaceCategory">
                                    <option value="">Не выбрана</option>
                                    <option th:each="surface : ${surfaceTypes}" th:value="${surface.code}" th:text="${surface.displayName}"></option>
                                </select>
                            </div>
                            <div>
                                <label>Доп. описание поверхности</label>
                                <input type="text" data-field="layingSurface" placeholder="По стене, в коробе...">
                            </div>
                        </div>
                        <p class="connection-usage" data-role="usage">Устройства будут отображены после заполнения первого шага.</p>
                    </div>
                </template>
            </section>

            <section class="wizard-step" data-step-index="2" hidden>
                <h3>Шаг 3. Группы устройств</h3>
                <p class="muted">Объедините камеры и другие устройства в логические группы. Эти группы будут использоваться для выбора монтажных материалов.</p>
                <div class="grouping-board">
                    <section class="grouping-source">
                        <h4>Устройства</h4>
                        <p class="muted small">Перетащите устройство в нужную группу.</p>
                        <div id="grouping-pool" class="grouping-pool">
                            <div class="device-chip" th:each="group, iter : *{deviceGroups}" th:data-index="${iter.index}" draggable="true">
                                <input type="hidden" th:field="*{deviceGroups[__${iter.index}__].groupLabel}" data-field="groupLabel">
                                <p class="muted small" data-role="summary">Заполните информацию на первом шаге, чтобы увидеть сводку.</p>
                                <p class="muted small" data-role="assignment">Группа: <span data-role="assignment-label">не задана</span></p>
                            </div>
                        </div>
                    </section>
                    <section class="grouping-destinations">
                        <div class="grouping-controls">
                            <button type="button" class="button secondary" id="add-group">Создать группу</button>
                        </div>
                        <p class="field-error" id="grouping-warning" hidden></p>
                        <p class="muted small" id="grouping-empty">Создайте группу и перетащите в неё устройства.</p>
                        <div id="grouping-columns" class="grouping-columns"></div>
                    </section>
                </div>
                <template id="group-column-template">
                    <div class="group-column card nested-card" data-group-label="">
                        <header class="group-header">
                            <input type="text" class="group-name-input" placeholder="Новая группа">
                            <button type="button" class="link-button danger remove-group">Удалить</button>
                        </header>
                        <p class="muted small" data-role="capacity">Длина линии: 0 м</p>
                        <p class="muted small" data-role="connection-hint">Узел: не выбран</p>
                        <div class="group-dropzone" data-role="dropzone"></div>
                    </div>
                </template>
                <template id="device-chip-template">
                    <div class="device-chip" draggable="true">
                        <input type="hidden" data-field="groupLabel">
                        <p class="muted small" data-role="summary">Заполните информацию на первом шаге, чтобы увидеть сводку.</p>
                        <p class="muted small" data-role="assignment">Группа: <span data-role="assignment-label">не задана</span></p>
                    </div>
                </template>
            </section>

            <section class="wizard-step" data-step-index="3" hidden>
                <h3>Шаг 4. Монтажные материалы</h3>
                <p class="muted">Для каждой созданной группы укажите необходимые материалы. Если группа не требует материалов, оставьте поля пустыми.</p>
                <div class="card nested-card">
                    <h4>Монтажные элементы</h4>
                    <p class="muted small">Монтажные коробки, назначенные на шаге «Точки подключения», отображаются автоматически. Добавьте материалы или дополнительные коробки при необходимости.</p>
                    <div class="stack" id="mounting-list">
                        <div class="mounting-row" th:each="element, iter : *{mountingElements}" th:data-index="${iter.index}" th:classappend="${element.autoAssigned} ? ' is-locked' : ''">
                            <input type="hidden" th:field="*{mountingElements[__${iter.index}__].elementName}" data-field="elementName">
                            <div class="grid mounting-row-header">
                                <div>
                                    <label>Монтажный короб / ящик</label>
                                    <div class="mounting-element-display" th:if="${element.autoAssigned}">
                                        <input type="hidden" th:field="*{mountingElements[__${iter.index}__].elementId}" data-field="elementId">
                                        <p class="muted" data-role="element-name" th:text="${#strings.hasText(element.elementName) ? element.elementName : 'Не выбран'}">Не выбран</p>
                                        <p class="muted small">Назначен на шаге точек подключения.</p>
                                    </div>
                                    <select th:unless="${element.autoAssigned}" th:field="*{mountingElements[__${iter.index}__].elementId}" data-field="elementId">
                                        <option value="">Не выбран</option>
                                        <option th:each="option : ${availableMountingElements}" th:value="${option.id}" th:text="${option.name}"></option>
                                    </select>
                                </div>
                                <div>
                                    <label>Количество / примечание</label>
                                    <input type="text" th:field="*{mountingElements[__${iter.index}__].quantity}" data-field="quantity" placeholder="2 шт, 1 комплект...">
                                </div>
                            </div>
                            <div class="stack mounting-materials" data-role="materials">
                                <div class="mounting-material-row" th:each="material, mIndex : *{mountingElements[__${iter.index}__].materials}" th:data-index="${mIndex.index}">
                                    <div class="grid">
                                        <div>
                                            <label>Материал</label>
                                            <select th:field="*{mountingElements[__${iter.index}__].materials[__${mIndex.index}__].materialId}" data-field="materialId">
                                                <option value="">Не выбран</option>
                                                <option th:each="materialOption : ${installationMaterials}" th:value="${materialOption.id}" th:text="${materialOption.name}"></option>
                                            </select>
                                        </div>
                                        <div>
                                            <label>Количество / примечание</label>
                                            <input type="text" th:field="*{mountingElements[__${iter.index}__].materials[__${mIndex.index}__].amount}" data-field="amount" placeholder="1 комплект, 20 м...">
                                        </div>
                                    </div>
                                    <button type="button" class="link-button danger remove-mounting-material" th:if="${mIndex.index > 0}">Удалить материал</button>
                                </div>
                            </div>
                            <button type="button" class="button tertiary" data-action="add-mounting-material">Добавить материал</button>
                            <button type="button" class="link-button danger remove-mounting" th:if="${!element.autoAssigned && iter.index > 0}">Удалить</button>
                        </div>
                    </div>
                    <button type="button" class="button secondary" id="add-mounting-element">Добавить монтажный элемент</button>
                </div>
                <template id="mounting-row-template">
                    <div class="mounting-row">
                        <input type="hidden" data-field="elementName">
                        <div class="grid mounting-row-header">
                            <div>
                                <label>Монтажный короб / ящик</label>
                                <select data-field="elementId">
                                    <option value="">Не выбран</option>
                                    <option th:each="option : ${availableMountingElements}" th:value="${option.id}" th:text="${option.name}"></option>
                                </select>
                            </div>
                            <div>
                                <label>Количество / примечание</label>
                                <input type="text" data-field="quantity" placeholder="2 шт, 1 комплект...">
                            </div>
                        </div>
                        <div class="stack mounting-materials" data-role="materials">
                            <div class="mounting-material-row">
                                <div class="grid">
                                    <div>
                                        <label>Материал</label>
                                        <select data-field="materialId">
                                            <option value="">Не выбран</option>
                                            <option th:each="materialOption : ${installationMaterials}" th:value="${materialOption.id}" th:text="${materialOption.name}"></option>
                                        </select>
                                    </div>
                                    <div>
                                        <label>Количество / примечание</label>
                                        <input type="text" data-field="amount" placeholder="1 комплект, 20 м...">
                                    </div>
                                </div>
                                <button type="button" class="link-button danger remove-mounting-material">Удалить материал</button>
                            </div>
                        </div>
                        <button type="button" class="button tertiary" data-action="add-mounting-material">Добавить материал</button>
                        <button type="button" class="link-button danger remove-mounting">Удалить</button>
                    </div>
                </template>
                <template id="mounting-material-template">
                    <div class="mounting-material-row">
                        <div class="grid">
                            <div>
                                <label>Материал</label>
                                <select data-field="materialId">
                                    <option value="">Не выбран</option>
                                    <option th:each="materialOption : ${installationMaterials}" th:value="${materialOption.id}" th:text="${materialOption.name}"></option>
                                </select>
                            </div>
                            <div>
                                <label>Количество / примечание</label>
                                <input type="text" data-field="amount" placeholder="1 комплект, 20 м...">
                            </div>
                        </div>
                        <button type="button" class="link-button danger remove-mounting-material">Удалить материал</button>
                    </div>
                </template>
                <p class="muted" id="materials-empty" th:if="${#lists.isEmpty(wizardForm.materialGroups)}">Создайте хотя бы одну группу устройств на предыдущем шаге, чтобы назначить материалы.</p>
                <div id="material-groups" class="stack">
                    <div class="material-group card nested-card" th:each="group, gIndex : *{materialGroups}" th:data-group-label="${group.groupLabel != null ? group.groupLabel : ''}">
                        <input type="hidden" th:field="*{materialGroups[__${gIndex.index}__].groupLabel}" data-field="groupLabel">
                        <header class="group-header">
                            <h4 class="group-label">Группа: <span data-role="label" th:text="${group.groupLabel}">Без названия</span></h4>
                        </header>
                        <p class="field-error capacity-warning" data-role="capacity-warning" hidden>Длина материалов превышает допустимую для этой группы.</p>
                        <div class="stack materials-container" th:id="${'material-rows-' + gIndex.index}">
                            <div class="material-row" th:each="usage, uIndex : *{materialGroups[__${gIndex.index}__].materials}" th:data-index="${uIndex.index}">
                                <div class="grid">
                                    <div>
                                        <label>Материал</label>
                                        <select th:field="*{materialGroups[__${gIndex.index}__].materials[__${uIndex.index}__].materialId}" data-field="materialId">
                                            <option value="">Не выбран</option>
                                            <option th:each="material : ${installationMaterials}" th:value="${material.id}" th:text="${material.name}"></option>
                                        </select>
                                    </div>
                                    <div>
                                        <label>Объем / длина</label>
                                        <input type="text" th:field="*{materialGroups[__${gIndex.index}__].materials[__${uIndex.index}__].amount}" data-field="amount" placeholder="25 м, 4 шт...">
                                    </div>
                                    <div>
                                        <label>Категория прокладки</label>
                                        <select th:field="*{materialGroups[__${gIndex.index}__].materials[__${uIndex.index}__].layingSurfaceCategory}" data-field="layingSurfaceCategory">
                                            <option value="">Не выбрана</option>
                                            <option th:each="surface : ${surfaceTypes}" th:value="${surface.code}" th:text="${surface.displayName}"></option>
                                        </select>
                                    </div>
                                    <div>
                                        <label>Доп. описание прокладки</label>
                                        <input type="text" th:field="*{materialGroups[__${gIndex.index}__].materials[__${uIndex.index}__].layingSurface}" data-field="layingSurface" placeholder="По стене, в коробе...">
                                    </div>
                                </div>
                                <button type="button" class="link-button danger remove-material" th:if="${uIndex.index > 0}">Удалить материал</button>
                            </div>
                        </div>
                        <button type="button" class="button secondary add-material">Добавить материал</button>
                    </div>
                </div>
                <template id="material-group-template">
                    <div class="material-group card nested-card">
                        <input type="hidden" data-field="groupLabel">
                        <header class="group-header">
                            <h4 class="group-label">Группа: <span data-role="label">Без названия</span></h4>
                        </header>
                        <p class="field-error capacity-warning" data-role="capacity-warning" hidden>Длина материалов превышает допустимую для этой группы.</p>
                        <div class="stack materials-container">
                            <div class="material-row">
                                <div class="grid">
                                    <div>
                                        <label>Материал</label>
                                        <select data-field="materialId">
                                            <option value="">Не выбран</option>
                                            <option th:each="material : ${installationMaterials}" th:value="${material.id}" th:text="${material.name}"></option>
                                        </select>
                                    </div>
                                    <div>
                                        <label>Объем / длина</label>
                                        <input type="text" data-field="amount" placeholder="25 м, 4 шт...">
                                    </div>
                                    <div>
                                        <label>Категория прокладки</label>
                                        <select data-field="layingSurfaceCategory">
                                            <option value="">Не выбрана</option>
                                            <option th:each="surface : ${surfaceTypes}" th:value="${surface.code}" th:text="${surface.displayName}"></option>
                                        </select>
                                    </div>
                                    <div>
                                        <label>Доп. описание прокладки</label>
                                        <input type="text" data-field="layingSurface" placeholder="По стене, в коробе...">
                                    </div>
                                </div>
                                <button type="button" class="link-button danger remove-material">Удалить материал</button>
                            </div>
                        </div>
                        <button type="button" class="button secondary add-material">Добавить материал</button>
                    </div>
                </template>
                <template id="material-row-template">
                    <div class="material-row">
                        <div class="grid">
                            <div>
                                <label>Материал</label>
                                <select data-field="materialId">
                                    <option value="">Не выбран</option>
                                    <option th:each="material : ${installationMaterials}" th:value="${material.id}" th:text="${material.name}"></option>
                                </select>
                            </div>
                            <div>
                                <label>Объем / длина</label>
                                <input type="text" data-field="amount" placeholder="25 м, 4 шт...">
                            </div>
                            <div>
                                <label>Категория прокладки</label>
                                <select data-field="layingSurfaceCategory">
                                    <option value="">Не выбрана</option>
                                    <option th:each="surface : ${surfaceTypes}" th:value="${surface.code}" th:text="${surface.displayName}"></option>
                                </select>
                            </div>
                            <div>
                                <label>Доп. описание прокладки</label>
                                <input type="text" data-field="layingSurface" placeholder="По стене, в коробе...">
                            </div>
                        </div>
                        <button type="button" class="link-button danger remove-material">Удалить материал</button>
                    </div>
                </template>
            </section>
        </div>

        <div class="form-row wizard-controls">
            <button type="button" class="button secondary" data-action="prev-step">Назад</button>
            <button type="button" class="button primary" data-action="next-step">Далее</button>
            <button type="submit" class="button" data-role="finish" hidden>Сохранить первичные данные</button>
            <a class="button secondary" th:href="@{'/objects/' + ${object.id}}">Отмена</a>
        </div>
    </form>
</main>
<footer class="footer">
    <p>Object Manager &copy; 2025</p>
</footer>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        const deviceContainer = document.getElementById('device-groups');
        const deviceTemplate = document.getElementById('device-group-template');
        const addDeviceButton = document.getElementById('add-device-group');
        const connectionTotal = document.getElementById('connection-total');
        const connectionContainer = document.getElementById('connection-points');
        const connectionTemplate = document.getElementById('connection-point-template');
        const connectionEmptyMessage = document.getElementById('connection-empty');
        const groupingPool = document.getElementById('grouping-pool');
        const groupColumnsContainer = document.getElementById('grouping-columns');
        const groupColumnTemplate = document.getElementById('group-column-template');
        const groupingEmptyMessage = document.getElementById('grouping-empty');
        const addGroupButton = document.getElementById('add-group');
        const deviceChipTemplate = document.getElementById('device-chip-template');
        const groupingWarning = document.getElementById('grouping-warning');
        const materialGroupsContainer = document.getElementById('material-groups');
        const materialGroupTemplate = document.getElementById('material-group-template');
        const materialRowTemplate = document.getElementById('material-row-template');
        const materialsEmptyMessage = document.getElementById('materials-empty');
        const mountingList = document.getElementById('mounting-list');
        const mountingRowTemplate = document.getElementById('mounting-row-template');
        const mountingMaterialTemplate = document.getElementById('mounting-material-template');
        const addMountingButton = document.getElementById('add-mounting-element');
        const stepSections = Array.from(document.querySelectorAll('.wizard-step'));
        const stepButtons = Array.from(document.querySelectorAll('.wizard-progress-step'));
        const prevButton = document.querySelector('[data-action="prev-step"]');
        const nextButton = document.querySelector('[data-action="next-step"]');
        const finishButton = document.querySelector('[data-role="finish"]');
        const wizardForm = document.querySelector('.wizard-form');
        const initialStepRaw = Number(wizardForm?.dataset.initialStep ?? '0');
        const initialStep = Number.isFinite(initialStepRaw)
            ? Math.max(0, Math.min(initialStepRaw, stepSections.length - 1))
            : 0;

        let currentStep = 0;

        function showStep(index) {
            if (index < 0 || index >= stepSections.length) {
                return;
            }
            currentStep = index;
            stepSections.forEach((section, idx) => {
                if (idx === index) {
                    section.removeAttribute('hidden');
                    section.classList.add('active');
                } else {
                    section.setAttribute('hidden', 'hidden');
                    section.classList.remove('active');
                }
            });
            stepButtons.forEach(button => {
                const stepIndex = Number(button.dataset.stepIndex);
                const isActive = stepIndex === index;
                button.classList.toggle('active', isActive);
                button.disabled = isActive;
            });
            if (prevButton) {
                prevButton.disabled = index === 0;
            }
            if (nextButton) {
                nextButton.hidden = index === stepSections.length - 1;
            }
            if (finishButton) {
                finishButton.hidden = index !== stepSections.length - 1;
            }
        }

        stepButtons.forEach(button => {
            button.addEventListener('click', () => {
                const stepIndex = Number(button.dataset.stepIndex);
                if (!Number.isNaN(stepIndex)) {
                    showStep(stepIndex);
                }
            });
        });
        prevButton?.addEventListener('click', () => {
            if (currentStep > 0) {
                showStep(currentStep - 1);
            }
        });
        nextButton?.addEventListener('click', () => {
            if (currentStep < stepSections.length - 1) {
                showStep(currentStep + 1);
            }
        });

        function updateTotalConnectionPoints() {
            if (!connectionTotal || !deviceContainer) {
                return;
            }
            const names = new Set();
            const connectionInputs = deviceContainer.querySelectorAll('input[data-field="connectionPoint"]');
            connectionInputs.forEach(input => {
                const value = input.value.trim();
                if (value) {
                    names.add(value);
                }
            });
            connectionTotal.textContent = names.size.toString();
        }

        function getDeviceGroups() {
            return Array.from(deviceContainer?.querySelectorAll('.device-group') ?? []);
        }

        function isCameraDevice(select) {
            if (!(select instanceof HTMLSelectElement)) {
                return false;
            }
            const option = select.options[select.selectedIndex];
            if (!option) {
                return false;
            }
            if (option.dataset && typeof option.dataset.camera !== 'undefined') {
                return option.dataset.camera === 'true';
            }
            const label = option.text?.toLowerCase() ?? '';
            return label.includes('камера');
        }

        function normalizeConnectionName(value) {
            return (value || '').trim().toLowerCase();
        }

        function requiresGenericCableLabel(select) {
            if (!(select instanceof HTMLSelectElement)) {
                return false;
            }
            const option = select.options[select.selectedIndex];
            const label = option?.text?.toLowerCase() ?? '';
            return label.includes('камера')
                || label.includes('точка доступа')
                || label.includes('wi-fi')
                || label.includes('wifi')
                || label.includes('точка сети')
                || label.includes('сетевая точка');
        }

        function updateCameraFieldsForGroup(group) {
            if (!group) {
                return;
            }
            const typeSelect = group.querySelector('select[data-field="deviceTypeId"]');
            const accessorySelect = group.querySelector('select[data-field="cameraAccessory"]');
            const depthInput = group.querySelector('input[data-field="cameraViewingDepth"]');
            const cameraFields = group.querySelector('[data-role="camera-fields"]');
            const cameraSelected = isCameraDevice(typeSelect);
            if (cameraFields) {
                cameraFields.classList.toggle('is-hidden', !cameraSelected);
            }
            if (accessorySelect) {
                accessorySelect.disabled = !cameraSelected;
                if (!cameraSelected) {
                    accessorySelect.value = '';
                }
            }
            if (depthInput) {
                depthInput.disabled = !cameraSelected;
                if (!cameraSelected) {
                    depthInput.value = '';
                }
            }
        }

        function getRequiredCableFunctions(select) {
            if (!(select instanceof HTMLSelectElement)) {
                return [];
            }
            const option = select.options[select.selectedIndex];
            const datasetValue = option?.dataset?.requiredCables || '';
            const functions = datasetValue
                .split(',')
                .map(item => item.trim().toUpperCase())
                .filter(Boolean);
            if (select.value && !functions.includes('SIGNAL')) {
                functions.push('SIGNAL');
            }
            return functions;
        }

        function updateCableFieldsForGroup(group) {
            if (!group) {
                return;
            }
            const typeSelect = group.querySelector('select[data-field="deviceTypeId"]');
            const requiredFunctions = getRequiredCableFunctions(typeSelect);
            const container = group.querySelector('[data-role="cable-fields"]');
            if (!container) {
                return;
            }
            const fields = Array.from(container.querySelectorAll('.cable-field'));
            fields.forEach(field => {
                const functionName = (field.dataset.cableFunction || '').toUpperCase();
                const required = requiredFunctions.includes(functionName);
                field.classList.toggle('is-hidden', !required);
                const select = field.querySelector('select');
                if (select) {
                    select.disabled = !required;
                    select.required = required;
                    if (!required) {
                        select.value = '';
                    }
                }
            });
            container.classList.toggle('is-hidden', requiredFunctions.length === 0);
            const signalField = fields.find(field => (field.dataset.cableFunction || '').toUpperCase() === 'SIGNAL');
            if (signalField) {
                const labelElement = signalField.querySelector('label');
                if (labelElement) {
                    const defaultLabel = labelElement.dataset.defaultLabel || labelElement.textContent || '';
                    if (requiresGenericCableLabel(typeSelect)) {
                        labelElement.textContent = 'Кабель';
                    } else if (defaultLabel) {
                        labelElement.textContent = defaultLabel;
                    }
                }
            }
        }

        function getMountingRows() {
            return Array.from(document.querySelectorAll('.mounting-row'));
        }

        function getMountingRowElementId(row) {
            if (!row) {
                return '';
            }
            const hidden = row.querySelector('input[data-field="elementId"]');
            if (hidden instanceof HTMLInputElement) {
                return hidden.value.trim();
            }
            const select = row.querySelector('select[data-field="elementId"]');
            if (select instanceof HTMLSelectElement) {
                return select.value.trim();
            }
            return '';
        }

        function updateAutoMountingRow(row, elementId, elementName) {
            if (!row) {
                return;
            }
            row.classList.add('is-locked');
            row.dataset.autoElementId = elementId;
            const idInput = row.querySelector('input[data-field="elementId"]');
            if (idInput instanceof HTMLInputElement) {
                idInput.value = elementId;
            }
            const nameInput = row.querySelector('input[data-field="elementName"]');
            if (nameInput instanceof HTMLInputElement) {
                nameInput.value = elementName || '';
            }
            const displayName = row.querySelector('[data-role="element-name"]');
            if (displayName) {
                displayName.textContent = elementName || 'Не выбран';
            }
        }

        function createAutoMountingRow(elementId, elementName) {
            const row = document.createElement('div');
            row.classList.add('mounting-row', 'is-locked');

            const elementNameInput = document.createElement('input');
            elementNameInput.type = 'hidden';
            elementNameInput.setAttribute('data-field', 'elementName');
            row.appendChild(elementNameInput);

            const header = document.createElement('div');
            header.classList.add('grid', 'mounting-row-header');
            row.appendChild(header);

            const elementColumn = document.createElement('div');
            header.appendChild(elementColumn);
            const label = document.createElement('label');
            label.textContent = 'Монтажный короб / ящик';
            elementColumn.appendChild(label);

            const display = document.createElement('div');
            display.classList.add('mounting-element-display');
            elementColumn.appendChild(display);

            const elementIdInput = document.createElement('input');
            elementIdInput.type = 'hidden';
            elementIdInput.setAttribute('data-field', 'elementId');
            display.appendChild(elementIdInput);

            const nameParagraph = document.createElement('p');
            nameParagraph.classList.add('muted');
            nameParagraph.setAttribute('data-role', 'element-name');
            display.appendChild(nameParagraph);

            const noteParagraph = document.createElement('p');
            noteParagraph.classList.add('muted', 'small');
            noteParagraph.textContent = 'Назначен на шаге точек подключения.';
            display.appendChild(noteParagraph);

            const quantityColumn = document.createElement('div');
            header.appendChild(quantityColumn);
            const quantityLabel = document.createElement('label');
            quantityLabel.textContent = 'Количество / примечание';
            quantityColumn.appendChild(quantityLabel);
            const quantityInput = document.createElement('input');
            quantityInput.type = 'text';
            quantityInput.placeholder = '2 шт, 1 комплект...';
            quantityInput.setAttribute('data-field', 'quantity');
            quantityColumn.appendChild(quantityInput);

            const materialsContainer = document.createElement('div');
            materialsContainer.classList.add('stack', 'mounting-materials');
            materialsContainer.setAttribute('data-role', 'materials');
            row.appendChild(materialsContainer);

            if (mountingMaterialTemplate instanceof HTMLTemplateElement) {
                const materialClone = mountingMaterialTemplate.content.firstElementChild.cloneNode(true);
                materialsContainer.appendChild(materialClone);
            } else {
                const materialRow = document.createElement('div');
                materialRow.classList.add('mounting-material-row');
                materialsContainer.appendChild(materialRow);
            }

            const addMaterialButton = document.createElement('button');
            addMaterialButton.type = 'button';
            addMaterialButton.classList.add('button', 'tertiary');
            addMaterialButton.dataset.action = 'add-mounting-material';
            addMaterialButton.textContent = 'Добавить материал';
            row.appendChild(addMaterialButton);

            updateAutoMountingRow(row, elementId, elementName);
            return row;
        }

        function syncAutoMountingRows() {
            if (!mountingList) {
                return;
            }
            const assignments = new Map();
            const connectionRows = Array.from(connectionContainer?.querySelectorAll('.connection-point') ?? []);
            connectionRows.forEach(row => {
                const select = row.querySelector('select[data-field="mountingElementId"]');
                if (!(select instanceof HTMLSelectElement)) {
                    return;
                }
                const value = select.value.trim();
                if (!value) {
                    return;
                }
                if (!assignments.has(value)) {
                    const option = select.options[select.selectedIndex];
                    const name = option?.text?.trim() || '';
                    assignments.set(value, name);
                }
            });

            const rows = Array.from(mountingList.querySelectorAll('.mounting-row'));
            const manualRows = [];
            rows.forEach(row => {
                const elementId = getMountingRowElementId(row);
                if (row.classList.contains('is-locked')) {
                    if (!assignments.has(elementId)) {
                        row.remove();
                    } else {
                        updateAutoMountingRow(row, elementId, assignments.get(elementId) || '');
                        assignments.delete(elementId);
                    }
                } else {
                    manualRows.push(row);
                }
            });

            assignments.forEach((name, id) => {
                const newRow = createAutoMountingRow(id, name);
                if (manualRows.length > 0) {
                    mountingList.insertBefore(newRow, manualRows[0]);
                } else {
                    mountingList.appendChild(newRow);
                }
            });

            reindexMountingRows();
        }

        function reindexMountingRows() {
            const rows = getMountingRows();
            rows.forEach((row, index) => {
                row.dataset.index = index.toString();
                row.querySelectorAll('[data-field]').forEach(field => {
                    if (!(field instanceof HTMLElement)) {
                        return;
                    }
                    if (field.closest('.mounting-material-row')) {
                        return;
                    }
                    const key = field.getAttribute('data-field');
                    if (!key) {
                        return;
                    }
                    field.setAttribute('name', `mountingElements[${index}].${key}`);
                });
                const materialsContainer = row.querySelector('[data-role="materials"]');
                if (materialsContainer) {
                    const materialRows = Array.from(materialsContainer.querySelectorAll('.mounting-material-row'));
                    materialRows.forEach((materialRow, materialIndex) => {
                        materialRow.dataset.index = materialIndex.toString();
                        materialRow.querySelectorAll('[data-field]').forEach(field => {
                            const key = field.getAttribute('data-field');
                            if (!key) {
                                return;
                            }
                            let name = '';
                            if (key === 'materialId') {
                                name = `mountingElements[${index}].materials[${materialIndex}].materialId`;
                            } else if (key === 'amount') {
                                name = `mountingElements[${index}].materials[${materialIndex}].amount`;
                            }
                            if (name) {
                                field.setAttribute('name', name);
                            }
                        });
                        const removeMaterialButton = materialRow.querySelector('.remove-mounting-material');
                        if (removeMaterialButton) {
                            removeMaterialButton.style.display = materialIndex === 0 ? 'none' : '';
                        }
                    });
                }
                const removeButton = row.querySelector('.remove-mounting');
                if (removeButton) {
                    if (row.classList.contains('is-locked')) {
                        removeButton.style.display = 'none';
                    } else {
                        removeButton.style.display = index === 0 ? 'none' : '';
                    }
                }
            });
        }

        function reindexDeviceGroups() {
            const groups = getDeviceGroups();
            groups.forEach((group, index) => {
                group.dataset.index = index.toString();
                group.querySelectorAll('[data-field]').forEach(field => {
                    const key = field.getAttribute('data-field');
                    if (!key) {
                        return;
                    }
                    field.setAttribute('name', `deviceGroups[${index}].${key}`);
                });
                const removeButton = group.querySelector('.remove-device');
                if (removeButton) {
                    removeButton.style.display = index === 0 ? 'none' : '';
                }
                updateCameraFieldsForGroup(group);
                updateCableFieldsForGroup(group);
            });
            updateTotalConnectionPoints();
            ensureDeviceCards();
            refreshGroupColumnsFromCards();
            syncConnectionPointsFromDevices();
        }

        function getDeviceCards() {
            return Array.from(groupingPool?.querySelectorAll('.device-chip') ?? []);
        }

        function enableCardDrag(card) {
            if (!card || card.dataset.dragBound === 'true') {
                return;
            }
            card.addEventListener('dragstart', event => {
                event.dataTransfer?.setData('text/plain', card.dataset.index ?? '');
                event.dataTransfer?.setDragImage(card, 12, 12);
                card.classList.add('dragging');
                showGroupingWarning('');
                highlightDropzonesForCard(card);
            });
            card.addEventListener('dragend', () => {
                card.classList.remove('dragging');
                clearDropzoneHighlights();
            });
            card.dataset.dragBound = 'true';
        }

        function ensureDeviceCards() {
            if (!groupingPool) {
                return;
            }
            const groups = getDeviceGroups();
            let cards = getDeviceCards();
            while (cards.length < groups.length) {
                if (!(deviceChipTemplate instanceof HTMLTemplateElement)) {
                    break;
                }
                const clone = deviceChipTemplate.content.firstElementChild.cloneNode(true);
                groupingPool.appendChild(clone);
                cards = getDeviceCards();
            }
            while (cards.length > groups.length) {
                const card = cards.pop();
                card?.remove();
            }
            cards = getDeviceCards();
            cards.forEach((card, index) => {
                card.dataset.index = index.toString();
                const hidden = card.querySelector('input[data-field="groupLabel"]');
                if (hidden) {
                    hidden.setAttribute('name', `deviceGroups[${index}].groupLabel`);
                    card.dataset.groupLabel = hidden.value.trim();
                }
                enableCardDrag(card);
                updateCardAssignmentDisplay(card);
            });
        }

        function getGroupColumns() {
            return Array.from(groupColumnsContainer?.querySelectorAll('.group-column') ?? []);
        }

        function ensureGroupColumn(label) {
            if (!groupColumnsContainer) {
                return null;
            }
            const trimmed = (label || '').trim();
            if (!trimmed) {
                return null;
            }
            let column = getGroupColumns().find(col => (col.dataset.groupLabel || '') === trimmed);
            if (!column) {
                if (!(groupColumnTemplate instanceof HTMLTemplateElement)) {
                    return null;
                }
                column = groupColumnTemplate.content.firstElementChild.cloneNode(true);
                groupColumnsContainer.appendChild(column);
                bindGroupColumnEvents(column);
            }
            column.dataset.groupLabel = trimmed;
            const input = column.querySelector('.group-name-input');
            if (input && input !== document.activeElement) {
                input.value = trimmed;
            }
            updateGroupingEmptyState();
            updateColumnConnection(column);
            return column;
        }

        function bindGroupColumnEvents(column) {
            const input = column.querySelector('.group-name-input');
            const dropzone = column.querySelector('[data-role="dropzone"]');
            const removeButton = column.querySelector('.remove-group');
            input?.addEventListener('input', () => {
                const newLabel = input.value.trim();
                column.dataset.groupLabel = newLabel;
                Array.from(dropzone?.querySelectorAll('.device-chip') ?? []).forEach(card => {
                    moveCardToGroup(card, newLabel);
                });
                if (!newLabel) {
                    column.remove();
                    updateGroupingEmptyState();
                    syncMaterialGroupsWithLabels();
                    validateMaterialCapacity();
                    return;
                }
                updateGroupingEmptyState();
                updateGroupCapacities();
                syncMaterialGroupsWithLabels();
                validateMaterialCapacity();
            });
            dropzone?.addEventListener('dragover', event => {
                event.preventDefault();
                dropzone.classList.add('drop-target');
            });
            dropzone?.addEventListener('dragleave', () => {
                dropzone.classList.remove('drop-target');
            });
            dropzone?.addEventListener('drop', event => {
                event.preventDefault();
                dropzone.classList.remove('drop-target');
                clearDropzoneHighlights();
                const index = Number(event.dataTransfer?.getData('text/plain'));
                const label = column.dataset.groupLabel || input?.value.trim() || '';
                moveCardToGroupByIndex(index, label);
            });
            removeButton?.addEventListener('click', () => {
                Array.from(column.querySelectorAll('.device-chip')).forEach(card => moveCardToGroup(card, ''));
                column.remove();
                updateGroupingEmptyState();
                syncMaterialGroupsWithLabels();
                validateMaterialCapacity();
            });
        }

        function updateGroupingEmptyState() {
            if (!groupingEmptyMessage || !groupColumnsContainer) {
                return;
            }
            const hasGroups = groupColumnsContainer.querySelector('.group-column') !== null;
            groupingEmptyMessage.hidden = hasGroups;
        }

        function updateCardAssignmentDisplay(card) {
            const labelElement = card.querySelector('[data-role="assignment-label"]');
            const label = (card.dataset.groupLabel || '').trim();
            if (labelElement) {
                labelElement.textContent = label || 'не задана';
            }
        }

        function moveCardToGroup(card, label, options = {}) {
            if (!card) {
                return;
            }
            const trimmed = (label || '').trim();
            const hidden = card.querySelector('input[data-field="groupLabel"]');
            const targetIsPool = trimmed.length === 0;
            let column = null;
            let dropzone = null;
            if (!targetIsPool) {
                column = ensureGroupColumn(trimmed);
                dropzone = column?.querySelector('[data-role="dropzone"]') ?? null;
                if (!dropzone) {
                    return;
                }
                if (!options.skipValidation && !isCardCompatibleWithColumn(card, column)) {
                    if (!options.silent) {
                        const allowed = column.dataset.allowedConnectionLabel || '';
                        const deviceConnection = (card.dataset.connectionPoint || '').trim() || 'без точки подключения';
                        const message = allowed
                            ? `Группы формируются по узлам. Устройство подключено к "${deviceConnection}", а группа предназначена для узла "${allowed}".`
                            : `Группы формируются по узлам. Устройство подключено к "${deviceConnection}", поэтому его нельзя объединять с этой группой.`;
                        showGroupingWarning(message);
                    }
                    return;
                }
            }
            if (hidden) {
                hidden.value = trimmed;
            }
            card.dataset.groupLabel = trimmed;
            updateCardAssignmentDisplay(card);
            if (targetIsPool || !dropzone) {
                groupingPool?.appendChild(card);
            } else {
                dropzone.appendChild(card);
            }
            if (!options.silent) {
                showGroupingWarning('');
            }
            updateGroupingEmptyState();
            updateGroupCapacities();
            syncMaterialGroupsWithLabels();
            validateMaterialCapacity();
        }

        function moveCardToGroupByIndex(index, label, options = {}) {
            const card = getDeviceCards().find(item => Number(item.dataset.index) === index);
            if (card) {
                moveCardToGroup(card, label, options);
            }
        }

        function getDeviceGroupData(index) {
            const group = deviceContainer?.querySelector(`.device-group[data-index="${index}"]`);
            if (!group) {
                return null;
            }
            const typeSelect = group.querySelector('select[data-field="deviceTypeId"]');
            const countInput = group.querySelector('input[data-field="deviceCount"]');
            const installInput = group.querySelector('input[data-field="installLocation"]');
            const connectionInput = group.querySelector('input[data-field="connectionPoint"]');
            const distanceInput = group.querySelector('input[data-field="distanceToConnectionPoint"]');
            const accessorySelect = group.querySelector('select[data-field="cameraAccessory"]');
            const viewingDepthInput = group.querySelector('input[data-field="cameraViewingDepth"]');
            const signalCableSelect = group.querySelector('select[data-field="signalCableTypeId"]');
            const lowVoltageCableSelect = group.querySelector('select[data-field="lowVoltageCableTypeId"]');
            const typeName = typeSelect instanceof HTMLSelectElement
                ? typeSelect.options[typeSelect.selectedIndex]?.text?.trim()
                : '';
            const connectionName = connectionInput?.value.trim() || '';
            return {
                typeName: typeName || '',
                count: countInput?.value.trim() || '',
                installLocation: installInput?.value.trim() || '',
                connectionPoint: connectionName,
                connectionKey: normalizeConnectionName(connectionName),
                distance: distanceInput?.value.trim() || '',
                accessory: accessorySelect instanceof HTMLSelectElement
                    ? accessorySelect.options[accessorySelect.selectedIndex]?.text?.trim() || ''
                    : '',
                viewingDepth: viewingDepthInput?.value.trim() || '',
                signalCable: signalCableSelect instanceof HTMLSelectElement
                    ? signalCableSelect.options[signalCableSelect.selectedIndex]?.text?.trim() || ''
                    : '',
                lowVoltageCable: lowVoltageCableSelect instanceof HTMLSelectElement
                    ? lowVoltageCableSelect.options[lowVoltageCableSelect.selectedIndex]?.text?.trim() || ''
                    : '',
                signalLabel: requiresGenericCableLabel(typeSelect) ? 'Кабель' : 'Сигнал',
                isCamera: isCameraDevice(typeSelect)
            };
        }

        function updateDeviceSummaries() {
            getDeviceCards().forEach(card => {
                const index = Number(card.dataset.index);
                const summary = card.querySelector('[data-role="summary"]');
                if (Number.isNaN(index) || !summary) {
                    return;
                }
                const data = getDeviceGroupData(index);
                if (!data) {
                    summary.textContent = 'Заполните информацию на первом шаге, чтобы увидеть сводку.';
                    card.dataset.totalLength = '0';
                    card.dataset.connectionPoint = '';
                    card.dataset.connectionKey = '';
                    return;
                }
                card.dataset.connectionPoint = data.connectionPoint || '';
                card.dataset.connectionKey = data.connectionKey || '';
                const parts = [];
                if (data.typeName) {
                    parts.push(data.typeName);
                }
                if (data.count) {
                    parts.push(`${data.count} шт.`);
                }
                if (data.installLocation) {
                    parts.push(`Установка: ${data.installLocation}`);
                }
                if (data.connectionPoint) {
                    parts.push(`Подключение: ${data.connectionPoint}`);
                }
                if (data.distance) {
                    parts.push(`Расстояние: ${data.distance} м`);
                }
                if (data.isCamera && data.accessory) {
                    parts.push(`Комплектация: ${data.accessory}`);
                }
                if (data.isCamera && data.viewingDepth) {
                    const hasUnit = /[a-zа-я]/i.test(data.viewingDepth);
                    const depthLabel = hasUnit ? data.viewingDepth : `${data.viewingDepth} м`;
                    parts.push(`Глубина: ${depthLabel}`);
                }
                const cableDescriptions = [];
                if (data.signalCable) {
                    cableDescriptions.push(`${data.signalLabel}: ${data.signalCable}`);
                }
                if (data.lowVoltageCable) {
                    cableDescriptions.push(`Питание: ${data.lowVoltageCable}`);
                }
                if (cableDescriptions.length > 0) {
                    parts.push(`Кабели: ${cableDescriptions.join(', ')}`);
                }
                summary.textContent = parts.length > 0
                    ? parts.join(' • ')
                    : 'Заполните информацию на первом шаге, чтобы увидеть сводку.';
                const countValue = Number.parseInt(data.count.replace(',', '.'), 10);
                const distanceValue = Number.parseFloat(data.distance.replace(',', '.'));
                const length = Number.isFinite(countValue) && Number.isFinite(distanceValue)
                    ? Math.max(countValue, 0) * Math.max(distanceValue, 0)
                    : 0;
                card.dataset.totalLength = Number.isFinite(length) ? length.toString() : '0';
            });
        }

        function refreshGroupColumnsFromCards() {
            if (!groupingPool) {
                return;
            }
            const cards = getDeviceCards();
            const labels = new Set();
            cards.forEach(card => {
                const label = (card.dataset.groupLabel || card.querySelector('input[data-field="groupLabel"]')?.value || '').trim();
                if (label) {
                    labels.add(label);
                }
            });
            labels.forEach(label => ensureGroupColumn(label));
            getGroupColumns().forEach(column => {
                const label = (column.dataset.groupLabel || '').trim();
                if (label && !labels.has(label)) {
                    column.remove();
                }
            });
            cards.forEach(card => {
                const label = (card.dataset.groupLabel || '').trim();
                if (label) {
                    const dropzone = ensureGroupColumn(label)?.querySelector('[data-role="dropzone"]');
                    dropzone?.appendChild(card);
                } else {
                    groupingPool.appendChild(card);
                }
                updateCardAssignmentDisplay(card);
            });
            updateGroupingEmptyState();
            updateDeviceSummaries();
            updateGroupCapacities();
            syncMaterialGroupsWithLabels();
            validateMaterialCapacity();
        }

        function updateGroupCapacities() {
            getGroupColumns().forEach(column => {
                const dropzone = column.querySelector('[data-role="dropzone"]');
                let total = 0;
                Array.from(dropzone?.querySelectorAll('.device-chip') ?? []).forEach(card => {
                    const length = Number.parseFloat(card.dataset.totalLength ?? '0');
                    if (!Number.isNaN(length)) {
                        total += length;
                    }
                });
                column.dataset.totalLength = total.toString();
                const capacity = column.querySelector('[data-role="capacity"]');
                if (capacity) {
                    capacity.textContent = `Длина линии: ${total.toFixed(2)} м`;
                }
                updateColumnConnection(column);
            });
        }

        function collectGroupLabels() {
            const seen = new Set();
            const labels = [];
            getGroupColumns().forEach(column => {
                const label = (column.dataset.groupLabel || '').trim();
                if (label && !seen.has(label)) {
                    seen.add(label);
                    labels.push(label);
                }
            });
            return labels;
        }

        function showGroupingWarning(message) {
            if (!groupingWarning) {
                if (message) {
                    console.warn(message);
                }
                return;
            }
            if (message) {
                groupingWarning.textContent = message;
                groupingWarning.hidden = false;
            } else {
                groupingWarning.textContent = '';
                groupingWarning.hidden = true;
            }
        }

        function updateColumnConnection(column) {
            if (!column) {
                return;
            }
            const dropzone = column.querySelector('[data-role="dropzone"]');
            const cards = Array.from(dropzone?.querySelectorAll('.device-chip') ?? []);
            const cardWithConnection = cards.find(item => (item.dataset.connectionPoint || '').trim());
            const connectionLabel = cardWithConnection ? (cardWithConnection.dataset.connectionPoint || '').trim() : '';
            column.dataset.allowedConnection = cardWithConnection ? normalizeConnectionName(connectionLabel) : '';
            column.dataset.allowedConnectionLabel = connectionLabel;
            const hint = column.querySelector('[data-role="connection-hint"]');
            if (hint) {
                if (cards.length === 0) {
                    hint.textContent = 'Узел: не выбран';
                } else if (connectionLabel) {
                    hint.textContent = `Узел: ${connectionLabel}`;
                } else {
                    hint.textContent = 'Узел: не указан';
                }
            }
        }

        function isCardCompatibleWithColumn(card, column) {
            if (!card || !column) {
                return false;
            }
            const dropzone = column.querySelector('[data-role="dropzone"]');
            const existingCards = Array.from(dropzone?.querySelectorAll('.device-chip') ?? []).filter(existing => existing !== card);
            if (existingCards.length === 0) {
                return true;
            }
            const cardConnection = (card.dataset.connectionPoint || '').trim();
            const cardKey = normalizeConnectionName(cardConnection);
            const nonEmpty = existingCards
                .map(existing => ({
                    raw: (existing.dataset.connectionPoint || '').trim(),
                    key: normalizeConnectionName(existing.dataset.connectionPoint || '')
                }))
                .filter(item => item.raw);
            if (nonEmpty.length > 0) {
                return cardKey.length > 0 && cardKey === nonEmpty[0].key;
            }
            return cardConnection.length === 0;
        }

        function highlightDropzonesForCard(card) {
            getGroupColumns().forEach(column => {
                const dropzone = column.querySelector('[data-role="dropzone"]');
                if (!dropzone) {
                    return;
                }
                const compatible = isCardCompatibleWithColumn(card, column);
                dropzone.classList.toggle('is-incompatible', !compatible);
            });
        }

        function clearDropzoneHighlights() {
            getGroupColumns().forEach(column => {
                column.querySelector('[data-role="dropzone"]')?.classList.remove('is-incompatible');
            });
            groupingPool?.classList.remove('is-incompatible');
        }

        function setConnectionPointError(input, message) {
            const row = input.closest('.connection-point');
            const errorElement = row?.querySelector('[data-role="error"]');
            if (!row || !errorElement) {
                return;
            }
            if (message) {
                errorElement.textContent = message;
                errorElement.hidden = false;
                input.classList.add('input-error');
            } else {
                errorElement.textContent = '';
                errorElement.hidden = true;
                input.classList.remove('input-error');
            }
        }

        function reindexConnectionPoints() {
            if (!connectionContainer) {
                return;
            }
            const rows = Array.from(connectionContainer.querySelectorAll('.connection-point'));
            rows.forEach((row, index) => {
                const nameInput = row.querySelector('input[data-field="name"]');
                const elementSelect = row.querySelector('select[data-field="mountingElementId"]');
                const distanceInput = row.querySelector('input[data-field="distanceToPower"]');
                const cableSelect = row.querySelector('select[data-field="powerCableTypeId"]');
                const materialSelect = row.querySelector('select[data-field="layingMaterialId"]');
                const surfaceCategorySelect = row.querySelector('select[data-field="layingSurfaceCategory"]');
                const surfaceInput = row.querySelector('input[data-field="layingSurface"]');
                row.dataset.index = index.toString();
                if (nameInput) {
                    nameInput.setAttribute('name', `connectionPoints[${index}].name`);
                    row.dataset.connectionName = nameInput.value.trim();
                }
                if (elementSelect) {
                    elementSelect.setAttribute('name', `connectionPoints[${index}].mountingElementId`);
                }
                if (distanceInput) {
                    distanceInput.setAttribute('name', `connectionPoints[${index}].distanceToPower`);
                }
                if (cableSelect) {
                    cableSelect.setAttribute('name', `connectionPoints[${index}].powerCableTypeId`);
                }
                if (materialSelect) {
                    materialSelect.setAttribute('name', `connectionPoints[${index}].layingMaterialId`);
                }
                if (surfaceCategorySelect) {
                    surfaceCategorySelect.setAttribute('name', `connectionPoints[${index}].layingSurfaceCategory`);
                }
                if (surfaceInput) {
                    surfaceInput.setAttribute('name', `connectionPoints[${index}].layingSurface`);
                }
            });
            if (connectionEmptyMessage) {
                connectionEmptyMessage.hidden = rows.length > 0;
            }
        }

        function syncConnectionPointsFromDevices() {
            if (!connectionContainer) {
                return;
            }
            const usageMap = new Map();
            const groups = getDeviceGroups();
            const rowMap = new Map();
            Array.from(connectionContainer.querySelectorAll('.connection-point')).forEach(row => {
                const key = (row.dataset.connectionName || '').trim();
                if (key) {
                    rowMap.set(key, row);
                }
                row.dataset.matched = 'false';
            });
            groups.forEach((group, index) => {
                const connectionInput = group.querySelector('input[data-field="connectionPoint"]');
                const name = connectionInput?.value.trim();
                if (!name) {
                    return;
                }
                if (!usageMap.has(name)) {
                    usageMap.set(name, []);
                }
                usageMap.get(name).push(index);
                let row = rowMap.get(name);
                if (!row) {
                    if (!(connectionTemplate instanceof HTMLTemplateElement)) {
                        return;
                    }
                    row = connectionTemplate.content.firstElementChild.cloneNode(true);
                    connectionContainer.appendChild(row);
                    rowMap.set(name, row);
                }
                row.dataset.matched = 'true';
                row.dataset.connectionName = name;
                const nameInput = row.querySelector('input[data-field="name"]');
                if (nameInput && nameInput.value.trim() !== name) {
                    nameInput.value = name;
                }
            });
            Array.from(connectionContainer.querySelectorAll('.connection-point')).forEach(row => {
                if (row.dataset.matched !== 'true') {
                    row.remove();
                } else {
                    row.removeAttribute('data-matched');
                }
            });
            reindexConnectionPoints();
            updateConnectionPointUsage(usageMap);
            syncAutoMountingRows();
        }

        function updateConnectionPointUsage(usageMap) {
            if (!connectionContainer) {
                return;
            }
            Array.from(connectionContainer.querySelectorAll('.connection-point')).forEach(row => {
                const usageElement = row.querySelector('[data-role="usage"]');
                if (!usageElement) {
                    return;
                }
                const name = row.dataset.connectionName || '';
                const indices = usageMap.get(name) || [];
                if (indices.length === 0) {
                    usageElement.textContent = 'Нет привязанных устройств.';
                    return;
                }
                const descriptions = indices.map(index => {
                    const data = getDeviceGroupData(index);
                    if (!data) {
                        return `Устройство №${index + 1}`;
                    }
                    const parts = [];
                    if (data.typeName) {
                        parts.push(data.typeName);
                    } else {
                        parts.push(`Устройство №${index + 1}`);
                    }
                    if (data.count) {
                        parts.push(`${data.count} шт.`);
                    }
                    if (data.installLocation) {
                        parts.push(data.installLocation);
                    }
                    return parts.join(' — ');
                });
                usageElement.textContent = `Устройства: ${descriptions.join('; ')}`;
            });
        }

        function updateDeviceConnectionNames(oldName, newName) {
            if (!deviceContainer || !oldName || oldName === newName) {
                return;
            }
            Array.from(deviceContainer.querySelectorAll('input[data-field="connectionPoint"]')).forEach(input => {
                if (input.value.trim() === oldName) {
                    input.value = newName;
                }
            });
        }

        function syncMaterialGroupsWithLabels() {
            if (!materialGroupsContainer) {
                return;
            }
            const labels = collectGroupLabels();
            const existing = Array.from(materialGroupsContainer.querySelectorAll('.material-group'));
            const groupMap = new Map(existing.map(group => [group.dataset.groupLabel || '', group]));
            const usedGroups = new Set();
            labels.forEach(label => {
                let group = groupMap.get(label);
                if (!group) {
                    if (!(materialGroupTemplate instanceof HTMLTemplateElement)) {
                        return;
                    }
                    group = materialGroupTemplate.content.firstElementChild.cloneNode(true);
                    materialGroupsContainer.appendChild(group);
                }
                group.dataset.groupLabel = label;
                const labelElement = group.querySelector('[data-role="label"]');
                if (labelElement) {
                    labelElement.textContent = label;
                }
                const hiddenInput = group.querySelector('input[data-field="groupLabel"]');
                if (hiddenInput) {
                    hiddenInput.value = label;
                }
                usedGroups.add(group);
            });
            existing.forEach(group => {
                if (!usedGroups.has(group)) {
                    group.remove();
                }
            });
            if (materialsEmptyMessage) {
                materialsEmptyMessage.hidden = labels.length > 0;
            }
            reindexMaterialGroups();
            validateMaterialCapacity();
        }

        function reindexMaterialGroups() {
            if (!materialGroupsContainer) {
                return;
            }
            const groups = Array.from(materialGroupsContainer.querySelectorAll('.material-group'));
            groups.forEach((group, groupIndex) => {
                group.dataset.index = groupIndex.toString();
                const labelInput = group.querySelector('input[data-field="groupLabel"]');
                if (labelInput) {
                    labelInput.setAttribute('name', `materialGroups[${groupIndex}].groupLabel`);
                    group.dataset.groupLabel = labelInput.value.trim();
                }
                const rows = Array.from(group.querySelectorAll('.material-row'));
                rows.forEach((row, rowIndex) => {
                    row.dataset.index = rowIndex.toString();
                    row.querySelectorAll('[data-field]').forEach(field => {
                        const key = field.getAttribute('data-field');
                        if (!key) {
                            return;
                        }
                        let name = '';
                        if (key === 'materialId') {
                            name = `materialGroups[${groupIndex}].materials[${rowIndex}].materialId`;
                        } else if (key === 'amount') {
                            name = `materialGroups[${groupIndex}].materials[${rowIndex}].amount`;
                        } else if (key === 'layingSurface') {
                            name = `materialGroups[${groupIndex}].materials[${rowIndex}].layingSurface`;
                        } else if (key === 'layingSurfaceCategory') {
                            name = `materialGroups[${groupIndex}].materials[${rowIndex}].layingSurfaceCategory`;
                        }
                        if (name) {
                            field.setAttribute('name', name);
                        }
                    });
                    const removeButton = row.querySelector('.remove-material');
                    if (removeButton) {
                        removeButton.style.display = rowIndex === 0 ? 'none' : '';
                    }
                });
            });
        }

        function parseLength(value) {
            if (!value) {
                return Number.NaN;
            }
            const match = value.replace(',', '.').match(/\d+(?:\.\d+)?/);
            return match ? Number.parseFloat(match[0]) : Number.NaN;
        }

        function validateMaterialCapacity() {
            if (!materialGroupsContainer) {
                return;
            }
            const capacities = new Map();
            getGroupColumns().forEach(column => {
                const label = (column.dataset.groupLabel || '').trim();
                if (!label) {
                    return;
                }
                const total = Number.parseFloat(column.dataset.totalLength ?? '0');
                capacities.set(label, Number.isNaN(total) ? 0 : total);
            });
            Array.from(materialGroupsContainer.querySelectorAll('.material-group')).forEach(group => {
                const label = (group.dataset.groupLabel || '').trim();
                const capacity = capacities.get(label) ?? 0;
                let used = 0;
                group.querySelectorAll('input[data-field="amount"]').forEach(input => {
                    const value = parseLength(input.value);
                    if (!Number.isNaN(value)) {
                        used += value;
                    }
                });
                group.dataset.capacity = capacity.toString();
                group.dataset.usedLength = used.toString();
                const warning = group.querySelector('[data-role="capacity-warning"]');
                const over = capacity > 0 && used > capacity + 0.0001;
                group.classList.toggle('over-capacity', over);
                if (warning) {
                    warning.hidden = !over;
                    if (over) {
                        warning.textContent = `Запланировано ${used.toFixed(2)} м при доступных ${capacity.toFixed(2)} м.`;
                    }
                }
            });
        }

        addDeviceButton?.addEventListener('click', () => {
            if (!(deviceTemplate instanceof HTMLTemplateElement) || !deviceContainer) {
                return;
            }
            const clone = deviceTemplate.content.firstElementChild.cloneNode(true);
            deviceContainer.appendChild(clone);
            reindexDeviceGroups();
        });

        deviceContainer?.addEventListener('input', event => {
            const target = event.target;
            if (!(target instanceof HTMLInputElement)) {
                return;
            }
            const field = target.getAttribute('data-field');
            if (field === 'deviceCount') {
                updateTotalConnectionPoints();
                updateDeviceSummaries();
                updateGroupCapacities();
                validateMaterialCapacity();
            }
            if (field === 'connectionPoint') {
                updateTotalConnectionPoints();
                syncConnectionPointsFromDevices();
                updateDeviceSummaries();
                updateGroupCapacities();
                validateMaterialCapacity();
            } else if (field === 'installLocation' || field === 'distanceToConnectionPoint') {
                updateDeviceSummaries();
                updateGroupCapacities();
                validateMaterialCapacity();
            } else if (field === 'cameraViewingDepth') {
                updateDeviceSummaries();
            }
        });

        deviceContainer?.addEventListener('change', event => {
            const target = event.target;
            if (!(target instanceof HTMLSelectElement)) {
                return;
            }
            const field = target.getAttribute('data-field');
            if (field === 'deviceTypeId') {
                const group = target.closest('.device-group');
                updateCameraFieldsForGroup(group);
                updateCableFieldsForGroup(group);
                updateDeviceSummaries();
                updateGroupCapacities();
                validateMaterialCapacity();
            } else if (field === 'cameraAccessory') {
                updateDeviceSummaries();
            } else if (field === 'signalCableTypeId' || field === 'lowVoltageCableTypeId'
                    || field === 'powerCableTypeId') {
                updateDeviceSummaries();
            }
        });

        deviceContainer?.addEventListener('click', event => {
            const target = event.target;
            if (!(target instanceof HTMLElement)) {
                return;
            }
            if (target.classList.contains('remove-device')) {
                const group = target.closest('.device-group');
                if (group && deviceContainer.children.length > 1) {
                    group.remove();
                    reindexDeviceGroups();
                }
            }
        });

        connectionContainer?.addEventListener('focusin', event => {
            const target = event.target;
            if (target instanceof HTMLInputElement && target.getAttribute('data-field') === 'name') {
                target.dataset.originalValue = target.value.trim();
            }
        });

        connectionContainer?.addEventListener('focusout', event => {
            const target = event.target;
            if (!(target instanceof HTMLInputElement) || target.getAttribute('data-field') !== 'name') {
                return;
            }
            const row = target.closest('.connection-point');
            if (!row) {
                return;
            }
            const oldValue = target.dataset.originalValue || row.dataset.connectionName || '';
            const newValue = target.value.trim();
            if (!newValue) {
                setConnectionPointError(target, 'Введите название точки подключения');
                target.value = oldValue;
                return;
            }
            const duplicate = Array.from(connectionContainer.querySelectorAll('.connection-point')).some(other => {
                if (other === row) {
                    return false;
                }
                const otherInput = other.querySelector('input[data-field="name"]');
                const otherName = other.dataset.connectionName || otherInput?.value.trim() || '';
                return otherName === newValue;
            });
            if (duplicate) {
                setConnectionPointError(target, 'Название должно быть уникальным');
                target.value = oldValue;
                return;
            }
            setConnectionPointError(target, null);
            row.dataset.connectionName = newValue;
            updateDeviceConnectionNames(oldValue, newValue);
            syncConnectionPointsFromDevices();
            updateDeviceSummaries();
            updateGroupCapacities();
            validateMaterialCapacity();
        });

        connectionContainer?.addEventListener('change', event => {
            const target = event.target;
            if (!(target instanceof HTMLSelectElement)) {
                return;
            }
            if (target.getAttribute('data-field') === 'mountingElementId') {
                syncAutoMountingRows();
            }
        });

        addGroupButton?.addEventListener('click', () => {
            const labels = collectGroupLabels();
            let counter = labels.length + 1;
            let proposed = `Группа ${counter}`;
            while (labels.includes(proposed)) {
                counter += 1;
                proposed = `Группа ${counter}`;
            }
            const column = ensureGroupColumn(proposed);
            if (column) {
                const input = column.querySelector('.group-name-input');
                if (input) {
                    input.value = proposed;
                    input.focus();
                    input.select();
                }
                column.dataset.groupLabel = proposed;
            }
            updateGroupingEmptyState();
            syncMaterialGroupsWithLabels();
        });

        groupingPool?.addEventListener('dragover', event => {
            event.preventDefault();
            groupingPool.classList.add('drop-target');
        });

        groupingPool?.addEventListener('dragleave', () => {
            groupingPool.classList.remove('drop-target');
        });

        groupingPool?.addEventListener('drop', event => {
            event.preventDefault();
            groupingPool.classList.remove('drop-target');
            clearDropzoneHighlights();
            const index = Number(event.dataTransfer?.getData('text/plain'));
            moveCardToGroupByIndex(index, '');
        });

        addMountingButton?.addEventListener('click', event => {
            event.preventDefault();
            if (!(mountingRowTemplate instanceof HTMLTemplateElement) || !mountingList) {
                return;
            }
            const clone = mountingRowTemplate.content.firstElementChild.cloneNode(true);
            mountingList.appendChild(clone);
            reindexMountingRows();
        });

        mountingList?.addEventListener('change', event => {
            const target = event.target;
            if (!(target instanceof HTMLSelectElement)) {
                return;
            }
            if (target.getAttribute('data-field') !== 'elementId') {
                return;
            }
            const row = target.closest('.mounting-row');
            if (!row) {
                return;
            }
            const hiddenName = row.querySelector('input[data-field="elementName"]');
            if (hiddenName instanceof HTMLInputElement) {
                const option = target.options[target.selectedIndex];
                hiddenName.value = option?.text ?? '';
            }
        });

        mountingList?.addEventListener('click', event => {
            const target = event.target;
            if (!(target instanceof HTMLElement)) {
                return;
            }
            if (target.dataset.action === 'add-mounting-material') {
                event.preventDefault();
                const row = target.closest('.mounting-row');
                if (!row || !(mountingMaterialTemplate instanceof HTMLTemplateElement)) {
                    return;
                }
                const container = row.querySelector('[data-role="materials"]');
                if (!container) {
                    return;
                }
                const clone = mountingMaterialTemplate.content.firstElementChild.cloneNode(true);
                container.appendChild(clone);
                reindexMountingRows();
                return;
            }
            if (target.classList.contains('remove-mounting-material')) {
                event.preventDefault();
                const materialRow = target.closest('.mounting-material-row');
                const row = target.closest('.mounting-row');
                if (!materialRow || !row) {
                    return;
                }
                const container = row.querySelector('[data-role="materials"]');
                if (!container) {
                    return;
                }
                const materialRows = Array.from(container.querySelectorAll('.mounting-material-row'));
                if (materialRows.length <= 1) {
                    materialRow.querySelectorAll('select[data-field], input[data-field]').forEach(field => {
                        if (field instanceof HTMLSelectElement || field instanceof HTMLInputElement) {
                            field.value = '';
                        }
                    });
                    return;
                }
                materialRow.remove();
                reindexMountingRows();
                return;
            }
            if (!target.classList.contains('remove-mounting')) {
                return;
            }
            event.preventDefault();
            const row = target.closest('.mounting-row');
            if (!row || row.classList.contains('is-locked')) {
                return;
            }
            const rows = getMountingRows();
            if (rows.length <= 1) {
                row.querySelectorAll('select[data-field], input[data-field]').forEach(field => {
                    if (field instanceof HTMLSelectElement || field instanceof HTMLInputElement) {
                        field.value = '';
                    }
                });
                const materials = row.querySelectorAll('.mounting-material-row');
                materials.forEach((materialRow, index) => {
                    materialRow.querySelectorAll('select[data-field], input[data-field]').forEach(field => {
                        if (field instanceof HTMLSelectElement || field instanceof HTMLInputElement) {
                            field.value = '';
                        }
                    });
                    if (index > 0) {
                        materialRow.remove();
                    }
                });
                reindexMountingRows();
                return;
            }
            row.remove();
            reindexMountingRows();
        });

        materialGroupsContainer?.addEventListener('click', event => {
            const target = event.target;
            if (!(target instanceof HTMLElement)) {
                return;
            }
            if (target.classList.contains('add-material')) {
                event.preventDefault();
                const group = target.closest('.material-group');
                const rowsContainer = group?.querySelector('.materials-container');
                if (!group || !rowsContainer || !(materialRowTemplate instanceof HTMLTemplateElement)) {
                    return;
                }
                const clone = materialRowTemplate.content.firstElementChild.cloneNode(true);
                rowsContainer.appendChild(clone);
                reindexMaterialGroups();
                validateMaterialCapacity();
                return;
            }
            if (target.classList.contains('remove-material')) {
                const row = target.closest('.material-row');
                const group = target.closest('.material-group');
                if (!row || !group) {
                    return;
                }
                const rows = group.querySelectorAll('.material-row');
                if (rows.length > 1) {
                    row.remove();
                    reindexMaterialGroups();
                    validateMaterialCapacity();
                }
            }
        });

        materialGroupsContainer?.addEventListener('input', event => {
            const target = event.target;
            if (target instanceof HTMLInputElement && target.getAttribute('data-field') === 'amount') {
                validateMaterialCapacity();
            }
        });

        function sanitizeFieldNames() {
            reindexDeviceGroups();
            reindexMountingRows();
            reindexConnectionPoints();
            reindexMaterialGroups();
            if (!wizardForm) {
                return;
            }
            wizardForm.querySelectorAll('[name*="__index__"]').forEach(field => {
                const key = field.getAttribute('data-field');
                if (!key) {
                    field.removeAttribute('name');
                    return;
                }
                const deviceGroup = field.closest('.device-group');
                if (deviceGroup && deviceGroup.dataset.index) {
                    field.setAttribute('name', `deviceGroups[${deviceGroup.dataset.index}].${key}`);
                    return;
                }
                const connectionPoint = field.closest('.connection-point');
                if (connectionPoint && connectionPoint.dataset.index) {
                    field.setAttribute('name', `connectionPoints[${connectionPoint.dataset.index}].${key}`);
                    return;
                }
                const materialGroup = field.closest('.material-group');
                if (materialGroup && materialGroup.dataset.index) {
                    const materialRow = field.closest('.material-row');
                    if (materialRow && materialRow.dataset.index) {
                        field.setAttribute('name', `materialGroups[${materialGroup.dataset.index}].materials[${materialRow.dataset.index}].${key}`);
                    } else {
                        field.setAttribute('name', `materialGroups[${materialGroup.dataset.index}].${key}`);
                    }
                    return;
                }
                const mountingRow = field.closest('.mounting-row');
                if (mountingRow && mountingRow.dataset.index) {
                    field.setAttribute('name', `mountingElements[${mountingRow.dataset.index}].${key}`);
                    return;
                }
                field.removeAttribute('name');
            });
        }

        wizardForm?.addEventListener('submit', () => {
            sanitizeFieldNames();
        });

        reindexMountingRows();
        reindexDeviceGroups();
        syncAutoMountingRows();
        showStep(initialStep);
    });
</script>
</body>
</html>
