<!DOCTYPE html>
<html lang="ru" xmlns:th="http://www.thymeleaf.org" xmlns:sec="http://www.thymeleaf.org/extras/spring-security">
<head>
    <meta charset="UTF-8">
    <title>Первичные данные объекта</title>
    <link rel="stylesheet" href="/css/main.css">
</head>
<body>
<header class="topbar">
    <h1>Object Manager</h1>
    <nav>
        <a href="/objects" class="active">Объекты</a>
        <a href="/customers">Заказчики</a>
        <a href="/admin" sec:authorize="hasRole('ADMIN')">Администрирование</a>
        <form method="post" action="/logout">
            <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}">
            <button type="submit" class="link-button">Выход</button>
        </form>
    </nav>
</header>
<main class="content">
    <section class="card">
        <div class="card-header">
            <h2 th:text="${object.name}">Объект</h2>
            <a class="button secondary" th:href="@{'/objects/' + ${object.id}}">Назад к объекту</a>
        </div>
        <p class="muted">Заполняйте первичные данные по шагам: сначала оборудование, затем точки подключения, после чего сгруппируйте устройства и задайте монтажные материалы.</p>
    </section>

    <form class="card wizard-form" method="post" th:action="@{'/objects/' + ${object.id} + '/primary-data/wizard'}" th:object="${wizardForm}">
        <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}">
        <nav class="wizard-progress">
            <button type="button" class="wizard-progress-step active" data-step-index="0">1. Оборудование</button>
            <button type="button" class="wizard-progress-step" data-step-index="1">2. Точки подключения</button>
            <button type="button" class="wizard-progress-step" data-step-index="2">3. Группы устройств</button>
            <button type="button" class="wizard-progress-step" data-step-index="3">4. Материалы</button>
        </nav>

        <div class="wizard-panels">
            <section class="wizard-step" data-step-index="0">
                <h3>Шаг 1. Оборудование</h3>
                <p class="muted">Укажите тип устройства, количество, место установки, точку подключения и расстояние до неё. Эти данные определяют дальнейшие шаги.</p>
                <div id="device-groups" class="stack">
                    <div class="device-group card nested-card" th:each="group, iter : *{deviceGroups}" th:data-index="${iter.index}">
                        <div class="grid">
                            <div>
                                <label>Тип устройства</label>
                                <select th:field="*{deviceGroups[__${iter.index}__].deviceTypeId}" data-field="deviceTypeId">
                                    <option value="">Не выбрано</option>
                                    <option th:each="type : ${deviceTypes}" th:value="${type.id}" th:text="${type.name}"></option>
                                </select>
                            </div>
                            <div>
                                <label>Количество</label>
                                <input type="number" min="0" step="1" class="device-count" th:field="*{deviceGroups[__${iter.index}__].deviceCount}" data-field="deviceCount">
                            </div>
                            <div>
                                <label>Расстояние до точки подключения (м)</label>
                                <input type="number" min="0" step="0.1" th:field="*{deviceGroups[__${iter.index}__].distanceToConnectionPoint}" data-field="distanceToConnectionPoint" placeholder="Например, 12">
                            </div>
                        </div>
                        <div class="grid">
                            <div>
                                <label>Точка установки</label>
                                <input type="text" th:field="*{deviceGroups[__${iter.index}__].installLocation}" data-field="installLocation" placeholder="Крыша, подъезд...">
                            </div>
                            <div>
                                <label>Точка подключения</label>
                                <input type="text" th:field="*{deviceGroups[__${iter.index}__].connectionPoint}" data-field="connectionPoint" placeholder="Распред. коробка...">
                            </div>
                        </div>
                        <button type="button" class="link-button danger remove-device" th:if="${iter.index > 0}">Удалить</button>
                    </div>
                </div>
                <template id="device-group-template">
                    <div class="device-group card nested-card">
                        <div class="grid">
                            <div>
                                <label>Тип устройства</label>
                                <select data-field="deviceTypeId">
                                    <option value="">Не выбрано</option>
                                    <option th:each="type : ${deviceTypes}" th:value="${type.id}" th:text="${type.name}"></option>
                                </select>
                            </div>
                            <div>
                                <label>Количество</label>
                                <input type="number" min="0" step="1" class="device-count" data-field="deviceCount">
                            </div>
                            <div>
                                <label>Расстояние до точки подключения (м)</label>
                                <input type="number" min="0" step="0.1" data-field="distanceToConnectionPoint" placeholder="Например, 12">
                            </div>
                        </div>
                        <div class="grid">
                            <div>
                                <label>Точка установки</label>
                                <input type="text" data-field="installLocation" placeholder="Крыша, подъезд...">
                            </div>
                            <div>
                                <label>Точка подключения</label>
                                <input type="text" data-field="connectionPoint" placeholder="Распред. коробка...">
                            </div>
                        </div>
                        <button type="button" class="link-button danger remove-device">Удалить</button>
                    </div>
                </template>
                <button type="button" class="button secondary" id="add-device-group">Добавить устройство</button>
                <p><strong>Всего точек подключения:</strong> <span id="connection-total" th:text="${totalConnectionPoints}">0</span></p>
            </section>

            <section class="wizard-step" data-step-index="1" hidden>
                <h3>Шаг 2. Точки подключения</h3>
                <p class="muted">Точки формируются автоматически на основании предыдущего шага. Названия должны быть уникальными, чтобы к одной точке можно было подключить несколько устройств.</p>
                <p class="muted" id="connection-empty" th:if="${#lists.isEmpty(wizardForm.connectionPoints)}">Добавьте устройства и укажите для них точки подключения на первом шаге.</p>
                <div id="connection-points" class="stack">
                    <div class="connection-point card nested-card" th:each="point, iter : *{connectionPoints}" th:data-connection-name="${point.name != null ? point.name : ''}">
                        <div class="grid">
                            <div>
                                <label>Название точки</label>
                                <input type="text" th:field="*{connectionPoints[__${iter.index}__].name}" data-field="name" placeholder="Распред. коробка №1">
                                <p class="field-error" data-role="error" hidden>Название должно быть уникальным</p>
                            </div>
                            <div>
                                <label>Монтажный короб / ящик</label>
                                <select th:field="*{connectionPoints[__${iter.index}__].mountingElementId}" data-field="mountingElementId">
                                    <option value="">Не выбран</option>
                                    <option th:each="element : ${mountingElements}" th:value="${element.id}" th:text="${element.name}"></option>
                                </select>
                            </div>
                        </div>
                        <p class="connection-usage" data-role="usage">Устройства будут отображены после заполнения первого шага.</p>
                    </div>
                </div>
                <template id="connection-point-template">
                    <div class="connection-point card nested-card">
                        <div class="grid">
                            <div>
                                <label>Название точки</label>
                                <input type="text" data-field="name" placeholder="Распред. коробка №1">
                                <p class="field-error" data-role="error" hidden>Название должно быть уникальным</p>
                            </div>
                            <div>
                                <label>Монтажный короб / ящик</label>
                                <select data-field="mountingElementId">
                                    <option value="">Не выбран</option>
                                    <option th:each="element : ${mountingElements}" th:value="${element.id}" th:text="${element.name}"></option>
                                </select>
                            </div>
                        </div>
                        <p class="connection-usage" data-role="usage">Устройства будут отображены после заполнения первого шага.</p>
                    </div>
                </template>
            </section>

            <section class="wizard-step" data-step-index="2" hidden>
                <h3>Шаг 3. Группы устройств</h3>
                <p class="muted">Объедините камеры и другие устройства в логические группы. Эти группы будут использоваться для выбора монтажных материалов.</p>
                <div id="grouping-list" class="stack">
                    <div class="grouping-row card nested-card" th:each="group, iter : *{deviceGroups}" th:data-index="${iter.index}">
                        <p class="muted small" data-role="summary">Заполните информацию на первом шаге, чтобы увидеть сводку.</p>
                        <label>Название группы</label>
                        <input type="text" th:field="*{deviceGroups[__${iter.index}__].groupLabel}" data-field="groupLabel" placeholder="Линия 1" list="group-label-datalist">
                    </div>
                </div>
                <datalist id="group-label-datalist"></datalist>
                <template id="grouping-row-template">
                    <div class="grouping-row card nested-card">
                        <p class="muted small" data-role="summary">Заполните информацию на первом шаге, чтобы увидеть сводку.</p>
                        <label>Название группы</label>
                        <input type="text" data-field="groupLabel" placeholder="Линия 1" list="group-label-datalist">
                    </div>
                </template>
            </section>

            <section class="wizard-step" data-step-index="3" hidden>
                <h3>Шаг 4. Монтажные материалы</h3>
                <p class="muted">Для каждой созданной группы укажите материалы и способ прокладки. Если группа не требует материалов, оставьте поля пустыми.</p>
                <div class="card nested-card">
                    <h4>Монтажные элементы</h4>
                    <p class="muted small">Укажите дополнительные монтажные элементы, необходимые для всех групп.</p>
                    <div class="stack">
                        <div class="mounting-row" th:each="element, iter : *{mountingElements}">
                            <input type="hidden" th:field="*{mountingElements[__${iter.index}__].elementId}">
                            <div class="grid">
                                <div>
                                    <label th:for="${'mounting-' + iter.index}" th:text="${element.elementName != null ? element.elementName : 'Элемент'}">Элемент</label>
                                    <input type="text" th:id="${'mounting-' + iter.index}" th:value="${element.elementName}" readonly>
                                </div>
                                <div>
                                    <label>Количество / примечание</label>
                                    <input type="text" th:field="*{mountingElements[__${iter.index}__].quantity}" placeholder="2 шт, 1 комплект...">
                                </div>
                            </div>
                        </div>
                        <p th:if="${#lists.isEmpty(mountingElements)}" class="muted small">Монтажные элементы пока не добавлены в администрировании.</p>
                    </div>
                </div>
                <p class="muted" id="materials-empty" th:if="${#lists.isEmpty(wizardForm.materialGroups)}">Создайте хотя бы одну группу устройств на предыдущем шаге, чтобы назначить материалы.</p>
                <div id="material-groups" class="stack">
                    <div class="material-group card nested-card" th:each="group, gIndex : *{materialGroups}" th:data-group-label="${group.groupLabel != null ? group.groupLabel : ''}">
                        <input type="hidden" th:field="*{materialGroups[__${gIndex.index}__].groupLabel}" data-field="groupLabel">
                        <header class="group-header">
                            <h4 class="group-label">Группа: <span data-role="label" th:text="${group.groupLabel}">Без названия</span></h4>
                        </header>
                        <div class="grid">
                            <div>
                                <label>Отображаемое название</label>
                                <input type="text" th:field="*{materialGroups[__${gIndex.index}__].groupName}" data-field="groupName" placeholder="Например, Линия 1">
                            </div>
                            <div>
                                <label>Поверхность прокладки</label>
                                <input type="text" th:field="*{materialGroups[__${gIndex.index}__].surface}" data-field="surface" placeholder="По потолку, в земле...">
                            </div>
                        </div>
                        <div class="stack materials-container" th:id="${'material-rows-' + gIndex.index}">
                            <div class="material-row" th:each="usage, uIndex : *{materialGroups[__${gIndex.index}__].materials}" th:data-index="${uIndex.index}">
                                <div class="grid">
                                    <div>
                                        <label>Материал</label>
                                        <select th:field="*{materialGroups[__${gIndex.index}__].materials[__${uIndex.index}__].materialId}" data-field="materialId">
                                            <option value="">Не выбран</option>
                                            <option th:each="material : ${installationMaterials}" th:value="${material.id}" th:text="${material.name}"></option>
                                        </select>
                                    </div>
                                    <div>
                                        <label>Объем / длина</label>
                                        <input type="text" th:field="*{materialGroups[__${gIndex.index}__].materials[__${uIndex.index}__].amount}" data-field="amount" placeholder="25 м, 4 шт...">
                                    </div>
                                    <div>
                                        <label>По чему проложены</label>
                                        <input type="text" th:field="*{materialGroups[__${gIndex.index}__].materials[__${uIndex.index}__].layingSurface}" data-field="layingSurface" placeholder="По стене, в коробе...">
                                    </div>
                                </div>
                                <button type="button" class="link-button danger remove-material" th:if="${uIndex.index > 0}">Удалить материал</button>
                            </div>
                        </div>
                        <button type="button" class="button secondary add-material">Добавить материал</button>
                    </div>
                </div>
                <template id="material-group-template">
                    <div class="material-group card nested-card">
                        <input type="hidden" data-field="groupLabel">
                        <header class="group-header">
                            <h4 class="group-label">Группа: <span data-role="label">Без названия</span></h4>
                        </header>
                        <div class="grid">
                            <div>
                                <label>Отображаемое название</label>
                                <input type="text" data-field="groupName" placeholder="Например, Линия 1">
                            </div>
                            <div>
                                <label>Поверхность прокладки</label>
                                <input type="text" data-field="surface" placeholder="По потолку, в земле...">
                            </div>
                        </div>
                        <div class="stack materials-container">
                            <div class="material-row">
                                <div class="grid">
                                    <div>
                                        <label>Материал</label>
                                        <select data-field="materialId">
                                            <option value="">Не выбран</option>
                                            <option th:each="material : ${installationMaterials}" th:value="${material.id}" th:text="${material.name}"></option>
                                        </select>
                                    </div>
                                    <div>
                                        <label>Объем / длина</label>
                                        <input type="text" data-field="amount" placeholder="25 м, 4 шт...">
                                    </div>
                                    <div>
                                        <label>По чему проложены</label>
                                        <input type="text" data-field="layingSurface" placeholder="По стене, в коробе...">
                                    </div>
                                </div>
                                <button type="button" class="link-button danger remove-material">Удалить материал</button>
                            </div>
                        </div>
                        <button type="button" class="button secondary add-material">Добавить материал</button>
                    </div>
                </template>
                <template id="material-row-template">
                    <div class="material-row">
                        <div class="grid">
                            <div>
                                <label>Материал</label>
                                <select data-field="materialId">
                                    <option value="">Не выбран</option>
                                    <option th:each="material : ${installationMaterials}" th:value="${material.id}" th:text="${material.name}"></option>
                                </select>
                            </div>
                            <div>
                                <label>Объем / длина</label>
                                <input type="text" data-field="amount" placeholder="25 м, 4 шт...">
                            </div>
                            <div>
                                <label>По чему проложены</label>
                                <input type="text" data-field="layingSurface" placeholder="По стене, в коробе...">
                            </div>
                        </div>
                        <button type="button" class="link-button danger remove-material">Удалить материал</button>
                    </div>
                </template>
            </section>
        </div>

        <div class="form-row wizard-controls">
            <button type="button" class="button secondary" data-action="prev-step">Назад</button>
            <button type="button" class="button primary" data-action="next-step">Далее</button>
            <button type="submit" class="button" data-role="finish" hidden>Сохранить первичные данные</button>
            <a class="button secondary" th:href="@{'/objects/' + ${object.id}}">Отмена</a>
        </div>
    </form>
</main>
<footer class="footer">
    <p>Object Manager &copy; 2025</p>
</footer>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        const deviceContainer = document.getElementById('device-groups');
        const deviceTemplate = document.getElementById('device-group-template');
        const addDeviceButton = document.getElementById('add-device-group');
        const connectionTotal = document.getElementById('connection-total');
        const connectionContainer = document.getElementById('connection-points');
        const connectionTemplate = document.getElementById('connection-point-template');
        const connectionEmptyMessage = document.getElementById('connection-empty');
        const groupingContainer = document.getElementById('grouping-list');
        const groupingTemplate = document.getElementById('grouping-row-template');
        const groupLabelDatalist = document.getElementById('group-label-datalist');
        const materialGroupsContainer = document.getElementById('material-groups');
        const materialGroupTemplate = document.getElementById('material-group-template');
        const materialRowTemplate = document.getElementById('material-row-template');
        const materialsEmptyMessage = document.getElementById('materials-empty');
        const stepSections = Array.from(document.querySelectorAll('.wizard-step'));
        const stepButtons = Array.from(document.querySelectorAll('.wizard-progress-step'));
        const prevButton = document.querySelector('[data-action="prev-step"]');
        const nextButton = document.querySelector('[data-action="next-step"]');
        const finishButton = document.querySelector('[data-role="finish"]');

        let currentStep = 0;

        function showStep(index) {
            if (index < 0 || index >= stepSections.length) {
                return;
            }
            currentStep = index;
            stepSections.forEach((section, idx) => {
                if (idx === index) {
                    section.removeAttribute('hidden');
                    section.classList.add('active');
                } else {
                    section.setAttribute('hidden', 'hidden');
                    section.classList.remove('active');
                }
            });
            stepButtons.forEach(button => {
                const stepIndex = Number(button.dataset.stepIndex);
                const isActive = stepIndex === index;
                button.classList.toggle('active', isActive);
                button.disabled = isActive;
            });
            if (prevButton) {
                prevButton.disabled = index === 0;
            }
            if (nextButton) {
                nextButton.hidden = index === stepSections.length - 1;
            }
            if (finishButton) {
                finishButton.hidden = index !== stepSections.length - 1;
            }
        }

        stepButtons.forEach(button => {
            button.addEventListener('click', () => {
                const stepIndex = Number(button.dataset.stepIndex);
                if (!Number.isNaN(stepIndex)) {
                    showStep(stepIndex);
                }
            });
        });
        prevButton?.addEventListener('click', () => {
            if (currentStep > 0) {
                showStep(currentStep - 1);
            }
        });
        nextButton?.addEventListener('click', () => {
            if (currentStep < stepSections.length - 1) {
                showStep(currentStep + 1);
            }
        });

        function updateTotalConnectionPoints() {
            if (!connectionTotal || !deviceContainer) {
                return;
            }
            const counts = deviceContainer.querySelectorAll('input[data-field="deviceCount"]');
            let total = 0;
            counts.forEach(input => {
                const value = parseInt(input.value, 10);
                if (!Number.isNaN(value)) {
                    total += value;
                }
            });
            connectionTotal.textContent = total.toString();
        }

        function getDeviceGroups() {
            return Array.from(deviceContainer?.querySelectorAll('.device-group') ?? []);
        }

        function reindexDeviceGroups() {
            const groups = getDeviceGroups();
            groups.forEach((group, index) => {
                group.dataset.index = index.toString();
                group.querySelectorAll('[data-field]').forEach(field => {
                    const key = field.getAttribute('data-field');
                    if (!key) {
                        return;
                    }
                    field.setAttribute('name', `deviceGroups[${index}].${key}`);
                });
                const removeButton = group.querySelector('.remove-device');
                if (removeButton) {
                    removeButton.style.display = index === 0 ? 'none' : '';
                }
            });
            updateTotalConnectionPoints();
            reindexGroupingRows();
            syncConnectionPointsFromDevices();
            updateGroupingSummaries();
            syncMaterialGroupsWithLabels();
        }

        function addGroupingRow() {
            if (!groupingContainer || !(groupingTemplate instanceof HTMLTemplateElement)) {
                return;
            }
            const clone = groupingTemplate.content.firstElementChild.cloneNode(true);
            groupingContainer.appendChild(clone);
        }

        function reindexGroupingRows() {
            if (!groupingContainer) {
                return;
            }
            const groups = getDeviceGroups();
            let rows = Array.from(groupingContainer.querySelectorAll('.grouping-row'));
            while (rows.length < groups.length) {
                addGroupingRow();
                rows = Array.from(groupingContainer.querySelectorAll('.grouping-row'));
            }
            while (rows.length > groups.length) {
                const row = rows.pop();
                row?.remove();
            }
            rows = Array.from(groupingContainer.querySelectorAll('.grouping-row'));
            rows.forEach((row, index) => {
                row.dataset.index = index.toString();
                const input = row.querySelector('input[data-field="groupLabel"]');
                if (input) {
                    input.setAttribute('name', `deviceGroups[${index}].groupLabel`);
                }
            });
            updateGroupLabelSuggestions();
        }

        function getDeviceGroupData(index) {
            const group = deviceContainer?.querySelector(`.device-group[data-index="${index}"]`);
            if (!group) {
                return null;
            }
            const typeSelect = group.querySelector('select[data-field="deviceTypeId"]');
            const countInput = group.querySelector('input[data-field="deviceCount"]');
            const installInput = group.querySelector('input[data-field="installLocation"]');
            const connectionInput = group.querySelector('input[data-field="connectionPoint"]');
            const distanceInput = group.querySelector('input[data-field="distanceToConnectionPoint"]');
            const typeName = typeSelect instanceof HTMLSelectElement
                ? typeSelect.options[typeSelect.selectedIndex]?.text?.trim()
                : '';
            return {
                typeName: typeName || '',
                count: countInput?.value.trim() || '',
                installLocation: installInput?.value.trim() || '',
                connectionPoint: connectionInput?.value.trim() || '',
                distance: distanceInput?.value.trim() || ''
            };
        }

        function updateGroupingSummaries() {
            if (!groupingContainer) {
                return;
            }
            groupingContainer.querySelectorAll('.grouping-row').forEach(row => {
                const index = Number(row.dataset.index);
                const summary = row.querySelector('[data-role="summary"]');
                if (Number.isNaN(index) || !summary) {
                    return;
                }
                const data = getDeviceGroupData(index);
                if (!data) {
                    summary.textContent = 'Заполните информацию на первом шаге, чтобы увидеть сводку.';
                    return;
                }
                const parts = [];
                if (data.typeName) {
                    parts.push(data.typeName);
                }
                if (data.count) {
                    parts.push(`${data.count} шт.`);
                }
                if (data.installLocation) {
                    parts.push(`Установка: ${data.installLocation}`);
                }
                if (data.connectionPoint) {
                    parts.push(`Подключение: ${data.connectionPoint}`);
                }
                if (data.distance) {
                    parts.push(`Расстояние: ${data.distance} м`);
                }
                summary.textContent = parts.length > 0
                    ? parts.join(' • ')
                    : 'Заполните информацию на первом шаге, чтобы увидеть сводку.';
            });
        }

        function setConnectionPointError(input, message) {
            const row = input.closest('.connection-point');
            const errorElement = row?.querySelector('[data-role="error"]');
            if (!row || !errorElement) {
                return;
            }
            if (message) {
                errorElement.textContent = message;
                errorElement.hidden = false;
                input.classList.add('input-error');
            } else {
                errorElement.textContent = '';
                errorElement.hidden = true;
                input.classList.remove('input-error');
            }
        }

        function reindexConnectionPoints() {
            if (!connectionContainer) {
                return;
            }
            const rows = Array.from(connectionContainer.querySelectorAll('.connection-point'));
            rows.forEach((row, index) => {
                const nameInput = row.querySelector('input[data-field="name"]');
                const elementSelect = row.querySelector('select[data-field="mountingElementId"]');
                row.dataset.index = index.toString();
                if (nameInput) {
                    nameInput.setAttribute('name', `connectionPoints[${index}].name`);
                }
                if (elementSelect) {
                    elementSelect.setAttribute('name', `connectionPoints[${index}].mountingElementId`);
                }
            });
            if (connectionEmptyMessage) {
                connectionEmptyMessage.hidden = rows.length > 0;
            }
        }

        function syncConnectionPointsFromDevices() {
            if (!connectionContainer) {
                return;
            }
            const usageMap = new Map();
            const groups = getDeviceGroups();
            const rowMap = new Map();
            Array.from(connectionContainer.querySelectorAll('.connection-point')).forEach(row => {
                const key = (row.dataset.connectionName || '').trim();
                if (key) {
                    rowMap.set(key, row);
                }
                row.dataset.matched = 'false';
            });
            groups.forEach((group, index) => {
                const connectionInput = group.querySelector('input[data-field="connectionPoint"]');
                const name = connectionInput?.value.trim();
                if (!name) {
                    return;
                }
                if (!usageMap.has(name)) {
                    usageMap.set(name, []);
                }
                usageMap.get(name).push(index);
                let row = rowMap.get(name);
                if (!row) {
                    if (!(connectionTemplate instanceof HTMLTemplateElement)) {
                        return;
                    }
                    row = connectionTemplate.content.firstElementChild.cloneNode(true);
                    connectionContainer.appendChild(row);
                    rowMap.set(name, row);
                }
                row.dataset.matched = 'true';
                row.dataset.connectionName = name;
                const nameInput = row.querySelector('input[data-field="name"]');
                if (nameInput && nameInput.value.trim() !== name) {
                    nameInput.value = name;
                }
            });
            Array.from(connectionContainer.querySelectorAll('.connection-point')).forEach(row => {
                if (row.dataset.matched !== 'true') {
                    row.remove();
                } else {
                    row.removeAttribute('data-matched');
                }
            });
            reindexConnectionPoints();
            updateConnectionPointUsage(usageMap);
        }

        function updateConnectionPointUsage(usageMap) {
            if (!connectionContainer) {
                return;
            }
            Array.from(connectionContainer.querySelectorAll('.connection-point')).forEach(row => {
                const usageElement = row.querySelector('[data-role="usage"]');
                if (!usageElement) {
                    return;
                }
                const name = row.dataset.connectionName || '';
                const indices = usageMap.get(name) || [];
                if (indices.length === 0) {
                    usageElement.textContent = 'Нет привязанных устройств.';
                    return;
                }
                const descriptions = indices.map(index => {
                    const data = getDeviceGroupData(index);
                    if (!data) {
                        return `Устройство №${index + 1}`;
                    }
                    const parts = [];
                    if (data.typeName) {
                        parts.push(data.typeName);
                    } else {
                        parts.push(`Устройство №${index + 1}`);
                    }
                    if (data.count) {
                        parts.push(`${data.count} шт.`);
                    }
                    if (data.installLocation) {
                        parts.push(data.installLocation);
                    }
                    return parts.join(' — ');
                });
                usageElement.textContent = `Устройства: ${descriptions.join('; ')}`;
            });
        }

        function updateDeviceConnectionNames(oldName, newName) {
            if (!deviceContainer || !oldName || oldName === newName) {
                return;
            }
            Array.from(deviceContainer.querySelectorAll('input[data-field="connectionPoint"]')).forEach(input => {
                if (input.value.trim() === oldName) {
                    input.value = newName;
                }
            });
        }

        function collectGroupLabels() {
            if (!groupingContainer) {
                return [];
            }
            const seen = new Set();
            const labels = [];
            groupingContainer.querySelectorAll('input[data-field="groupLabel"]').forEach(input => {
                const value = input.value.trim();
                if (value && !seen.has(value)) {
                    seen.add(value);
                    labels.push(value);
                }
            });
            return labels;
        }

        function syncMaterialGroupsWithLabels() {
            if (!materialGroupsContainer) {
                return;
            }
            const labels = collectGroupLabels();
            const existing = Array.from(materialGroupsContainer.querySelectorAll('.material-group'));
            const groupMap = new Map(existing.map(group => [group.dataset.groupLabel || '', group]));
            const usedGroups = new Set();
            labels.forEach(label => {
                let group = groupMap.get(label);
                if (!group) {
                    if (!(materialGroupTemplate instanceof HTMLTemplateElement)) {
                        return;
                    }
                    group = materialGroupTemplate.content.firstElementChild.cloneNode(true);
                    materialGroupsContainer.appendChild(group);
                }
                group.dataset.groupLabel = label;
                const labelElement = group.querySelector('[data-role="label"]');
                if (labelElement) {
                    labelElement.textContent = label;
                }
                const hiddenInput = group.querySelector('input[data-field="groupLabel"]');
                if (hiddenInput) {
                    hiddenInput.value = label;
                }
                usedGroups.add(group);
            });
            existing.forEach(group => {
                if (!usedGroups.has(group)) {
                    group.remove();
                }
            });
            if (materialsEmptyMessage) {
                materialsEmptyMessage.hidden = labels.length > 0;
            }
            reindexMaterialGroups();
        }

        function reindexMaterialGroups() {
            if (!materialGroupsContainer) {
                return;
            }
            const groups = Array.from(materialGroupsContainer.querySelectorAll('.material-group'));
            groups.forEach((group, groupIndex) => {
                group.dataset.index = groupIndex.toString();
                const labelInput = group.querySelector('input[data-field="groupLabel"]');
                const nameInput = group.querySelector('input[data-field="groupName"]');
                const surfaceInput = group.querySelector('input[data-field="surface"]');
                if (labelInput) {
                    labelInput.setAttribute('name', `materialGroups[${groupIndex}].groupLabel`);
                }
                if (nameInput) {
                    nameInput.setAttribute('name', `materialGroups[${groupIndex}].groupName`);
                }
                if (surfaceInput) {
                    surfaceInput.setAttribute('name', `materialGroups[${groupIndex}].surface`);
                }
                const rows = Array.from(group.querySelectorAll('.material-row'));
                rows.forEach((row, rowIndex) => {
                    row.dataset.index = rowIndex.toString();
                    row.querySelectorAll('[data-field]').forEach(field => {
                        const key = field.getAttribute('data-field');
                        if (!key) {
                            return;
                        }
                        let name = '';
                        if (key === 'materialId') {
                            name = `materialGroups[${groupIndex}].materials[${rowIndex}].materialId`;
                        } else if (key === 'amount') {
                            name = `materialGroups[${groupIndex}].materials[${rowIndex}].amount`;
                        } else if (key === 'layingSurface') {
                            name = `materialGroups[${groupIndex}].materials[${rowIndex}].layingSurface`;
                        }
                        if (name) {
                            field.setAttribute('name', name);
                        }
                    });
                    const removeButton = row.querySelector('.remove-material');
                    if (removeButton) {
                        removeButton.style.display = rowIndex === 0 ? 'none' : '';
                    }
                });
            });
        }

        function updateGroupLabelSuggestions() {
            if (!groupLabelDatalist) {
                return;
            }
            groupLabelDatalist.innerHTML = '';
            collectGroupLabels().forEach(label => {
                const option = document.createElement('option');
                option.value = label;
                groupLabelDatalist.appendChild(option);
            });
        }

        addDeviceButton?.addEventListener('click', () => {
            if (!(deviceTemplate instanceof HTMLTemplateElement) || !deviceContainer) {
                return;
            }
            const clone = deviceTemplate.content.firstElementChild.cloneNode(true);
            deviceContainer.appendChild(clone);
            addGroupingRow();
            reindexDeviceGroups();
        });

        deviceContainer?.addEventListener('input', event => {
            const target = event.target;
            if (!(target instanceof HTMLInputElement)) {
                return;
            }
            const field = target.getAttribute('data-field');
            if (field === 'deviceCount') {
                updateTotalConnectionPoints();
            }
            if (field === 'connectionPoint') {
                syncConnectionPointsFromDevices();
                updateGroupingSummaries();
            } else if (field === 'installLocation' || field === 'distanceToConnectionPoint') {
                updateGroupingSummaries();
            }
        });

        deviceContainer?.addEventListener('change', event => {
            const target = event.target;
            if (target instanceof HTMLSelectElement && target.getAttribute('data-field') === 'deviceTypeId') {
                updateGroupingSummaries();
            }
        });

        deviceContainer?.addEventListener('click', event => {
            const target = event.target;
            if (!(target instanceof HTMLElement)) {
                return;
            }
            if (target.classList.contains('remove-device')) {
                const group = target.closest('.device-group');
                if (group && deviceContainer.children.length > 1) {
                    group.remove();
                    reindexDeviceGroups();
                }
            }
        });

        connectionContainer?.addEventListener('focusin', event => {
            const target = event.target;
            if (target instanceof HTMLInputElement && target.getAttribute('data-field') === 'name') {
                target.dataset.originalValue = target.value.trim();
            }
        });

        connectionContainer?.addEventListener('focusout', event => {
            const target = event.target;
            if (!(target instanceof HTMLInputElement) || target.getAttribute('data-field') !== 'name') {
                return;
            }
            const row = target.closest('.connection-point');
            if (!row) {
                return;
            }
            const oldValue = target.dataset.originalValue || row.dataset.connectionName || '';
            const newValue = target.value.trim();
            if (!newValue) {
                setConnectionPointError(target, 'Введите название точки подключения');
                target.value = oldValue;
                return;
            }
            const duplicate = Array.from(connectionContainer.querySelectorAll('.connection-point')).some(other => {
                if (other === row) {
                    return false;
                }
                const otherInput = other.querySelector('input[data-field="name"]');
                const otherName = other.dataset.connectionName || otherInput?.value.trim() || '';
                return otherName === newValue;
            });
            if (duplicate) {
                setConnectionPointError(target, 'Название должно быть уникальным');
                target.value = oldValue;
                return;
            }
            setConnectionPointError(target, null);
            row.dataset.connectionName = newValue;
            updateDeviceConnectionNames(oldValue, newValue);
            syncConnectionPointsFromDevices();
            updateGroupingSummaries();
        });

        groupingContainer?.addEventListener('input', event => {
            const target = event.target;
            if (target instanceof HTMLInputElement && target.getAttribute('data-field') === 'groupLabel') {
                syncMaterialGroupsWithLabels();
                updateGroupLabelSuggestions();
            }
        });

        materialGroupsContainer?.addEventListener('click', event => {
            const target = event.target;
            if (!(target instanceof HTMLElement)) {
                return;
            }
            if (target.classList.contains('add-material')) {
                event.preventDefault();
                const group = target.closest('.material-group');
                const rowsContainer = group?.querySelector('.materials-container');
                if (!group || !rowsContainer || !(materialRowTemplate instanceof HTMLTemplateElement)) {
                    return;
                }
                const clone = materialRowTemplate.content.firstElementChild.cloneNode(true);
                rowsContainer.appendChild(clone);
                reindexMaterialGroups();
                return;
            }
            if (target.classList.contains('remove-material')) {
                const row = target.closest('.material-row');
                const group = target.closest('.material-group');
                if (!row || !group) {
                    return;
                }
                const rows = group.querySelectorAll('.material-row');
                if (rows.length > 1) {
                    row.remove();
                    reindexMaterialGroups();
                }
            }
        });

        reindexDeviceGroups();
        showStep(0);
    });
</script>
</body>
</html>
